# 并发编程

**1、进程和线程的区别？**

进程是对运行时程序的封装，是**系统进行资源调度和分配的的基本单位，实现了操作系统的并发**；

线程是进程的子任务，**是CPU调度和分派的基本单位**，**用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位**。每个线程都独自占用一个**虚拟处理器**：独自的**寄存器组**，**指令计数器和处理器状态**。每个线程完成不同的任务，但是**共享同一地址空间**（也就是同样的**动态内存，映射文件，目标代码等等**），**打开的文件队列和其他内核资源**。



**2、什么是原子性、可见性、有序性？**

**原子性**：一个操作或多个操作要么全部执行完成且执行过程不被中断，要么就不执行。

**可见性**：当多个线程同时访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 violate

**有序性**：程序执行的顺序按照代码的先后顺序执行。重排序问题



**3、为什么要使用多线程？**

简单来说就是为了提高效率

在单核CPU中，多线程主要是为了降低阻塞。 多线程的并发，其实是一种“伪并行”。 在每个时刻，真正执行的只有一个线程。 但是，由于多线程减少了等待IO操作（比如：磁盘、网络、[数据库](https://cloud.tencent.com/solution/database?from=20065&from_column=20065)等）时间， 所以，多线程大大提高了程序的效率。

正因为追求效率，后面我们会看到线程池的应用， 线程池的产生就是因为线程之间的创建、撤销、切换具有较大的时空开销， 尽管它的开销比较进程要小得多。



**4、创建线程有哪几种方式？**

**1、继承 Thread 类**

通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。

- 首先定义一个类来继承 Thread 类，重写 run 方法。
- 然后创建这个子类对象，并调用 start 方法启动线程。

![img](https://ask.qcloudimg.com/http-save/yehe-2219188/uaa1zy9cb5.png?imageView2/2/w/1200)

**2、实现 Runnable 接口**

通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。

- 首先定义一个类实现 Runnable 接口，并实现 run 方法。
- 然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中
- 最后调用 start 方法启动线程。

![img](https://ask.qcloudimg.com/http-save/yehe-2219188/qucp8pstk7.png?imageView2/2/w/1200)

**3、实现 Callable 接口，并结合 Future 实现**

- 首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。
- 然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。
- 把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。
- 通过 FutureTask 的 get 方法获取线程的执行结果。

![img](https://ask.qcloudimg.com/http-save/yehe-2219188/zglut4qdvh.png?imageView2/2/w/1200)

**4、通过线程池创建线程**

此处用 JDK 自带的 Executors 来创建线程池对象。

- 首先，定一个 Runnable 的实现类，重写 run 方法。
- 然后创建一个拥有固定线程数的线程池。
- 最后通过 ExecutorService 对象的 execute 方法传入线程对象。

![img](https://ask.qcloudimg.com/http-save/yehe-2219188/grx8pgz81h.png?imageView2/2/w/1200)



**5、什么是守护线程？**

Java 中的线程分为两类，分别为 daemon 线程（守护线程〉和 user 线程（用户线程）。

在 JVM 启动时会调用 main 函数， main 函数所在的线程就是一个用户线程，其实在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。

**守护线程定义**：所谓守护线程，是指在程序运行的时候在后台提供一种通用服务的线程。比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。

因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。

**用户线程定义**：某种意义上的主要用户线程，只要有用户线程未执行完毕，JVM 虚拟机不会退出。

**区别**：在本质上，用户线程和守护线程并没有太大区别，唯一的区别就是当最后一个非守护线程结束时，JVM 会正常退出，而不管当前是否有守护线程，也就是说守护线程是否结束并不影响 JVM 的退出。

言外之意，只要有一个用户线程还没结束， 正常情况下 JVM 就不会退出。

3. 守护线程的特点

Java 中的守护线程和 Linux 中的守护进程是有些区别的，Linux 守护进程是系统级别的，当系统退出时，才会终止。

而 Java 中的守护线程是 JVM 级别的，当 JVM 中无任何用户进程时，守护进程销毁，JVM 退出，程序终止。总结来说，Java 守护进程的最主要的特点有:

- 守护线程是运行在程序后台的线程；
- 守护线程创建的线程，依然是守护线程；
- 守护线程不会影响 JVM 的退出，当 JVM 只剩余守护线程时，JVM 进行退出；
- 守护线程在 JVM 退出时，自动销毁。

**创建方式**：将线程转换为守护线程可以通过调用 Thread 对象的 setDaemon (true) 方法来实现。

**创建细节**：

- thread.setDaemon (true) 必须在 thread.start () 之前设置，否则会跑出一个 llegalThreadStateException 异常。你不能把正在运行的常规线程设置为守护线程；
- 在 Daemon 线程中产生的新线程也是 Daemon 的；
- 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

6. 守护线程的作用及使用场景

**作用**：我们以 GC 垃圾回收线程举例，它就是一个经典的守护线程，当我们的程序中不再有任何运行的 Thread, 程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。

它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。

**应用场景**：

- 为其它线程提供服务支持的情况，可选用守护线程；

- 根据开发需求，程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用；

- 如果一个正在执行某个操作的线程必须要执行完毕后再释放，否则就会出现不良的后果的话，那么这个线程就不能是守护线程，而是用户线程；

- 正常开发过程中，一般心跳监听，垃圾回收，临时数据清理等通用服务会选择守护线程。

  

**6、线程的状态有哪几种？怎么流转的？**

![image-20230603142022520](http://8.130.25.175:8080/img/image-20230603142022520.png)

**7、线程的优先级有什么用？**

\* Thread.setPriority()可能根本不做任何事情，这跟你的操作系统和虚拟机版本有关
\* 线程优先级对于不同的线程调度器可能有不同的含义，可能并不是你直观的推测。特别地，优先级并不一定是指CPU的分享。在UNIX系统，优先级或多或少可以认为是CPU的分配，但Windows不是这样
\* 线程的优先级通常是全局的和局部的优先级设定的组合。Java的setPriority()方法只应用于局部的优先级。换句话说，你不能在整个可能的范围 内设定优先级。（这通常是一种保护的方式，你大概不希望鼠标指针的线程或者处理音频数据的线程被其它随机的用户线程所抢占）
\* 不同的系统有不同的线程优先级的取值范围，但是Java定义了10个级别（1-10）。这样就有可能出现几个线程在一个操作系统里有不同的优先级，在另外一个操作系统里却有相同的优先级（并因此可能有意想不到的行为）
\* 操作系统可能（并通常这么做）根据线程的优先级给线程添加一些专有的行为（例如”only give a quantum boost if the priority is below X“）。这里再重复一次，优先级的定义有部分在不同系统间有差别。
\* 大多数操作系统的线程调度器实际上执行的是在战略的角度上对线程的优先级做临时操作（例如当一个线程接收到它所等待的一个事件或者I/O），通常操作系统知道最多，试图手工控制优先级可能只会干扰这个系统。
\* 你的应用程序通常不知道有哪些其它进程运行的线程，所以对于整个系统来说，变更一个线程的优先级所带来的影响是难于预测的。例如你可能发现，你有一个预期 为偶尔在后台运行的低优先级的线程几乎没有运行，原因是一个病毒监控程序在一个稍微高一点的优先级（但仍然低于普通的优先级）上运行，并且无法预计你程序 的性能，它会根据你的客户使用的防病毒程序不同而不同。



**8、我们常说的 JUC 是指什么？**

https://blog.51cto.com/u_9177933/3002229



**9、i++ 是线程安全的吗？**

不是，i++三步操作，并非原子指令。



**10、join 方法有什么用？什么原理？**

Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。

```java
public class JoinTest {
 public static void main(String [] args) throws InterruptedException {
  ThreadJoinTest t1 = new ThreadJoinTest("小明");
  ThreadJoinTest t2 = new ThreadJoinTest("小东");
  t1.start();
  /**join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是：
程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕
所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会
*/
  t1.join();
  t2.start();
 }
 
}
class ThreadJoinTest extends Thread{
 public ThreadJoinTest(String name){
  super(name);
 }
 @Override
 public void run(){
  for(int i=0;i<1000;i++){
System.out.println(this.getName() + ":" + i);
  }
 }
}
```

面程序结果是先打印完小明线程，在打印小东线程；　

　

上面注释也大概说明了join方法的作用：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。注意，这里调用的join方法是没有传参的，join方法其实也可以传递一个参数给它的，具体看下面的简单例子：

 

```java
public class JoinTest {
 public static void main(String [] args) throws InterruptedException {
  ThreadJoinTest t1 = new ThreadJoinTest("小明");
  ThreadJoinTest t2 = new ThreadJoinTest("小东");
  t1.start();
  /**join方法可以传递参数，join(10)表示main线程会等待t1线程10毫秒，10毫秒过去后，
* main线程和t1线程之间执行顺序由串行执行变为普通的并行执行
*/
  t1.join(10);
  t2.start();
 }
 
}
class ThreadJoinTest extends Thread{
 public ThreadJoinTest(String name){
  super(name);
 }
 @Override
 public void run(){
  for(int i=0;i<1000;i++){
System.out.println(this.getName() + ":" + i);
  }
 }
}
1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23.24.
```

上面代码结果是：程序执行前面10毫秒内打印的都是小明线程，10毫秒后，小明和小东程序交替打印。

 

所以，join方法中如果传入参数，则表示这样的意思：如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。需要注意的是，jdk规定，join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join()。



**11、如何让一个线程休眠？**

方法1：Thread.sleep方法2：TimeUnit方法3：wait方法4：Condition方法5：LockSupport总结

在 java 中，让线程休眠的方法有很多，这些方法大致可以分为两类，一类是设置时间，在一段时间后自动唤醒，而另一个类是提供了一对休眠和唤醒的方法，在线程休眠之后，可以在任意时间对线程进行唤醒。



方法2：TimeUnit

sleep 方法因为要传递一个毫秒类型的参数，因此在设置大一点的时间时比较麻烦，比如设置 1 小时或 1 天时，此时我们就可以使用 TimeUnit 来替代 sleep 方法实现休眠。 TimeUnit 的功能和 sleep 一样，让线程休眠 N 个单位时间之后自动唤醒，它的基础用法如下：

```java
Thread t1 = new Thread() {

@Override

public void run() {

System.out.println("线程执行：" + LocalDateTime.now());

try {

TimeUnit.SECONDS.sleep(1); // 休眠 1s

//TimeUnit.DAYS.sleep(1); // 休眠 1 天

} catch (InterruptedException e) {

e.printStackTrace();

}

System.out.println("线程结束：" + LocalDateTime.now());

}

};

t1.start();
```

方法3：wait

wait/notify/notifyAll 都来自于 Object 类，其中：

wait() / wait(long timeout)：表示让当前线程进入休眠状态。notify()：唤醒当前对象上的一个休眠线程。notifyAll()：唤醒当前对象上的所有休眠线程。

其中 wait() 方法表示让当前线程无限期等待下去，直到遇到 notify/notifyAll 方法时才会被唤醒，而 wait(long timeout) 表示接收一个 long 类型的超时时间，如果没有遇到 notify/notifyAll 会在 long 毫秒之后自动唤醒，如果遇到了 notify/notifyAll 方法会立即被唤醒。 它的基础用法如下：

```java
Object lock = new Object();

new Thread(() -> {

synchronized (lock) {

try {

// 让当前线程休眠

lock.wait();

} catch (InterruptedException e) {

e.printStackTrace();

}

}

}).start();

synchronized (lock) {

lock.notify(); // 唤醒当前对象上一个休眠线程

// lock.notifyAll(); // 唤醒当前对象上所有休眠的线程

}
```

需要注意的是 wait/notify/notifyAll 在使用时必须要配合 synchronized 一起使用，否则程序执行会报错。



方法4：Condition

Condition 作为 wait 的升级版，它提供的常用方法有以下几个：

await()：让当前线程进入等待状态，直到被通知（signal）或者被中断时才会继续执行。awaitUninterruptibly()：让当前线程进入等待状态，直到被通知才会被唤醒，它对线程的中断通知不做响应。await(long time, TimeUnit unit)：在 alLFAFMdwait() 方法的基础上添加了超时时间，如果过了超时时间还没有遇到唤醒方法则会自动唤醒并恢复执行。awaitUntil(Date deadline)：让当前线程进入等待状态，如果没有遇到唤醒方法也会在设置的时间之后自动唤醒。signal()：唤醒一个等待在 Condition 上的线程。signalAll()：唤醒等待在 Condition 上所有的线程。

它的基本用法如下：

```java
import java.time.LocalDateTime;

import java.util.concurrent.locks.Condition;

import java.util.concurrent.locks.Lock;

import java.util.concurrent.locks.ReentrantLock;

public class ConditionExample {

public static void main(String[] args) throws InterruptedException {

// 创建锁

final Lock lock = new ReentrantLock();

// 创建 Condition

final Condition condition = lock.newCondition();

new Thread(() -> {

System.out.println("线程执行：" + LocalDateTime.now());

lock.lock(); // 得到锁

try {

// 休眠线程

condition.await();

} catch (InterruptedException e) {

e.printStackTrace();

} finally {

lock.unlock(); // 释放锁

}

System.out.println("线程结束：" + LocalDateTime.now());

}).start();

Thread.sleep(1000);

lock.lock(); // 得到锁

try {

// 唤醒线程

condition.signal();

} finally {

lock.unlock(); // 释放锁

}

}

}
```

相比于 wait 方法，Condition 对象更加灵活，因为它可以在一把锁上定义多个 Condition 对象进行使用，



**12、启动一个线程是用 start 还是 run 方法？**

启动线程肯定要用start()方法。当用start()开始一个线程后，线程就进入**就绪状态**，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这**并不意味着线程就会立即运行**。当cpu分配给它时间时，才开始执行run()方法(如果有的话)。start()是方法,它调用run()方法。而run()方法是你必须重写的. run()方法中包含的是线程的主体。



**13、start 和 run 方法有什么区别？**

```java
public class Test1 extends Thread {

@Override

public void run() {

while (true)

{

System.out.println(Thread.currentThread().getName());

}

}

public static void main(String[] args) {

Test1 test1=new Test1();

test1.run(); //输出结果:main(当前线程名)

test1.start(); //输出结果 Thread-0（新启动的线程名）

}

}
```

1.start

start作用是启动一个新线程。

当用start()开始一个线程后，线程就进入就绪状态，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。但是这并不意味着线程就会立即运行。只有当cpu分配时间片时，这个线程获得时间片时，才开始执行run()方[http](https://www.eolink.com/news/tags-1144.html)://法。start()不能被重复调用，它调用run()[方法](https://www.eolink.com/news/tags-1160.html).run()方法是你必须重写的

2.run

run()就和普通的成员方法一样，可以被重复调用。

如果直接调用run方法，并不会启动新线程！程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。

调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。





**14、sleep 和 wait 方法有什么区别？**

Java 中 `wait` 和 `sleep` 之间的区别或者 `sleep` 和 `yield` 之间的区别是流行的核心 Java 面试问题之一，并且在多线程面试中被问到。 在 Java 中可用于暂停线程的三种方法中，`sleep()` 和 `yield()` 方法定义在线程类中，而 `wait()` 方法定义在 Object 类中，这是另一个面试问题。 `wait()` 和 `sleep()` 之间的主要区别在于前者用于线程间通信，而后者用于引入以暂停当前线程一小段时间。

这种区别在以下事实中更加明显：当一个线程调用 `wait()` 方法时，它会释放它持有的监视器或锁定该对象，但是当一个线程调用 `sleep()` 方法时，它甚至不会释放监视器 如果它持有。

回到 `yield()`，它与 `wait()` 和 `sleep()` 没什么不同，它只是释放线程占用的 CPU，让另一个线程有机会运行，但不能保证谁会获得 CPU。

这完全取决于线程调度程序，调用 `yield()` 方法的线程甚至有可能再次获得 CPU。 因此，依赖 `yield()` 方法是不可靠的，它只是在尽力而为的基础上。



**15、Thread.yield 方法有什么用？**

Thread yield()方法的作用是暂停当前线程，以便其他线程有机会执行，不过不能指定暂停的时间，并且也不能保证当前线程马上停止。yield方法只是将Running状态转变为Runnable状态。



**16、yield 和 sleep 有什么区别？**

sleep()方法：可以让正在运行的线程进入阻塞状态，直到休眠时间满了，进入就绪状 态yield()方法：可以让正在运行的线程直接进入就绪状态，让出 CPU 的使用权。

yield 方法的使用 yield()方法的作用：暂停当前正在执行的线程，并执行其他线程。 yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得 运行的机会。因此，使用 yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。 但是，实际中无法保证 yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次 选中。



**17、怎么理解 Java 中的线程中断？**

线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。

```java
try {
				Thread.sleep(3000);
			} catch (InterruptedException e) {
				System.out.println("Java技术栈线程休眠被中断，程序退出。");
				Thread.currentThread().interrupt();
			}

```

**18、你怎么理解多线程分组？**

```java
/**

 * 微信公众号：Java技术栈
   */
   public static void main(String[] args) {
   Runnable runnable = () -> {
   	System.out.println("Java技术栈线程线程组名称：" + Thread.currentThread().getThreadGroup());
   	System.out.println("Java技术栈线程线程名称：" + Thread.currentThread().getName());
   	try {
   		Thread.sleep(3000);
   	} catch (InterruptedException e) {
   		e.printStackTrace();
   	}
   };

   ThreadGroup userGroup = new ThreadGroup("user");
   userGroup.setMaxPriority(Thread.MIN_PRIORITY);

   Thread userTask1 = new Thread(userGroup, runnable, "user-task1");
   Thread userTask2 = new Thread(userGroup, runnable, "user-task2");

   userTask1.start();
   userTask2.start();

   System.out.println("Java技术栈线程线程组活跃线程数：" + userGroup.activeCount());
   userGroup.list();

}
```


程序输出以下结果。

程序输出以下结果。

```
Java技术栈线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]
Java技术栈线程线程名称：user-task1
Java技术栈线程线程组活跃线程数：2
Java技术栈线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]
Java技术栈线程线程名称：user-task2
java.lang.ThreadGroup[name=user,maxpri=1]
    Thread[user-task1,1,user]
    Thread[user-task2,1,user]
```


根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。

线程组还能统一设置**组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级**。

另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程**中断**功能进行优雅终止线程。



**19、你怎么理解 wait、notify、notifyAll？**

在Java中，每个对象都有两个池，锁(monitor)池和等待池

锁池

锁池:假设线程A已经拥有了某个对象的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。

等待池

等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁)，同时线程A就进入到了该对象的等待池中。如果另外的一个线程调用了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池.

notify 和 notifyAll 的区别

wait()

public final void wait() throws InterruptedException,IllegalMonitorStateException
该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用 wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait()方法。进入 wait()方法后，当前线程释放锁。在从 wait()返回前，线程与其他线程竞争重新获得锁。如果调用 wait()时，没有持有适当的锁，则抛出 IllegalMonitorStateException，它是 RuntimeException 的一个子类，因此，不需要 try-catch 结

notify()

public final native void notify() throws IllegalMonitorStateException
该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，的如果调用 notify()时没有持有适当的锁，也会抛出 IllegalMonitorStateException。
该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个 wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify 后，当前线程不会马上释放该对象锁，wait 所在的线程并不能马上获取该对象锁，要等到程序退出 synchronized 代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。当第一个获得了该对象锁的 wait 线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用 notify 语句，则即便该对象已经空闲，其他 wait 状态等待的线程由于没有得到该对象的通知，会继续阻塞在 wait 状态，直到这个对象发出一个 notify 或 notifyAll。这里需要注意：它们等待的是被 notify 或 notifyAll，而不是锁。这与下面的 notifyAll()方法执行后的情况不同。

notifyAll()

public final native void notifyAll() throws IllegalMonitorStateException
该方法与 notify ()方法的工作方式相同，重要的一点差异是：
notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待 notify 或 notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll 线程退出调用了 notifyAll 的 synchronized 代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。





**20、同步和异步的区别？**

同步与异步是指访问数据的机制，同步一般指主动请求并等待IO操作完成的方式。
异步则指主动请求数据后便可以继续处理其它任务，随后等待IO操作完毕的通知。
同步和异步最大的区别就在于：同步需要等待，异步不需要等待。

阻塞与非阻塞是描述线程在访问某个资源时，数据是否准备就绪的一种处理方式。当数据没有准备就绪时：
阻塞：线程持续等待资源中数据准备完成，直到返回响应结果。
非阻塞：线程直接返回结果，不会持续等待资源准备数据结束后才响应结果。

① 阻塞与非阻塞是针对线程来说的，阻塞可能发生在IO期间也可能发生在IO之前。
② 同步与异步是针对IO操作来说的，同步是用户线程一直盯着IO直到完成，异步是用户线程在IO完成时会收到通知。

**21、什么是死锁？**

互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。
循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。



**22、怎么避免死锁？**

1.破坏“占有且等待”条件:所有的进程在开始运行之前，必须**一次性地申请其在整个运行过程中所需要的全部资源**。

2.破坏“不可抢占”条件:当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。

3.破坏“循环等待”条件;采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将**紧缺的，稀少的采用较大的编号**，在申请资源时必须按照编号的顺序进行（**从小往大申请**），一个进程只有获得较小编号的进程才能申请较大编号的进程。

**死锁避免算法**：银行家算法

安全序列：

![1358881-20191125164249992-1856910147](http://8.130.25.175:8080/img/1358881-20191125164249992-1856910147.png)

1）系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。
2）安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态。

银行家算法的实质就是**要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。**即没当进程提出资源请求且系统的资源能够满足该请求时，系统将判断满足此次资源请求后系统状态是否安全，如果判断结果为安全，则给该进程分配资源，否则不分配资源，申请资源的进程将阻塞。

银行家算法的执行有个前提条件，即要求进程预先提出自己的最大资源请求，并假设系统拥有固定的资源总量。下面介绍银行家算法所用的主要的数据结构。

多个线程均分得一部分资源，但没完全满足，可能出现没资源可分的情况，这样的情况会出现死锁。

![1358881-20191125171934215-167814328](http://8.130.25.175:8080/img/1358881-20191125171934215-167814328.png)

![1358881-20191125172027066-647382599](http://8.130.25.175:8080/img/1358881-20191125172027066-647382599.png)

**23、什么是活锁？**

活锁指的是**任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败**。 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。 活锁可以认为是一种特殊的饥饿。

活锁指的是线程不断重复执行相同的操作，但每次操作的结果都是失败的。尽管这个问题不会阻塞线程，但是程序也无法继续执行。活锁通常发生在处理事务消息的应用程序中，如果不能成功处理这个事务那么事务将回滚整个操作。解决活锁的办法是在每次重复执行的时候引入随机机制，这样由于出现的可能性不同使得程序可以继续执行其他的任务。



**24、什么是无锁？**





**25、什么是线程饥饿？**

**26、什么是 CAS？**

**27、阻塞和非阻塞的区别？**

**28、并发和并行的区别？**

**29、为什么不推荐使用 stop 停止线程？**

**30、如何优雅地终止一个线程？**

Thread.interrupt()

`Thread`提供了`interrupt()`方法，它没有像`stop()`方法那样，直接中断一个线程的执行，而是通过信号量来通知线程可以停止执行了，当线程收到该信号量时，可以通过`isInterrupted()`方法判断当前是否需要中断。这样的停止方式，相比`stop()`是不是更加友好，让线程自己判断能否中断，从而保证业务处理的完整性。



**31、Synchronized 同步锁有哪几种用法？**

在 Java 语言中，保证线程安全性的主要手段是加锁，而 Java 中的锁主要有两种：synchronized 和 Lock，我们今天重点来看一下 synchronized 的几种用法。

使用 synchronized 无需手动执行加锁和释放锁的操作，我们只需要声明 synchronized 关键字就可以了，JVM 层面会帮我们自动的进行加锁和释放锁的操作。
synchronized 可用于修饰**普通方法、静态方法和代码块**

修饰普通方法 VS 修饰静态方法

synchronized 修饰普通方法和静态方法看似相同，但二者完全不同，**对于静态方法来说 synchronized 加锁是全局的，也就是整个程序运行期间，所有调用这个静态方法的对象都是互斥的，而普通方法是针对对象级别的，不同的对象对应着不同的锁**，

修饰代码块

我们在日常开发中，最常用的是给代码块加锁，而不是给方法加锁，因为给方法加锁，相当于给整个方法全部加锁，这样的话锁的粒度就太大了，程序的执行性能就会受到影响，所以通常情况下，我们会使用 synchronized 给代码块加锁

this VS class

使用 synchronized 加锁 this 和 xxx.class 是完全不同的，当加锁 this 时，表示用当前的对象进行加锁，每个对象都对应了一把锁；而当使用 xxx.class 加锁时，表示使用某个类（而非类实例）来加锁，它是应用程序级别的，是全局生效的。

synchronized (this)会对加锁本对象的执行这个代码块进行加锁。（本对象）

synchronized (class)会对加锁本类的执行这个代码块进行加锁。（全局）



**32、什么是重入锁（ReentrantLock）？**

可重入锁，也叫做 **递归锁**，从名字上理解，字面意思就是再进入的锁，重入性是指任意线程在获取到锁之后能够再次获取该锁而不会被锁阻塞，首先他需要具备两个条件：

1. **线程再次获取锁**：所需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次获取成功
2. **锁的最终释放**：线程重复n次获取了锁，随后在第n次释放该锁后，其它线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前线程被重复获取的次数，而被释放时，计数自减，当计数为0时表示锁已经成功释放。



**33、Synchronized 与 ReentrantLock 的区别？**

synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。



ReentrantLock 在使用之前需要先创建 ReentrantLock 对象，然后使用 lock 方法进行加锁，使用完之后再调用 unlock 方法释放锁



**34、synchronized 锁的是什么?**







**35、什么是读写锁？**

https://www.51cto.com/article/708233.html

读写锁(Readers-Writer Lock)顾名思义是一把锁分为两部分：读锁和写锁，其中读锁允许多个线程同时获得，因为读操作本身是线程安全的，而写锁则是互斥锁，不允许多个线程同时获得写锁，并且写操作和读操作也是互斥的。总结来说，读写锁的特点是：读读不互斥、读写互斥、写写互斥。

```
// 创建读写锁
final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
// 获得读锁
final ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();
// 获得写锁
final ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();
// 读锁使用
readLock.lock();
try {
    // 业务代码...
} finally {
    readLock.unlock();
}
// 写锁使用
writeLock.lock();
try {
    // 业务代码...
} finally {
    writeLock.unlock();
}
```

**36、公平锁和非公平锁的区别？**

https://www.cnblogs.com/vipstone/p/16248006.html

公平锁：每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的，最前面的线程总是最先获取到锁。
非公平锁：每个线程获取锁的顺序是随机的，并不会遵循先来先得的规则，所有线程会竞争获取锁。

在 Java 语言中，锁 synchronized 和 ReentrantLock 默认都是非公平锁，当然我们在创建 ReentrantLock 时，可以手动指定其为公平锁，但 synchronized 只能为非公平锁。

ReentrantLock 默认为非公平锁可以在它的源码实现中得到验证，如下源码所示：

![image](http://8.130.25.175:8080/img/image.png)

当使用 new ReentrantLock(true) 时，可以创建公平锁，如下源码所示：

![image (1)](http://8.130.25.175:8080/img/image (1).png)



**37、有哪些锁优化的方式？**

为了提升性能，JDK1.6 引入了偏向锁、轻量级锁、重量级锁概念，来减少锁竞争带来的上下文切换，而正是新增的 Java 对象头实现了锁升级功能。



**38、什么是偏向锁？**

**偏向锁主要用来优化同一线程多次申请同一个锁的竞争**。在某些情况下，大部分时间是同一个线程竞争锁资源，例如，在创建一个线程并在线程中执行循环监听的场景下，或单线程操作一个线程安全集合时，同一线程每次都需要获取和释放锁，每次操作都会发生用户态与内核态的切换。

偏向锁的作用就是，当一个线程再次访问这个同步代码或方法时，该线程只需去对象头的 Mark Word 中去判断一下是否有偏向锁指向它的 ID，无需再进入 Monitor 去竞争对象了。**当对象被当做同步锁并有一个线程抢到了锁时，锁标志位还是 01，“是否偏向锁”标志位设置为 1，并且记录抢到锁的线程 ID，表示进入偏向锁状态。**

一旦出现其它线程竞争锁资源时，偏向锁就会被撤销。偏向锁的撤销需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被其它线程抢占。

**下图中红线流程部分为偏向锁获取和撤销流程：**

![43f90d5e5ec3e9d311a84027caf44e24](http://8.130.25.175:8080/img/43f90d5e5ec3e9d311a84027caf44e24.png)

因此，在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生 stop the word 后， 开启偏向锁无疑会带来更大的性能开销，这时我们可以通过添加 JVM 参数关闭偏向锁来调优系统性能，示例代码如下：

```cpp
-XX:-UseBiasedLocking // 关闭偏向锁（默认打开）
```

或

```cpp
-XX:+UseHeavyMonitors  // 设置重量级锁
```



**39、什么是轻量级锁？**

当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头 Mark Word 中的线程 ID 不是自己的线程 ID，就会进行 CAS 操作获取锁，如果获取成功，直接替换 Mark Word 中的线程 ID 为自己的 ID，该锁会保持偏向锁状态；如果获取锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。

轻量级锁适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争。

**下图中红线流程部分为升级轻量级锁及操作流程：**

![6bdab4d622bec1806526425bcc3724df](http://8.130.25.175:8080/img/6bdab4d622bec1806526425bcc3724df.png)

**40、什么是自旋锁？**

轻量级锁 CAS 抢锁失败，线程将会被挂起进入阻塞状态。如果正在持有锁的线程在很短的时间内释放资源，那么进入阻塞状态的线程无疑又要申请锁资源。

JVM 提供了一种自旋锁，可以通过自旋方式不断尝试获取锁，从而避免线程被挂起阻塞。这是基于大多数情况下，线程持有锁的时间都不会太长，毕竟线程被挂起阻塞可能会得不偿失。

从 JDK1.7 开始，自旋锁默认启用，自旋次数由 JVM 设置决定，这里我不建议设置的重试次数过多，因为 CAS 重试操作意味着长时间地占用 CPU。

自旋锁重试之后如果抢锁依然失败，同步锁就会升级至重量级锁，锁标志位改为 10。在这个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在 _WaitSet 队列中。

**下图中红线流程部分为自旋后升级为重量级锁的流程：**

![](http://8.130.25.175:8080/img/fa85ab7b61a1a7ad410b3e7158e1c05d.png)

在锁竞争不激烈且锁占用时间非常短的场景下，自旋锁可以提高系统性能。一旦锁竞争激烈或锁占用的时间过长，自旋锁将会导致大量的线程一直处于 CAS 重试状态，占用 CPU 资源，反而会增加系统性能开销。所以自旋锁和重量级锁的使用都要结合实际场景。

在高负载、高并发的场景下，我们可以通过设置 JVM 参数来关闭自旋锁，优化系统性能，示例代码如下：

```cpp
-XX:-UseSpinning // 参数关闭自旋锁优化 (默认打开) 
-XX:PreBlockSpin // 参数修改默认的自旋次数。JDK1.7 后，去掉此参数，由 jvm 控制
```



**41、什么是锁消除？**

除了锁升级优化，Java 还使用了编译器对锁进行优化。JIT 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。

确认是的话，那么 JIT 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁的申请与释放的机器码，即消除了锁的使用。在 Java7 之后的版本就不需要手动配置了，该操作可以自动实现。



**42、什么是锁粗化？**

锁粗化同理，就是在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。



**43、什么是重量级锁？**

JVM 在 JDK1.6 中引入了分级锁机制来优化 Synchronized，当一个线程获取锁时，首先对象锁将成为一个偏向锁，这样做是为了优化同一线程重复获取导致的用户态与内核态的切换问题；其次如果有多个线程竞争锁资源，锁将会升级为轻量级锁，它适用于在短时间内持有锁，且分锁有交替切换的场景；偏向锁还使用了自旋锁来避免线程用户态与内核态的频繁切换，大大地提高了系统性能；但如果锁竞争太激烈了，那么同步锁将会升级为重量级锁。

减少锁竞争，是优化 Synchronized 同步锁的关键。我们应该尽量使 Synchronized 同步锁处于轻量级锁或偏向锁，这样才能提高 Synchronized 同步锁的性能；通过减小锁粒度来降低锁竞争也是一种最常用的优化方法；另外我们还可以通过减少锁的持有时间来提高 Synchronized 同步锁在自旋时获取锁资源的成功率，避免 Synchronized 同步锁升级为重量级锁。



**44、什么是线程池？**

https://zhuanlan.zhihu.com/p/36551354

线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。

Java中有三个比较常用的线程池，分别是FixedThreadPool，SingleThreadExecutor，CachedThreadPool。

\1) FixedThreadPool

这是一个线程数固定的线程池，当这个线程池被创建的时候，池里的线程数就已经固定了。当需要运行的线程数量大体上变化不大时，适合使用这种线程池。固定数量还有一个好处，它可以一次性支付高昂的创建线程的开销，之后再使用的时候就不再需要这种开销。

\2) SingleThreadExecutor

这是一个线程数量为1的线程池，所有提交的这个线程池的任务都会按照提交的先后顺序排队执行。单个线程执行有个好处：由于任务之间没有并发执行，因此提交到线程池种的任务之间不会相互干扰。程序执行的结果更具有确定性。

\3) CachedThreadPool

一看到Cache就知道这是一个和缓存有关的线程池，每次有任务提交到线程池的时候，如果池中没有空闲的线程，线程池就会为这个任务创建一个线程，如果有空闲的线程，就会使用已有的空闲线程执行任务。有的人可能会有个疑惑：这样线程不就越来越多了吗？其实不是的，这个线程池还有一个销毁机制，如果一个线程60秒之内没有被使用过，这个线程就会被销毁，这样就节省了很多资源。CachedThreadPool是一个比较通用的线程池，它在多数情况下都能表现出优良的性能。以后编码的时候，遇事不决，用缓存（线程池）。



**45、使用线程池有什么好处？**

前面的基础中发现创建线程的方式只有一种使用Thread方式，线程启动调用start方法，运行完销毁，任务少没问题，任务多了就会耗资源

```
for (int i = 0; i < 10000; i++) { 
    Thread thread = new Thread(new Task());
    thread.start();
}
```

问题总结：

每一次创建线程和销毁线程都会带来一定的开销，如果任务比较简单，那么就有可能导致创建和销毁线程消耗的资源比线程执行任务本身消耗的资源还要大。
每一个线程都需要占用一定的内存空间，不仅如此，线程切换的时候还有上下文切换的开销。





**46、创建一个线程池有哪些核心参数？**

一、corePoolSize 线程池核心线程大小

线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。

二、maximumPoolSize 线程池最大线程数量

当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。

三、keepAliveTime 空闲线程存活时间

一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定

四、unit 空闲线程存活时间单位

keepAliveTime的计量单位

五、workQueue 工作队列
①ArrayBlockingQueue

基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。

②LinkedBlockingQuene

基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。

③SynchronousQuene

一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。

④PriorityBlockingQueue

具有优先级的无界阻塞队列，优先级通过参数Comparator实现。

六、threadFactory 线程工厂

创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等

七、handler 拒绝策略

当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的
https://blog.csdn.net/ye17186/article/details/89467919



**47、线程池的工作流程是怎样的？**

1. 在创建了线程池后，等待提交过来的任务请求

2. 当调用execute()方法添加一个请求任务时，线程池会做出如下判断

3. 1. 如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务
   2. 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列
   3. 如果这时候队列满了，并且正在运行的线程数量还小于maximumPoolSize，那么还是创建非核心线程like运行这个任务；
   4. 如果队列满了并且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行

4. 当一个线程完成任务时，它会从队列中取下一个任务来执行

5. 当一个线程无事可做操作一定的时间(keepAliveTime)时，线程池会判断：

6. 1. 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉
   2. 所以线程池的所有任务完成后，它会最终收缩到corePoolSize的大小
   3. 

**48、Java 里面有哪些内置的线程池？**



**49、为什么阿里不让用 Executors 创建线程池？**

- `workQueue`：LinkedBlockingQueue，一个由链表结构组成的有界阻塞队列，并且使用了最大长度的队列。

```go
public LinkedBlockingQueue() {
    this(Integer.MAX_VALUE);
}
```

这种方式创建的线程池由于核心线程数和最大线程数相同，所以线程池中线程的数量是固定的，并且没有限制队列大小，所以多余的任务均会被放到队列中排队，在资源有限时容易出现内存溢出。



阿里巴巴开发手册为什么禁止使用 `Executors` 去创建线程池，原因就是 `newFixedThreadPool()` 和 `newSingleThreadExecutor()`两个方法允许请求的最大队列长度是 `Integer.MAX_VALUE` ，可能会出现任务堆积，出现OOM。`newCachedThreadPool()`允许创建的线程数量为 `Integer.MAX_VALUE`，可能会创建大量的线程，导致发生OOM。它建议使用`ThreadPoolExecutor`方式去创建线程池，通过上面的分析我们也知道了其实`Executors` 三种创建线程池的方式最终就是通过`ThreadPoolExecutor`来创建的，只不过有些参数我们无法控制，如果通过`ThreadPoolExecutor`的构造器去创建，我们就可以根据实际需求控制线程池需要的任何参数，避免发生OOM异常。





**50、线程池的拒绝策略有哪几种？**

- AbortPolicy：中止策略，线程池会抛出异常并中止执行此任务;

- CallerRunsPolicy：把任务交给添加此任务的(main)线程来执行;

- DiscardPolicy：忽略此任务，忽略最新的一个任务;

- DiscardOldestPolicy：忽略最早的任务，最先加入队列的任务。

  

**51、如何提交一个线程到线程池？**

**52、线程池 submit 和 execute 有什么区别？**

**53、如何查看线程池的运行状态？**

**54、如何设置线程池的大小？**

**55、如何关闭线程池？**

线程池提供了两个关闭方法，`shutdownNow` 和 `shutdown` 方法。

`shutdownNow`方法的解释是：线程池拒接收新提交的任务，同时立马关闭线程池，线程池里的任务不再执行。

`shutdown`方法的解释是：线程池拒接收新提交的任务，同时等待线程池里的任务执行完毕后关闭线程池。

**56、AQS 是什么？**

**57、AQS 的底层原理是什么？**

AQS（AbstractQueuedSynchronizer）原理分析

字面意思是**抽象的队列同步器**，AQS 是一个同步器框架，它制定了一套多线程场景下访问共享资源的方案，Java 中很多同步类底层都是使用 AQS 实现，比如：ReentrantLock、CountDownLatch、ReentrantReadWriteLock，这些 java 同步类的内部会使用一个 Sync 内部类，而这个 Sync 继承了 AbstractQueuedSynchronizer 类，这是一种模板方法模式，所以说这些同步类的底层是使用 AQS 实现。

![image-20230630200708582](http://8.130.25.175:8080/img/image-20230630200708582.png)

AQS 内部维护了一个 volatile 修饰的 int state 属性（共享资源）和一个先进先出的线程等待队列（即多线程竞争共享资源时被阻塞的线程会进入这个队列）。因为 state 是使用 volatile 修饰，所以在多线程之前可见，访问 state 的方式有 3 种，getState()、setState()和 compareAndSetState()。

AQS 定义了 3 种资源共享方式：

- 独占锁（exclusive），保证只有一条线程执行，比如 ReentrantLock、AtomicInteger。
- 共享锁（shared），允许多个线程同时执行，比如 CountDownLatch、Semaphore。
- 同时实现独占和共享，比如 ReentrantReadWriteLock，允许多个线程同时执行读操作，只允许一条线程执行写操作。





**58、Java 中的 Fork Join 框架有什么用？**

fork join框架是java 7中引入框架，这个框架的引入主要是为了提升并行计算的能力。

fork join主要有两个步骤，第一就是fork，将一个大任务分成很多个小任务，第二就是join，将第一个任务的结果join起来，生成最后的结果。如果第一步中并没有任何返回值，join将会等到所有的小任务都结束。



**59、ThreadLocal 有什么用？**

ThreadLocal的作用就是：线程安全。

ThreadLocal的本质就是一个内部的静态的map，key是当前线程的句柄，value是需要保持的值。

由于是内部静态map，不提供遍历和查询的接口，每个线程只能获取自己线程的value。



**60、ThreadLocal 有什么副作用？**

**61、volatile 关键字有什么用？**

　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

　　2）禁止进行指令重排序。

实验表明没有volatile，多线程对共享值的修改可能不会及时别所有线程发现，volatile保证多个线程能及时看到共享变量的修改。

**62、volatile 有哪些应用场景？**

https://www.cnblogs.com/54chensongxia/p/11806836.html线程为什么有时候`check-Thread`线程能感知到状态的变化，有时候又感知不到变化呢？这个要从Java的内存模型说起。

这也我上述做的实验有相同的情况



**63、CyclicBarrier 有什么用？**

`java.util.concurrent`工具类里的另一个工具`CyclicBarrier`正如其名，“循环栅栏”，是Java提供的一种特定场景下的多线程之间进行交互的使用方法；

CyclicBarrier可以使一定数量的线程反复地在栅栏位置处汇集。当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达栅栏位置，那么栅栏将打开，此时所有的线程都将被释放，而栅栏将被重置以便下次使用。

```java
/**
 * TODO
 *
 * @author taoze
 * @version 1.0
 * @date 6/24/21 3:16 PM
 */
public class CyclicBarrierTest {

    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        CyclicBarrier barrier = new CyclicBarrier(5, new Runnable() {
            @Override
            public void run() {
                System.out.println("全部到达"+Thread.currentThread().getName()+"呼叫服务员开始点餐！");
                service.shutdown();

            }
        });
        for (int j = 0; j < 5; j++) {
            service.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(1000);
                        System.out.println(Thread.currentThread().getName() + "同学到达");
                        barrier.await();
                        System.out.println(Thread.currentThread().getName()+"同学点餐");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                }

            });
        }
        service.shutdown();
    }
}
```

执行结果：

![image-20230630211838091](http://8.130.25.175:8080/img/image-20230630211838091.png)

CyclicBarrier和CountDownLatch的区别

- CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景；
- CyclicBarrier还提供了一些其他有用的方法，比如getNumberWaiting()方法可以获得CyclicBarrier阻塞的线程数量，isBroken()方法用来了解阻塞的线程是否被中断；
- CountDownLatch允许一个或多个线程等待一组事件的产生，而CyclicBarrier用于等待其他线程运行到栅栏位置。





**64、CountDownLatch 有什么用？**

CountDownLatch是具有synchronized机制的一个工具，**目的是让一个或者多个线程等待，直到其他线程的一系列操作完成**。 CountDownLatch初始化的时候，需要提供一个整形数字，数字代表着线程需要调用countDown()方法的次数，当计数为0时，线程才会继续执行await()方法后的其他内容。



**65、CountDownLatch 与 CyclicBarrier 的区别？**

**CountDownLatch** 一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行； **CyclicBarrier** 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行； **CountDownLatch** 是不能够重用的，而**CyclicBarrier** 是可以重用的。



**66、Semaphore 有什么用？**

信号量（n个资源，使用时-1，用完+1，Semaphore==0时，任务在等待队列等待）

**67、Exchanger 有什么用？**

**68、LockSupport 有什么用？**

**69、Java 中原子操作的类有哪些？**

**70、什么是 ABA 问题？怎么解决？**

**71、Java 并发容器，你知道几个？**

https://juejin.cn/post/6844903924911046663

ConcurrentHashMap：并发版HashMap

CopyOnWriteArrayList：并发版ArrayList

CopyOnWriteArraySet：并发Set

ConcurrentLinkedQueue：并发队列(基于链表)

ConcurrentLinkedDeque：并发队列(基于双向链表)

ConcurrentSkipListMap：基于跳表的并发Map

ConcurrentSkipListSet：基于跳表的并发Set

ArrayBlockingQueue：阻塞队列(基于数组)

LinkedBlockingQueue：阻塞队列(基于链表)

LinkedBlockingDeque：阻塞队列(基于双向链表)

PriorityBlockingQueue：线程安全的优先队列

SynchronousQueue：读写成对的队列

LinkedTransferQueue：基于链表的数据交换队列

DelayQueue：延时队列



java对象序列化：

https://bbs.huaweicloud.com/blogs/254865

**1、序列化是干啥用的？**

序列化的原本意图是希望对一个Java对象作一下“变换”，变成字节序列，这样一来方便持久化存储到磁盘，避免程序运行结束后对象就从内存里消失，另外变换成字节序列也更便于网络运输和传播，所以概念上很好理解：

- **序列化**：把Java对象转换为字节序列。
- **反序列化**：把字节序列恢复为原先的Java对象。

而且序列化机制从某种意义上来说也弥补了平台化的一些差异，毕竟转换后的字节流可以在其他平台上进行反序列化来恢复对象。

2、对象序列化的方式？

在Java中，如果一个对象要想实现序列化，必须要实现下面两个接口之一：

- Serializable 接口
- Externalizable 接口

那这两个接口是如何工作的呢？两者又有什么关系呢？我们分别进行介绍。

**Serializable 如何序列化对象？**

**Serializable演示**

然而Java目前并没有一个关键字可以直接去定义一个所谓的“可持久化”对象。

对象的持久化和反持久化需要靠程序员在代码里手动**显式地**进行序列化和反序列化还原的动作。

举个例子，假如我们要对Student类对象序列化到一个名为student.txt的文本文件中，然后再通过文本文件反序列化成Student类对象：

1、Student类定义

```text
public class Student implements Serializable {

    private String name;
    private Integer age;
    private Integer score;
    
    @Override
    public String toString() {
        return "Student:" + '\n' +
        "name = " + this.name + '\n' +
        "age = " + this.age + '\n' +
        "score = " + this.score + '\n'
        ;
    }
    
    // ... 其他省略 ...
}
```

2、序列化

```text
public static void serialize(  ) throws IOException {

    Student student = new Student();
    student.setName("CodeSheep");
    student.setAge( 18 );
    student.setScore( 1000 );

    ObjectOutputStream objectOutputStream = 
        new ObjectOutputStream( new FileOutputStream( new File("student.txt") ) );
    objectOutputStream.writeObject( student );
    objectOutputStream.close();
    
    System.out.println("序列化成功！已经生成student.txt文件");
    System.out.println("==============================================");
}
```

3、反序列化

```text
public static void deserialize(  ) throws IOException, ClassNotFoundException {
    ObjectInputStream objectInputStream = 
        new ObjectInputStream( new FileInputStream( new File("student.txt") ) );
    Student student = (Student) objectInputStream.readObject();
    objectInputStream.close();
    
    System.out.println("反序列化结果为：");
    System.out.println( student );
}
```

4、运行结果

控制台打印：

```text
序列化成功！已经生成student.txt文件
==============================================
反序列化结果为：
Student:
name = CodeSheep
age = 18
score = 1000
```

## **serialVersionUID号有何用？**

相信你一定经常看到有些类中定义了如下代码行，即定义了一个名为serialVersionUID的字段：

```actionscript
private static final long serialVersionUID = -4392658638228508589L;
```

你知道这句声明的含义吗？为什么要搞一个名为serialVersionUID的序列号？

继续来做一个简单实验，还拿上面的Student类为例，我们并没有人为在里面显式地声明一个serialVersionUID字段。

我们首先还是调用上面的serialize()方法，将一个Student对象序列化到本地磁盘上的student.txt文件：

接下来我们在Student类里面动点手脚，比如在里面再增加一个名为id的字段，表示学生学号：

```javascript
public class Student implements Serializable {
    private String name;
    private Integer age;
    private Integer score;
    private Integer id;
```



这时候，我们拿刚才已经序列化到本地的student.txt文件，还用如下代码进行反序列化，试图还原出刚才那个Student对象：

运行发现报错了，并且抛出了InvalidClassException异常![img](https://bbs-img.huaweicloud.com/blogs/img/1617263554713007851.png)这地方提示的信息非常明确了：序列化前后的serialVersionUID号码不兼容！

从这地方最起码可以得出两个重要信息：

1、serialVersionUID是序列化前后的唯一标识符

2、默认如果没有人为显式定义过serialVersionUID，那编译器会为它自动声明一个！

第1个问题： serialVersionUID序列化ID，可以看成是序列化和反序列化过程中的“暗号”，在反序列化时，JVM会把字节流中的序列号ID和被序列化类中的序列号ID做比对，只有两者一致，才能重新反序列化，否则就会报异常来终止反序列化的过程。

第2个问题： 如果在定义一个可序列化的类时，没有人为显式地给它定义一个serialVersionUID的话，则Java运行时环境会根据该类的各方面信息自动地为它生成一个默认的serialVersionUID，一旦像上面一样更改了类的结构或者信息，则类的serialVersionUID也会跟着变化！

所以，为了serialVersionUID的确定性，写代码时还是建议，凡是implements Serializable的类，都最好人为显式地为它声明一个serialVersionUID明确值！

1、凡是被static修饰的字段是不会被序列化的

2、凡是被transient修饰符修饰的字段也是不会被序列化的

对于第一点，因为序列化保存的是对象的状态而非类的状态，所以会忽略static静态域也是理所应当的。

对于第二点，就需要了解一下transient修饰符的作用了。

如果在序列化某个类的对象时，就是不希望某个字段被序列化（比如这个字段存放的是隐私值，如：密码等），那这时就可以用transient修饰符来修饰该字段。



**72、什么是阻塞队列？**

**73、阻塞队列有哪些常用的应用场景？**

**74、Java 中的阻塞的队列有哪些？**

**75、什么是幂等性？**