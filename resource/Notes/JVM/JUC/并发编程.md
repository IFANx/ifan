# 并发编程

**1、进程和线程的区别？**

进程是对运行时程序的封装，是**系统进行资源调度和分配的的基本单位，实现了操作系统的并发**；

线程是进程的子任务，**是CPU调度和分派的基本单位**，**用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位**。每个线程都独自占用一个**虚拟处理器**：独自的**寄存器组**，**指令计数器和处理器状态**。每个线程完成不同的任务，但是**共享同一地址空间**（也就是同样的**动态内存，映射文件，目标代码等等**），**打开的文件队列和其他内核资源**。



**2、什么是原子性、可见性、有序性？**

**原子性**：一个操作或多个操作要么全部执行完成且执行过程不被中断，要么就不执行。

**可见性**：当多个线程同时访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 violate

**有序性**：程序执行的顺序按照代码的先后顺序执行。重排序问题



**3、为什么要使用多线程？**

简单来说就是为了提高效率

在单核CPU中，多线程主要是为了降低阻塞。 多线程的并发，其实是一种“伪并行”。 在每个时刻，真正执行的只有一个线程。 但是，由于多线程减少了等待IO操作（比如：磁盘、网络、[数据库](https://cloud.tencent.com/solution/database?from=20065&from_column=20065)等）时间， 所以，多线程大大提高了程序的效率。

正因为追求效率，后面我们会看到线程池的应用， 线程池的产生就是因为线程之间的创建、撤销、切换具有较大的时空开销， 尽管它的开销比较进程要小得多。



**4、创建线程有哪几种方式？**

**1、继承 Thread 类**

通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。

- 首先定义一个类来继承 Thread 类，重写 run 方法。
- 然后创建这个子类对象，并调用 start 方法启动线程。

![img](https://ask.qcloudimg.com/http-save/yehe-2219188/uaa1zy9cb5.png?imageView2/2/w/1200)

**2、实现 Runnable 接口**

通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。

- 首先定义一个类实现 Runnable 接口，并实现 run 方法。
- 然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中
- 最后调用 start 方法启动线程。

![img](https://ask.qcloudimg.com/http-save/yehe-2219188/qucp8pstk7.png?imageView2/2/w/1200)

**3、实现 Callable 接口，并结合 Future 实现**

- 首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。
- 然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。
- 把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。
- 通过 FutureTask 的 get 方法获取线程的执行结果。

![img](https://ask.qcloudimg.com/http-save/yehe-2219188/zglut4qdvh.png?imageView2/2/w/1200)

**4、通过线程池创建线程**

此处用 JDK 自带的 Executors 来创建线程池对象。

- 首先，定一个 Runnable 的实现类，重写 run 方法。
- 然后创建一个拥有固定线程数的线程池。
- 最后通过 ExecutorService 对象的 execute 方法传入线程对象。

![img](https://ask.qcloudimg.com/http-save/yehe-2219188/grx8pgz81h.png?imageView2/2/w/1200)



**5、什么是守护线程？**

Java 中的线程分为两类，分别为 daemon 线程（守护线程〉和 user 线程（用户线程）。

在 JVM 启动时会调用 main 函数， main 函数所在的线程就是一个用户线程，其实在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。

**守护线程定义**：所谓守护线程，是指在程序运行的时候在后台提供一种通用服务的线程。比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。

因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。

**用户线程定义**：某种意义上的主要用户线程，只要有用户线程未执行完毕，JVM 虚拟机不会退出。

**区别**：在本质上，用户线程和守护线程并没有太大区别，唯一的区别就是当最后一个非守护线程结束时，JVM 会正常退出，而不管当前是否有守护线程，也就是说守护线程是否结束并不影响 JVM 的退出。

言外之意，只要有一个用户线程还没结束， 正常情况下 JVM 就不会退出。

3. 守护线程的特点

Java 中的守护线程和 Linux 中的守护进程是有些区别的，Linux 守护进程是系统级别的，当系统退出时，才会终止。

而 Java 中的守护线程是 JVM 级别的，当 JVM 中无任何用户进程时，守护进程销毁，JVM 退出，程序终止。总结来说，Java 守护进程的最主要的特点有:

- 守护线程是运行在程序后台的线程；
- 守护线程创建的线程，依然是守护线程；
- 守护线程不会影响 JVM 的退出，当 JVM 只剩余守护线程时，JVM 进行退出；
- 守护线程在 JVM 退出时，自动销毁。

**创建方式**：将线程转换为守护线程可以通过调用 Thread 对象的 setDaemon (true) 方法来实现。

**创建细节**：

- thread.setDaemon (true) 必须在 thread.start () 之前设置，否则会跑出一个 llegalThreadStateException 异常。你不能把正在运行的常规线程设置为守护线程；
- 在 Daemon 线程中产生的新线程也是 Daemon 的；
- 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

6. 守护线程的作用及使用场景

**作用**：我们以 GC 垃圾回收线程举例，它就是一个经典的守护线程，当我们的程序中不再有任何运行的 Thread, 程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。

它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。

**应用场景**：

- 为其它线程提供服务支持的情况，可选用守护线程；

- 根据开发需求，程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用；

- 如果一个正在执行某个操作的线程必须要执行完毕后再释放，否则就会出现不良的后果的话，那么这个线程就不能是守护线程，而是用户线程；

- 正常开发过程中，一般心跳监听，垃圾回收，临时数据清理等通用服务会选择守护线程。

  

**6、线程的状态有哪几种？怎么流转的？**

![image-20230603142022520](http://8.130.25.175:8080/img/image-20230603142022520.png)

**7、线程的优先级有什么用？**

\* Thread.setPriority()可能根本不做任何事情，这跟你的操作系统和虚拟机版本有关
\* 线程优先级对于不同的线程调度器可能有不同的含义，可能并不是你直观的推测。特别地，优先级并不一定是指CPU的分享。在UNIX系统，优先级或多或少可以认为是CPU的分配，但Windows不是这样
\* 线程的优先级通常是全局的和局部的优先级设定的组合。Java的setPriority()方法只应用于局部的优先级。换句话说，你不能在整个可能的范围 内设定优先级。（这通常是一种保护的方式，你大概不希望鼠标指针的线程或者处理音频数据的线程被其它随机的用户线程所抢占）
\* 不同的系统有不同的线程优先级的取值范围，但是Java定义了10个级别（1-10）。这样就有可能出现几个线程在一个操作系统里有不同的优先级，在另外一个操作系统里却有相同的优先级（并因此可能有意想不到的行为）
\* 操作系统可能（并通常这么做）根据线程的优先级给线程添加一些专有的行为（例如”only give a quantum boost if the priority is below X“）。这里再重复一次，优先级的定义有部分在不同系统间有差别。
\* 大多数操作系统的线程调度器实际上执行的是在战略的角度上对线程的优先级做临时操作（例如当一个线程接收到它所等待的一个事件或者I/O），通常操作系统知道最多，试图手工控制优先级可能只会干扰这个系统。
\* 你的应用程序通常不知道有哪些其它进程运行的线程，所以对于整个系统来说，变更一个线程的优先级所带来的影响是难于预测的。例如你可能发现，你有一个预期 为偶尔在后台运行的低优先级的线程几乎没有运行，原因是一个病毒监控程序在一个稍微高一点的优先级（但仍然低于普通的优先级）上运行，并且无法预计你程序 的性能，它会根据你的客户使用的防病毒程序不同而不同。



**8、我们常说的 JUC 是指什么？**

https://blog.51cto.com/u_9177933/3002229



**9、i++ 是线程安全的吗？**

不是，i++三步操作，并非原子指令。



**10、join 方法有什么用？什么原理？**

Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。

```java
public class JoinTest {
 public static void main(String [] args) throws InterruptedException {
  ThreadJoinTest t1 = new ThreadJoinTest("小明");
  ThreadJoinTest t2 = new ThreadJoinTest("小东");
  t1.start();
  /**join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是：
程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕
所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会
*/
  t1.join();
  t2.start();
 }
 
}
class ThreadJoinTest extends Thread{
 public ThreadJoinTest(String name){
  super(name);
 }
 @Override
 public void run(){
  for(int i=0;i<1000;i++){
System.out.println(this.getName() + ":" + i);
  }
 }
}
```

面程序结果是先打印完小明线程，在打印小东线程；　

　

上面注释也大概说明了join方法的作用：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。注意，这里调用的join方法是没有传参的，join方法其实也可以传递一个参数给它的，具体看下面的简单例子：

 

```java
public class JoinTest {
 public static void main(String [] args) throws InterruptedException {
  ThreadJoinTest t1 = new ThreadJoinTest("小明");
  ThreadJoinTest t2 = new ThreadJoinTest("小东");
  t1.start();
  /**join方法可以传递参数，join(10)表示main线程会等待t1线程10毫秒，10毫秒过去后，
* main线程和t1线程之间执行顺序由串行执行变为普通的并行执行
*/
  t1.join(10);
  t2.start();
 }
 
}
class ThreadJoinTest extends Thread{
 public ThreadJoinTest(String name){
  super(name);
 }
 @Override
 public void run(){
  for(int i=0;i<1000;i++){
System.out.println(this.getName() + ":" + i);
  }
 }
}
1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23.24.
```

上面代码结果是：程序执行前面10毫秒内打印的都是小明线程，10毫秒后，小明和小东程序交替打印。

 

所以，join方法中如果传入参数，则表示这样的意思：如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。需要注意的是，jdk规定，join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join()。



**11、如何让一个线程休眠？**

方法1：Thread.sleep方法2：TimeUnit方法3：wait方法4：Condition方法5：LockSupport总结

在 java 中，让线程休眠的方法有很多，这些方法大致可以分为两类，一类是设置时间，在一段时间后自动唤醒，而另一个类是提供了一对休眠和唤醒的方法，在线程休眠之后，可以在任意时间对线程进行唤醒。



方法2：TimeUnit

sleep 方法因为要传递一个毫秒类型的参数，因此在设置大一点的时间时比较麻烦，比如设置 1 小时或 1 天时，此时我们就可以使用 TimeUnit 来替代 sleep 方法实现休眠。 TimeUnit 的功能和 sleep 一样，让线程休眠 N 个单位时间之后自动唤醒，它的基础用法如下：

```java
Thread t1 = new Thread() {

@Override

public void run() {

System.out.println("线程执行：" + LocalDateTime.now());

try {

TimeUnit.SECONDS.sleep(1); // 休眠 1s

//TimeUnit.DAYS.sleep(1); // 休眠 1 天

} catch (InterruptedException e) {

e.printStackTrace();

}

System.out.println("线程结束：" + LocalDateTime.now());

}

};

t1.start();
```

方法3：wait

wait/notify/notifyAll 都来自于 Object 类，其中：

wait() / wait(long timeout)：表示让当前线程进入休眠状态。notify()：唤醒当前对象上的一个休眠线程。notifyAll()：唤醒当前对象上的所有休眠线程。

其中 wait() 方法表示让当前线程无限期等待下去，直到遇到 notify/notifyAll 方法时才会被唤醒，而 wait(long timeout) 表示接收一个 long 类型的超时时间，如果没有遇到 notify/notifyAll 会在 long 毫秒之后自动唤醒，如果遇到了 notify/notifyAll 方法会立即被唤醒。 它的基础用法如下：

```java
Object lock = new Object();

new Thread(() -> {

synchronized (lock) {

try {

// 让当前线程休眠

lock.wait();

} catch (InterruptedException e) {

e.printStackTrace();

}

}

}).start();

synchronized (lock) {

lock.notify(); // 唤醒当前对象上一个休眠线程

// lock.notifyAll(); // 唤醒当前对象上所有休眠的线程

}
```

需要注意的是 wait/notify/notifyAll 在使用时必须要配合 synchronized 一起使用，否则程序执行会报错。



方法4：Condition

Condition 作为 wait 的升级版，它提供的常用方法有以下几个：

await()：让当前线程进入等待状态，直到被通知（signal）或者被中断时才会继续执行。awaitUninterruptibly()：让当前线程进入等待状态，直到被通知才会被唤醒，它对线程的中断通知不做响应。await(long time, TimeUnit unit)：在 alLFAFMdwait() 方法的基础上添加了超时时间，如果过了超时时间还没有遇到唤醒方法则会自动唤醒并恢复执行。awaitUntil(Date deadline)：让当前线程进入等待状态，如果没有遇到唤醒方法也会在设置的时间之后自动唤醒。signal()：唤醒一个等待在 Condition 上的线程。signalAll()：唤醒等待在 Condition 上所有的线程。

它的基本用法如下：

```java
import java.time.LocalDateTime;

import java.util.concurrent.locks.Condition;

import java.util.concurrent.locks.Lock;

import java.util.concurrent.locks.ReentrantLock;

public class ConditionExample {

public static void main(String[] args) throws InterruptedException {

// 创建锁

final Lock lock = new ReentrantLock();

// 创建 Condition

final Condition condition = lock.newCondition();

new Thread(() -> {

System.out.println("线程执行：" + LocalDateTime.now());

lock.lock(); // 得到锁

try {

// 休眠线程

condition.await();

} catch (InterruptedException e) {

e.printStackTrace();

} finally {

lock.unlock(); // 释放锁

}

System.out.println("线程结束：" + LocalDateTime.now());

}).start();

Thread.sleep(1000);

lock.lock(); // 得到锁

try {

// 唤醒线程

condition.signal();

} finally {

lock.unlock(); // 释放锁

}

}

}
```

相比于 wait 方法，Condition 对象更加灵活，因为它可以在一把锁上定义多个 Condition 对象进行使用，



**12、启动一个线程是用 start 还是 run 方法？**

启动线程肯定要用start()方法。当用start()开始一个线程后，线程就进入**就绪状态**，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这**并不意味着线程就会立即运行**。当cpu分配给它时间时，才开始执行run()方法(如果有的话)。start()是方法,它调用run()方法。而run()方法是你必须重写的. run()方法中包含的是线程的主体。



**13、start 和 run 方法有什么区别？**

```java
public class Test1 extends Thread {

@Override

public void run() {

while (true)

{

System.out.println(Thread.currentThread().getName());

}

}

public static void main(String[] args) {

Test1 test1=new Test1();

test1.run(); //输出结果:main(当前线程名)

test1.start(); //输出结果 Thread-0（新启动的线程名）

}

}
```

1.start

start作用是启动一个新线程。

当用start()开始一个线程后，线程就进入就绪状态，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。但是这并不意味着线程就会立即运行。只有当cpu分配时间片时，这个线程获得时间片时，才开始执行run()方[http](https://www.eolink.com/news/tags-1144.html)://法。start()不能被重复调用，它调用run()[方法](https://www.eolink.com/news/tags-1160.html).run()方法是你必须重写的

2.run

run()就和普通的成员方法一样，可以被重复调用。

如果直接调用run方法，并不会启动新线程！程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。

调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。





**14、sleep 和 wait 方法有什么区别？**

Java 中 `wait` 和 `sleep` 之间的区别或者 `sleep` 和 `yield` 之间的区别是流行的核心 Java 面试问题之一，并且在多线程面试中被问到。 在 Java 中可用于暂停线程的三种方法中，`sleep()` 和 `yield()` 方法定义在线程类中，而 `wait()` 方法定义在 Object 类中，这是另一个面试问题。 `wait()` 和 `sleep()` 之间的主要区别在于前者用于线程间通信，而后者用于引入以暂停当前线程一小段时间。

这种区别在以下事实中更加明显：当一个线程调用 `wait()` 方法时，它会释放它持有的监视器或锁定该对象，但是当一个线程调用 `sleep()` 方法时，它甚至不会释放监视器 如果它持有。

回到 `yield()`，它与 `wait()` 和 `sleep()` 没什么不同，它只是释放线程占用的 CPU，让另一个线程有机会运行，但不能保证谁会获得 CPU。

这完全取决于线程调度程序，调用 `yield()` 方法的线程甚至有可能再次获得 CPU。 因此，依赖 `yield()` 方法是不可靠的，它只是在尽力而为的基础上。



**15、Thread.yield 方法有什么用？**

Thread yield()方法的作用是暂停当前线程，以便其他线程有机会执行，不过不能指定暂停的时间，并且也不能保证当前线程马上停止。yield方法只是将Running状态转变为Runnable状态。



**16、yield 和 sleep 有什么区别？**

sleep()方法：可以让正在运行的线程进入阻塞状态，直到休眠时间满了，进入就绪状 态yield()方法：可以让正在运行的线程直接进入就绪状态，让出 CPU 的使用权。

yield 方法的使用 yield()方法的作用：暂停当前正在执行的线程，并执行其他线程。 yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得 运行的机会。因此，使用 yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。 但是，实际中无法保证 yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次 选中。



**17、怎么理解 Java 中的线程中断？**

线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。

```java
try {
				Thread.sleep(3000);
			} catch (InterruptedException e) {
				System.out.println("Java技术栈线程休眠被中断，程序退出。");
				Thread.currentThread().interrupt();
			}

```

**18、你怎么理解多线程分组？**

```java
/**

 * 微信公众号：Java技术栈
   */
   public static void main(String[] args) {
   Runnable runnable = () -> {
   	System.out.println("Java技术栈线程线程组名称：" + Thread.currentThread().getThreadGroup());
   	System.out.println("Java技术栈线程线程名称：" + Thread.currentThread().getName());
   	try {
   		Thread.sleep(3000);
   	} catch (InterruptedException e) {
   		e.printStackTrace();
   	}
   };

   ThreadGroup userGroup = new ThreadGroup("user");
   userGroup.setMaxPriority(Thread.MIN_PRIORITY);

   Thread userTask1 = new Thread(userGroup, runnable, "user-task1");
   Thread userTask2 = new Thread(userGroup, runnable, "user-task2");

   userTask1.start();
   userTask2.start();

   System.out.println("Java技术栈线程线程组活跃线程数：" + userGroup.activeCount());
   userGroup.list();

}
```


程序输出以下结果。

程序输出以下结果。

```
Java技术栈线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]
Java技术栈线程线程名称：user-task1
Java技术栈线程线程组活跃线程数：2
Java技术栈线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]
Java技术栈线程线程名称：user-task2
java.lang.ThreadGroup[name=user,maxpri=1]
    Thread[user-task1,1,user]
    Thread[user-task2,1,user]
```


根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。

线程组还能统一设置**组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级**。

另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程**中断**功能进行优雅终止线程。



**19、你怎么理解 wait、notify、notifyAll？**

在Java中，每个对象都有两个池，锁(monitor)池和等待池

## 锁池

锁池:假设线程A已经拥有了某个对象的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。

## 等待池

等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁)，同时线程A就进入到了该对象的等待池中。如果另外的一个线程调用了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池.

## notify 和 notifyAll 的区别

### wait()

public final void wait() throws InterruptedException,IllegalMonitorStateException
该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用 wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait()方法。进入 wait()方法后，当前线程释放锁。在从 wait()返回前，线程与其他线程竞争重新获得锁。如果调用 wait()时，没有持有适当的锁，则抛出 IllegalMonitorStateException，它是 RuntimeException 的一个子类，因此，不需要 try-catch 结

### notify()

public final native void notify() throws IllegalMonitorStateException
该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，的如果调用 notify()时没有持有适当的锁，也会抛出 IllegalMonitorStateException。
该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个 wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify 后，当前线程不会马上释放该对象锁，wait 所在的线程并不能马上获取该对象锁，要等到程序退出 synchronized 代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。当第一个获得了该对象锁的 wait 线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用 notify 语句，则即便该对象已经空闲，其他 wait 状态等待的线程由于没有得到该对象的通知，会继续阻塞在 wait 状态，直到这个对象发出一个 notify 或 notifyAll。这里需要注意：它们等待的是被 notify 或 notifyAll，而不是锁。这与下面的 notifyAll()方法执行后的情况不同。

### notifyAll()

public final native void notifyAll() throws IllegalMonitorStateException
该方法与 notify ()方法的工作方式相同，重要的一点差异是：
notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待 notify 或 notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll 线程退出调用了 notifyAll 的 synchronized 代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。





**20、同步和异步的区别？**

同步与异步是指访问数据的机制，同步一般指主动请求并等待IO操作完成的方式。
异步则指主动请求数据后便可以继续处理其它任务，随后等待IO操作完毕的通知。
同步和异步最大的区别就在于：同步需要等待，异步不需要等待。

阻塞与非阻塞是描述线程在访问某个资源时，数据是否准备就绪的一种处理方式。当数据没有准备就绪时：
阻塞：线程持续等待资源中数据准备完成，直到返回响应结果。
非阻塞：线程直接返回结果，不会持续等待资源准备数据结束后才响应结果。

① 阻塞与非阻塞是针对线程来说的，阻塞可能发生在IO期间也可能发生在IO之前。
② 同步与异步是针对IO操作来说的，同步是用户线程一直盯着IO直到完成，异步是用户线程在IO完成时会收到通知。

**21、什么是死锁？**

互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。
循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。



**22、怎么避免死锁？**

1.破坏“占有且等待”条件:所有的进程在开始运行之前，必须**一次性地申请其在整个运行过程中所需要的全部资源**。

2.破坏“不可抢占”条件:当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。

3.破坏“循环等待”条件;采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将**紧缺的，稀少的采用较大的编号**，在申请资源时必须按照编号的顺序进行（**从小往大申请**），一个进程只有获得较小编号的进程才能申请较大编号的进程。

**死锁避免算法**：银行家算法

安全序列：

![1358881-20191125164249992-1856910147](http://8.130.25.175:8080/img/1358881-20191125164249992-1856910147.png)

1）系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。
2）安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态。

银行家算法的实质就是**要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。**即没当进程提出资源请求且系统的资源能够满足该请求时，系统将判断满足此次资源请求后系统状态是否安全，如果判断结果为安全，则给该进程分配资源，否则不分配资源，申请资源的进程将阻塞。

银行家算法的执行有个前提条件，即要求进程预先提出自己的最大资源请求，并假设系统拥有固定的资源总量。下面介绍银行家算法所用的主要的数据结构。

多个线程均分得一部分资源，但没完全满足，可能出现没资源可分的情况，这样的情况会出现死锁。

![1358881-20191125171934215-167814328](http://8.130.25.175:8080/img/1358881-20191125171934215-167814328.png)

![1358881-20191125172027066-647382599](http://8.130.25.175:8080/img/1358881-20191125172027066-647382599.png)

**23、什么是活锁？**

活锁指的是**任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败**。 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。 活锁可以认为是一种特殊的饥饿。

活锁指的是线程不断重复执行相同的操作，但每次操作的结果都是失败的。尽管这个问题不会阻塞线程，但是程序也无法继续执行。活锁通常发生在处理事务消息的应用程序中，如果不能成功处理这个事务那么事务将回滚整个操作。解决活锁的办法是在每次重复执行的时候引入随机机制，这样由于出现的可能性不同使得程序可以继续执行其他的任务。



**24、什么是无锁？**





**25、什么是线程饥饿？**

**26、什么是 CAS？**

**27、阻塞和非阻塞的区别？**

**28、并发和并行的区别？**

**29、为什么不推荐使用 stop 停止线程？**

**30、如何优雅地终止一个线程？**

Thread.interrupt()

`Thread`提供了`interrupt()`方法，它没有像`stop()`方法那样，直接中断一个线程的执行，而是通过信号量来通知线程可以停止执行了，当线程收到该信号量时，可以通过`isInterrupted()`方法判断当前是否需要中断。这样的停止方式，相比`stop()`是不是更加友好，让线程自己判断能否中断，从而保证业务处理的完整性。

**31、Synchronized 同步锁有哪几种用法？**

**32、什么是重入锁（ReentrantLock）？**

**33、Synchronized 与 ReentrantLock 的区别？**

**34、synchronized 锁的是什么?**

**35、什么是读写锁？**

**36、公平锁和非公平锁的区别？**

**37、有哪些锁优化的方式？**

**38、什么是偏向锁？**

**39、什么是轻量级锁？**

**40、什么是自旋锁？**

**41、什么是锁消除？**

**42、什么是锁粗化？**

**43、什么是重量级锁？**

**44、什么是线程池？**

**45、使用线程池有什么好处？**

**46、创建一个线程池有哪些核心参数？**

**47、线程池的工作流程是怎样的？**

**48、Java 里面有哪些内置的线程池？**

**49、为什么阿里不让用 Executors 创建线程池？**

**50、线程池的拒绝策略有哪几种？**

**51、如何提交一个线程到线程池？**

**52、线程池 submit 和 execute 有什么区别？**

**53、如何查看线程池的运行状态？**

**54、如何设置线程池的大小？**

**55、如何关闭线程池？**

**56、AQS 是什么？**

**57、AQS 的底层原理是什么？**

**58、Java 中的 Fork Join 框架有什么用？**

**59、ThreadLocal 有什么用？**

**60、ThreadLocal 有什么副作用？**

**61、volatile 关键字有什么用？**

**62、volatile 有哪些应用场景？**

**63、CyclicBarrier 有什么用？**

**64、CountDownLatch 有什么用？**

**65、CountDownLatch 与 CyclicBarrier 的区别？**

**66、Semaphore 有什么用？**

**67、Exchanger 有什么用？**

**68、LockSupport 有什么用？**

**69、Java 中原子操作的类有哪些？**

**70、什么是 ABA 问题？怎么解决？**

**71、Java 并发容器，你知道几个？**

**72、什么是阻塞队列？**

**73、阻塞队列有哪些常用的应用场景？**

**74、Java 中的阻塞的队列有哪些？**

**75、什么是幂等性？**