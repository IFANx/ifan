## 设计模式

[设计模式目录](https://refactoringguru.cn/design-patterns/catalog)（推荐看这个，非常详细有代码，且易懂）

my [gitee](https://gitee.com/IFANx/design-module/)

### 创建性模式

#### 1.[工厂方法模式](https://refactoringguru.cn/design-patterns/factory-method)

#### （[简单工厂，工厂方法与抽象工厂的比较](https://gitee.com/IFANx/design-module/blob/master/src/main/java/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/factory/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md)）https://refactoringguru.cn/design-patterns/factory-comparison

**亦称：** 虚拟构造函数、Virtual Constructor、Factory Method

意图

**工厂方法模式**是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。(工厂方法模式建议使用特殊的*工厂*方法代替对于对象构造函数的直接调用 （即使用 `new`运算符）。 不用担心， 对象仍将通过 `new`运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。)

#### 2.[抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)

**意图**

**抽象工厂模式**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。



**抽象工厂模式适合应用场景**

 如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。

 抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。

 如果你有一个基于一组[抽象方法](https://refactoringguru.cn/design-patterns/factory-method)的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。

 在设计良好的程序中， *每个类仅负责一件事*。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。

**识别方法：** 我们可以通过方法来识别该模式——其会返回一个工厂对象。 接下来， 工厂将被用于创建特定的子组件。



#### 3.[生成器模式](https://refactoringguru.cn/design-patterns/builder)

亦称： 建造者模式、Builder

 意图

**生成器模式**是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。



#### 4.[原型模式](https://refactoringguru.cn/design-patterns/prototype)



**亦称：** 克隆、Clone、Prototype

意图

**原型模式**是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。



#### 5.[单例模式](https://refactoringguru.cn/design-patterns/singleton)

**亦称：**单件模式、Singleton

意图

**单例模式**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。











### 结构性模式

#### 6.适配器模式

#### 7.桥接模式

#### 8.组合模式

#### 9.装饰模式

#### 10.外观模式

#### 11.亨元模式

#### 12.代理模式



### 行为模式

#### 13.观察者模式

#### 14.模版方法模式

#### 15.访问者模式

#### 16.命令模式

#### 17.责任链

#### 18.迭代器

#### 19.中介者

#### 20.备忘录

#### 21.状态

#### 22.策略







