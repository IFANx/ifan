{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{291:function(t,a,s){\"use strict\";s.r(a);var r=s(14),_=Object(r.a)({},(function(){var t=this,a=t._self._c;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"引论\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#引论\"}},[t._v(\"#\")]),t._v(\" 引论\")]),t._v(\" \"),a(\"p\",[t._v(\"用户与之交互的程序，基于文本的通常称为shell，而基于图标的则称为图形用户界面(Graphical User Interface，GUI)，它们实际上并不是操作系统的一部分，尽管这些程序使用操作系统来完成工作。\")]),t._v(\" \"),a(\"p\",[t._v(\"操作系统运行在裸机之上，为所有其他软件提供基础的运行环境。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"http://8.130.25.175:8080/img/image-20230505190232511.png\",alt:\"image-20230505190232511\"}})]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_1-1计算机硬件介绍\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-1计算机硬件介绍\"}},[t._v(\"#\")]),t._v(\" 1.1计算机硬件介绍\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_1-1-1-处理器\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-1-1-处理器\"}},[t._v(\"#\")]),t._v(\" 1.1.1 处理器\")]),t._v(\" \"),a(\"p\",[t._v(\"计算机的“大脑”是CPU，它从内存中取出指令并执行之。在每个CPU基本周期中，首先从内存中取出指 令，解码以确定其类型和操作数，接着执行之，然后取指、解码并执行下一条指令。按照这一方式，程序被执行完成。\")]),t._v(\" \"),a(\"p\",[t._v(\"为了改善性能，CPU设计师早就放弃了同时读取、解码和执行一条指令的简单模型。许多现代CPU具有 同时取出多条指令的机制。例如，一个CPU可以有分开的取指单元、解码单元和执行单元，于是当它执行指 令n时，它还可以对指令n+1解码，并且读取指令n+2。这样一种机制称为流水线(pipeline)\")]),t._v(\" \"),a(\"p\",[t._v(\"除了用在嵌入式系统中的非常简单的CPU之外，多数CPU都有两种模式，即前面已经提及的内核态和用 户态。通常，在PSW中有一个二进制位控制这两种模式。当在内核态运行时，CPU可以执行指令集中的每一 条指令，并且使用硬件的每种功能。操作系统在内核态下运行，从而可以访问整个硬件。\")]),t._v(\" \"),a(\"p\",[t._v(\"相反，用户程序在用户态下运行，仅允许执行整个指令集的一个子集和访问所有功能的一个子集。一般 而言，在用户态中有关I/O和内存保护的所有指令是禁止的。当然，将PSW中的模式位设置成内核态也是禁 止的。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_1-1-2-存储器\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-1-2-存储器\"}},[t._v(\"#\")]),t._v(\" 1.1.2 存储器\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"http://8.130.25.175:8080/img/image-20230505192738134.png\",alt:\"image-20230505192738134\"}})]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_1-1-3-i-o设备\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-1-3-i-o设备\"}},[t._v(\"#\")]),t._v(\" 1.1.3 I/O设备\")]),t._v(\" \"),a(\"p\",[t._v(\"在有些计算机中，设备寄存器被映射到操作系统的地址空间(操作系统可使用的地址)，这样，它们就 可以像普通存储字一样读出和写入。在这种计算机中，不需要专门的I/O指令，用户程序可以被硬件阻挡在 外，防止其接触这些存储器地址(例如，采用基址和界限寄存器)。在另外一些计算机中，设备寄存器被放 入一个专门的I/O端口空间中，每个寄存器都有一个端口地址。在这些机器中，提供在内核态中可使用的专 门IN和OUT指令，供设备驱动程序读写这些寄存器用。前一种方式不需要专门的I/O指令，但是占用了一些 地址空间。后者不占用地址空间，但是需要专门的指令。这两种方式的应用都很广泛。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_1-1-4-总线\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-1-4-总线\"}},[t._v(\"#\")]),t._v(\" 1.1.4 总线\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_1-2-操作系统\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-2-操作系统\"}},[t._v(\"#\")]),t._v(\" 1.2 操作系统\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_1-2-1-进程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-2-1-进程\"}},[t._v(\"#\")]),t._v(\" 1.2.1 进程\")]),t._v(\" \"),a(\"p\",[t._v(\"进程本质上是正在执行的一个程序。与每个进 程相关的是进程的地址空间(address space)，这是从某个最小值的存储位置(通常是零)到某个最大值存 储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及 程序的堆栈。与每个进程相关的还有资源集，通常包括寄存器(含有程序计数器和堆栈指针)、打开文件的 清单、突出的报警、有关进程清单，以及运行该程序所需要的所有其他信息。进程基本上是容纳运行一个程 序所需要所有信息的容器。\")]),t._v(\" \"),a(\"p\",[t._v(\"操作系统周期性地挂起一个进程然 后启动运行另一个进程。例如，在过去的一秒钟内，第一个进程已使用完分配给它的时间片。（多进程，单CPU，轮转调度，时间片，上下文保存恢复）\")])])}),[],!1,null,null,null);a.default=_.exports}}]);","extractedComments":[]}