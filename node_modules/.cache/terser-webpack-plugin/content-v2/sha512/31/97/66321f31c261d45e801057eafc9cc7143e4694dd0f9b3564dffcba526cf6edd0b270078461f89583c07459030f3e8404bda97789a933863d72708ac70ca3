{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{280:function(t,a,e){\"use strict\";e.r(a);var r=e(14),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"aqs\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aqs\"}},[t._v(\"#\")]),t._v(\" AQS\")]),t._v(\" \"),a(\"p\",[t._v(\"https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html\")]),t._v(\" \"),a(\"p\",[t._v(\"AbstractQueuedSynchronizer抽象类是核心，需要重点掌握。它提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。\")]),t._v(\" \"),a(\"p\",[t._v(\"AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"aqs-核心思想\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aqs-核心思想\"}},[t._v(\"#\")]),t._v(\" AQS 核心思想\")]),t._v(\" \"),a(\"p\",[t._v(\"AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。\")])]),t._v(\" \"),a(\"p\",[t._v(\"AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。\")]),t._v(\" \"),a(\"hr\"),t._v(\" \"),a(\"h3\",{attrs:{id:\"aqs-对资源的共享方式\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aqs-对资源的共享方式\"}},[t._v(\"#\")]),t._v(\" AQS 对资源的共享方式\")]),t._v(\" \"),a(\"p\",[t._v(\"AQS定义两种资源共享方式\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：\\n\"),a(\"ul\",[a(\"li\",[t._v(\"公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\")]),t._v(\" \"),a(\"li\",[t._v(\"非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\")])])]),t._v(\" \"),a(\"li\",[t._v(\"Share(共享)：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\")])]),t._v(\" \"),a(\"p\",[t._v(\"ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。\")]),t._v(\" \"),a(\"p\",[t._v(\"不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在上层已经帮我们实现好了。\")])])}),[],!1,null,null,null);a.default=n.exports}}]);","extractedComments":[]}