{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{352:function(v,_,t){\"use strict\";t.r(_);var s=t(14),p=Object(s.a)({},(function(){var v=this,_=v._self._c;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[_(\"h2\",{attrs:{id:\"redis与mysql双写一致性如何保证\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis与mysql双写一致性如何保证\"}},[v._v(\"#\")]),v._v(\" Redis与MySQL双写一致性如何保证？\")]),v._v(\" \"),_(\"p\",[v._v(\"https://juejin.cn/post/6964531365643550751\")]),v._v(\" \"),_(\"p\",[v._v(\"https://mp.weixin.qq.com/s/-0_ReIv2bp5snq3NUI3P7A\")]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/Users/kkxu/NodeProjects/ifan/ifan/images/image-20230627173843521.png\",alt:\"image-20230627173843521\"}})]),v._v(\" \"),_(\"p\",[v._v(\"一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"strong\",[v._v(\"强一致性\")]),v._v(\"：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"弱一致性\")]),v._v(\"：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"最终一致性\")]),v._v(\"：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型\")])]),v._v(\" \"),_(\"h3\",{attrs:{id:\"不更新缓存-而是删除缓存\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#不更新缓存-而是删除缓存\"}},[v._v(\"#\")]),v._v(\" 不更新缓存，而是删除缓存\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。\")])]),v._v(\" \"),_(\"p\",[v._v(\"观点引用：《分布式之数据库和缓存双写一致性方案解析》孤独烟\")]),v._v(\" \"),_(\"blockquote\",[_(\"p\",[_(\"strong\",[v._v(\"原因一：线程安全角度\")])]),v._v(\" \"),_(\"p\",[v._v(\"同时有请求A和请求B进行更新操作，那么会出现\")]),v._v(\" \"),_(\"p\",[v._v(\"（1）线程A更新了数据库\")]),v._v(\" \"),_(\"p\",[v._v(\"（2）线程B更新了数据库\")]),v._v(\" \"),_(\"p\",[v._v(\"（3）线程B更新了缓存\")]),v._v(\" \"),_(\"p\",[v._v(\"（4）线程A更新了缓存\")]),v._v(\" \"),_(\"p\",[v._v(\"这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"原因二：业务场景角度\")])]),v._v(\" \"),_(\"p\",[v._v(\"有如下两点：\")]),v._v(\" \"),_(\"p\",[v._v(\"（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。\")]),v._v(\" \"),_(\"p\",[v._v(\"（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"其实如果业务非常简单，只是去数据库拿一个值，写入缓存，那么更新缓存也是可以的。但是，淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss，建议作为通用的处理方式。\")])]),v._v(\" \"),_(\"h3\",{attrs:{id:\"先操作缓存-还是先操作数据库\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#先操作缓存-还是先操作数据库\"}},[v._v(\"#\")]),v._v(\" 先操作缓存，还是先操作数据库\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"那么问题就来了，我们是先删除缓存，然后再更新数据库，还是先更新数据库，再删缓存呢？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"先删缓存，再更新数据库\")])]),v._v(\" \"),_(\"p\",[v._v(\"该方案会导致请求数据不一致\")]),v._v(\" \"),_(\"p\",[v._v(\"同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:\")]),v._v(\" \"),_(\"p\",[v._v(\"（1）请求A进行写操作，删除缓存\")]),v._v(\" \"),_(\"p\",[v._v(\"（2）请求B查询发现缓存不存在\")]),v._v(\" \"),_(\"p\",[v._v(\"（3）请求B去数据库查询得到旧值\")]),v._v(\" \"),_(\"p\",[v._v(\"（4）请求B将旧值写入缓存\")]),v._v(\" \"),_(\"p\",[v._v(\"（5）请求A将新值写入数据库\")]),v._v(\" \"),_(\"p\",[v._v(\"上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"所以先删缓存，再更新数据库并不是一劳永逸的解决方案，再看看先更新数据库，再删缓存这种方案怎么样？\")])]),v._v(\" \"),_(\"blockquote\",[_(\"p\",[_(\"strong\",[v._v(\"先更新数据库，再删缓存\")]),v._v(\"这种情况不存在并发问题么？\")]),v._v(\" \"),_(\"p\",[v._v(\"不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生\")]),v._v(\" \"),_(\"p\",[v._v(\"（1）缓存刚好失效\")]),v._v(\" \"),_(\"p\",[v._v(\"（2）请求A查询数据库，得一个旧值\")]),v._v(\" \"),_(\"p\",[v._v(\"（3）请求B将新值写入数据库\")]),v._v(\" \"),_(\"p\",[v._v(\"（4）请求B删除缓存\")]),v._v(\" \"),_(\"p\",[v._v(\"（5）请求A将查到的旧值写入缓存\")]),v._v(\" \"),_(\"p\",[v._v(\"ok，如果发生上述情况，确实是会发生脏数据。\")]),v._v(\" \"),_(\"p\",[v._v(\"然而，发生这种情况的概率又有多少呢？\")]),v._v(\" \"),_(\"p\",[v._v(\"发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，\"),_(\"strong\",[v._v(\"数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。\")])])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！\")])]),v._v(\" \"),_(\"p\",[v._v(\"所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请\"),_(\"strong\",[v._v(\"先更新数据库，再删缓存!\")])]),v._v(\" \"),_(\"h3\",{attrs:{id:\"我非要数据库和缓存数据强一致怎么办\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#我非要数据库和缓存数据强一致怎么办\"}},[v._v(\"#\")]),v._v(\" 我非要数据库和缓存数据强一致怎么办\")]),v._v(\" \"),_(\"p\",[v._v(\"那么，如果我非要保证绝对一致性怎么办，先给出结论：\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP。\")])]),v._v(\" \"),_(\"p\",[v._v(\"所以，我们得委曲求全，可以去做到BASE理论中说的\"),_(\"strong\",[v._v(\"最终一致性\")]),v._v(\"。\")]),v._v(\" \"),_(\"blockquote\",[_(\"p\",[v._v(\"最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性\")])]),v._v(\" \"),_(\"p\",[v._v(\"大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库/先更新数据库，再删缓存）导致的\"),_(\"strong\",[v._v(\"脏数据问题，进行相应的处理，来保证最终一致性。\")])]),v._v(\" \"),_(\"h4\",{attrs:{id:\"缓存延时双删\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#缓存延时双删\"}},[v._v(\"#\")]),v._v(\" 缓存延时双删\")]),v._v(\" \"),_(\"p\",[v._v(\"问：先删除缓存，再更新数据库中避免脏数据？\")]),v._v(\" \"),_(\"p\",[v._v(\"答案：采用延时双删策略。\")]),v._v(\" \"),_(\"p\",[v._v(\"上文我们提到，在先删除缓存，再更新数据库的情况下，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"那么延时双删怎么解决这个问题呢？\")])]),v._v(\" \"),_(\"blockquote\",[_(\"p\",[v._v(\"（1）先淘汰缓存\")]),v._v(\" \"),_(\"p\",[v._v(\"（2）再写数据库（这两步和原来一样）\")]),v._v(\" \"),_(\"p\",[v._v(\"（3）休眠1秒，再次淘汰缓存\")]),v._v(\" \"),_(\"p\",[v._v(\"这么做，可以将1秒内所造成的缓存脏数据，再次删除。\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"那么，这个1秒怎么确定的，具体该休眠多久呢？\")])]),v._v(\" \"),_(\"blockquote\",[_(\"p\",[_(\"strong\",[v._v(\"针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\")])])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"如果你用了mysql的读写分离架构怎么办？\")])]),v._v(\" \"),_(\"blockquote\",[_(\"p\",[v._v(\"ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。\")]),v._v(\" \"),_(\"p\",[v._v(\"（1）请求A进行写操作，删除缓存\")]),v._v(\" \"),_(\"p\",[v._v(\"（2）请求A将数据写入数据库了，\")]),v._v(\" \"),_(\"p\",[v._v(\"（3）请求B查询缓存发现，缓存没有值\")]),v._v(\" \"),_(\"p\",[v._v(\"（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值\")]),v._v(\" \"),_(\"p\",[v._v(\"（5）请求B将旧值写入缓存\")]),v._v(\" \"),_(\"p\",[v._v(\"（6）数据库完成主从同步，从库变为新值\")]),v._v(\" \"),_(\"p\",[v._v(\"上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"采用这种同步淘汰策略，吞吐量降低怎么办？\")])]),v._v(\" \"),_(\"blockquote\",[_(\"p\",[v._v(\"ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"所以在先删除缓存，再更新数据库的情况下\")]),v._v(\"，可以使用延时双删的策略，来保证脏数据只会存活一段时间，就会被准确的数据覆盖。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"在先更新数据库，再删缓存的情况下\")]),v._v(\"，缓存出现脏数据的情况虽然可能性极小，但也会出现。我们依然可以用延时双删策略，在请求A对缓存写入了脏的旧值之后，再次删除缓存。来保证去掉脏缓存。\")]),v._v(\" \"),_(\"h4\",{attrs:{id:\"删缓存失败了怎么办-重试机制\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#删缓存失败了怎么办-重试机制\"}},[v._v(\"#\")]),v._v(\" 删缓存失败了怎么办：重试机制\")]),v._v(\" \"),_(\"p\",[v._v(\"看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？\")])])}),[],!1,null,null,null);_.default=p.exports}}]);","extractedComments":[]}