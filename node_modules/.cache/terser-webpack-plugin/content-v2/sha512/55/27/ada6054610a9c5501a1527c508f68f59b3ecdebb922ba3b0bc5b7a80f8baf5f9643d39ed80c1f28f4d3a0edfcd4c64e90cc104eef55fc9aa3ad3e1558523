{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{283:function(v,_,t){\"use strict\";t.r(_);var r=t(14),n=Object(r.a)({},(function(){var v=this,_=v._self._c;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[_(\"h1\",{attrs:{id:\"并发编程\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#并发编程\"}},[v._v(\"#\")]),v._v(\" 并发编程\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"1、进程和线程的区别？\")])]),v._v(\" \"),_(\"p\",[v._v(\"进程是对运行时程序的封装，是\"),_(\"strong\",[v._v(\"系统进行资源调度和分配的的基本单位，实现了操作系统的并发\")]),v._v(\"；\")]),v._v(\" \"),_(\"p\",[v._v(\"线程是进程的子任务，\"),_(\"strong\",[v._v(\"是CPU调度和分派的基本单位\")]),v._v(\"，\"),_(\"strong\",[v._v(\"用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位\")]),v._v(\"。每个线程都独自占用一个\"),_(\"strong\",[v._v(\"虚拟处理器\")]),v._v(\"：独自的\"),_(\"strong\",[v._v(\"寄存器组\")]),v._v(\"，\"),_(\"strong\",[v._v(\"指令计数器和处理器状态\")]),v._v(\"。每个线程完成不同的任务，但是\"),_(\"strong\",[v._v(\"共享同一地址空间\")]),v._v(\"（也就是同样的\"),_(\"strong\",[v._v(\"动态内存，映射文件，目标代码等等\")]),v._v(\"），\"),_(\"strong\",[v._v(\"打开的文件队列和其他内核资源\")]),v._v(\"。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"2、什么是原子性、可见性、有序性？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"原子性\")]),v._v(\"：一个操作或多个操作要么全部执行完成且执行过程不被中断，要么就不执行。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"可见性\")]),v._v(\"：当多个线程同时访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 violate\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"有序性\")]),v._v(\"：程序执行的顺序按照代码的先后顺序执行。重排序问题\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"3、为什么要使用多线程？\")])]),v._v(\" \"),_(\"p\",[v._v(\"简单来说就是为了提高效率\")]),v._v(\" \"),_(\"p\",[v._v(\"在单核CPU中，多线程主要是为了降低阻塞。 多线程的并发，其实是一种“伪并行”。 在每个时刻，真正执行的只有一个线程。 但是，由于多线程减少了等待IO操作（比如：磁盘、网络、\"),_(\"a\",{attrs:{href:\"https://cloud.tencent.com/solution/database?from=20065&from_column=20065\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v._v(\"数据库\"),_(\"OutboundLink\")],1),v._v(\"等）时间， 所以，多线程大大提高了程序的效率。\")]),v._v(\" \"),_(\"p\",[v._v(\"正因为追求效率，后面我们会看到线程池的应用， 线程池的产生就是因为线程之间的创建、撤销、切换具有较大的时空开销， 尽管它的开销比较进程要小得多。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"4、创建线程有哪几种方式？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"1、继承 Thread 类\")])]),v._v(\" \"),_(\"p\",[v._v(\"通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[v._v(\"首先定义一个类来继承 Thread 类，重写 run 方法。\")]),v._v(\" \"),_(\"li\",[v._v(\"然后创建这个子类对象，并调用 start 方法启动线程。\")])]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://ask.qcloudimg.com/http-save/yehe-2219188/uaa1zy9cb5.png?imageView2/2/w/1200\",alt:\"img\"}})]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"2、实现 Runnable 接口\")])]),v._v(\" \"),_(\"p\",[v._v(\"通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[v._v(\"首先定义一个类实现 Runnable 接口，并实现 run 方法。\")]),v._v(\" \"),_(\"li\",[v._v(\"然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中\")]),v._v(\" \"),_(\"li\",[v._v(\"最后调用 start 方法启动线程。\")])]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://ask.qcloudimg.com/http-save/yehe-2219188/qucp8pstk7.png?imageView2/2/w/1200\",alt:\"img\"}})]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"3、实现 Callable 接口，并结合 Future 实现\")])]),v._v(\" \"),_(\"ul\",[_(\"li\",[v._v(\"首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。\")]),v._v(\" \"),_(\"li\",[v._v(\"然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。\")]),v._v(\" \"),_(\"li\",[v._v(\"把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。\")]),v._v(\" \"),_(\"li\",[v._v(\"通过 FutureTask 的 get 方法获取线程的执行结果。\")])]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://ask.qcloudimg.com/http-save/yehe-2219188/zglut4qdvh.png?imageView2/2/w/1200\",alt:\"img\"}})]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"4、通过线程池创建线程\")])]),v._v(\" \"),_(\"p\",[v._v(\"此处用 JDK 自带的 Executors 来创建线程池对象。\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[v._v(\"首先，定一个 Runnable 的实现类，重写 run 方法。\")]),v._v(\" \"),_(\"li\",[v._v(\"然后创建一个拥有固定线程数的线程池。\")]),v._v(\" \"),_(\"li\",[v._v(\"最后通过 ExecutorService 对象的 execute 方法传入线程对象。\")])]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://ask.qcloudimg.com/http-save/yehe-2219188/grx8pgz81h.png?imageView2/2/w/1200\",alt:\"img\"}})]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"5、什么是守护线程？\")])]),v._v(\" \"),_(\"p\",[v._v(\"Java 中的线程分为两类，分别为 daemon 线程（守护线程〉和 user 线程（用户线程）。\")]),v._v(\" \"),_(\"p\",[v._v(\"在 JVM 启动时会调用 main 函数， main 函数所在的线程就是一个用户线程，其实在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"守护线程定义\")]),v._v(\"：所谓守护线程，是指在程序运行的时候在后台提供一种通用服务的线程。比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。\")]),v._v(\" \"),_(\"p\",[v._v(\"因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"用户线程定义\")]),v._v(\"：某种意义上的主要用户线程，只要有用户线程未执行完毕，JVM 虚拟机不会退出。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"区别\")]),v._v(\"：在本质上，用户线程和守护线程并没有太大区别，唯一的区别就是当最后一个非守护线程结束时，JVM 会正常退出，而不管当前是否有守护线程，也就是说守护线程是否结束并不影响 JVM 的退出。\")]),v._v(\" \"),_(\"p\",[v._v(\"言外之意，只要有一个用户线程还没结束， 正常情况下 JVM 就不会退出。\")]),v._v(\" \"),_(\"ol\",{attrs:{start:\"3\"}},[_(\"li\",[v._v(\"守护线程的特点\")])]),v._v(\" \"),_(\"p\",[v._v(\"Java 中的守护线程和 Linux 中的守护进程是有些区别的，Linux 守护进程是系统级别的，当系统退出时，才会终止。\")]),v._v(\" \"),_(\"p\",[v._v(\"而 Java 中的守护线程是 JVM 级别的，当 JVM 中无任何用户进程时，守护进程销毁，JVM 退出，程序终止。总结来说，Java 守护进程的最主要的特点有:\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[v._v(\"守护线程是运行在程序后台的线程；\")]),v._v(\" \"),_(\"li\",[v._v(\"守护线程创建的线程，依然是守护线程；\")]),v._v(\" \"),_(\"li\",[v._v(\"守护线程不会影响 JVM 的退出，当 JVM 只剩余守护线程时，JVM 进行退出；\")]),v._v(\" \"),_(\"li\",[v._v(\"守护线程在 JVM 退出时，自动销毁。\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"创建方式\")]),v._v(\"：将线程转换为守护线程可以通过调用 Thread 对象的 setDaemon (true) 方法来实现。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"创建细节\")]),v._v(\"：\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[v._v(\"thread.setDaemon (true) 必须在 thread.start () 之前设置，否则会跑出一个 llegalThreadStateException 异常。你不能把正在运行的常规线程设置为守护线程；\")]),v._v(\" \"),_(\"li\",[v._v(\"在 Daemon 线程中产生的新线程也是 Daemon 的；\")]),v._v(\" \"),_(\"li\",[v._v(\"守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。\")])]),v._v(\" \"),_(\"ol\",{attrs:{start:\"6\"}},[_(\"li\",[v._v(\"守护线程的作用及使用场景\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"作用\")]),v._v(\"：我们以 GC 垃圾回收线程举例，它就是一个经典的守护线程，当我们的程序中不再有任何运行的 Thread, 程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。\")]),v._v(\" \"),_(\"p\",[v._v(\"它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"应用场景\")]),v._v(\"：\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[v._v(\"为其它线程提供服务支持的情况，可选用守护线程；\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"根据开发需求，程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用；\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"如果一个正在执行某个操作的线程必须要执行完毕后再释放，否则就会出现不良的后果的话，那么这个线程就不能是守护线程，而是用户线程；\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"正常开发过程中，一般心跳监听，垃圾回收，临时数据清理等通用服务会选择守护线程。\")])])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"6、线程的状态有哪几种？怎么流转的？\")])]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"http://8.130.25.175:8080/img/image-20230603142022520.png\",alt:\"image-20230603142022520\"}})]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"7、线程的优先级有什么用？\")])]),v._v(\" \"),_(\"p\",[v._v(\"* Thread.setPriority()可能根本不做任何事情，这跟你的操作系统和虚拟机版本有关\\n* 线程优先级对于不同的线程调度器可能有不同的含义，可能并不是你直观的推测。特别地，优先级并不一定是指CPU的分享。在UNIX系统，优先级或多或少可以认为是CPU的分配，但Windows不是这样\\n* 线程的优先级通常是全局的和局部的优先级设定的组合。Java的setPriority()方法只应用于局部的优先级。换句话说，你不能在整个可能的范围 内设定优先级。（这通常是一种保护的方式，你大概不希望鼠标指针的线程或者处理音频数据的线程被其它随机的用户线程所抢占）\\n* 不同的系统有不同的线程优先级的取值范围，但是Java定义了10个级别（1-10）。这样就有可能出现几个线程在一个操作系统里有不同的优先级，在另外一个操作系统里却有相同的优先级（并因此可能有意想不到的行为）\\n* 操作系统可能（并通常这么做）根据线程的优先级给线程添加一些专有的行为（例如”only give a quantum boost if the priority is below X“）。这里再重复一次，优先级的定义有部分在不同系统间有差别。\\n* 大多数操作系统的线程调度器实际上执行的是在战略的角度上对线程的优先级做临时操作（例如当一个线程接收到它所等待的一个事件或者I/O），通常操作系统知道最多，试图手工控制优先级可能只会干扰这个系统。\\n* 你的应用程序通常不知道有哪些其它进程运行的线程，所以对于整个系统来说，变更一个线程的优先级所带来的影响是难于预测的。例如你可能发现，你有一个预期 为偶尔在后台运行的低优先级的线程几乎没有运行，原因是一个病毒监控程序在一个稍微高一点的优先级（但仍然低于普通的优先级）上运行，并且无法预计你程序 的性能，它会根据你的客户使用的防病毒程序不同而不同。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"8、我们常说的 JUC 是指什么？\")])]),v._v(\" \"),_(\"p\",[v._v(\"https://blog.51cto.com/u_9177933/3002229\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"9、i++ 是线程安全的吗？\")])]),v._v(\" \"),_(\"p\",[v._v(\"不是，i++三步操作，并非原子指令。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"10、join 方法有什么用？什么原理？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"11、如何让一个线程休眠？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"12、启动一个线程是用 start 还是 run 方法？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"13、start 和 run 方法有什么区别？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"14、sleep 和 wait 方法有什么区别？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"15、Thread.yield 方法有什么用？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"16、yield 和 sleep 有什么区别？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"17、怎么理解 Java 中的线程中断？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"18、你怎么理解多线程分组？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"19、你怎么理解 wait、notify、notifyAll？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"20、同步和异步的区别？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"21、什么是死锁？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"22、怎么避免死锁？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"23、什么是活锁？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"24、什么是无锁？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"25、什么是线程饥饿？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"26、什么是 CAS？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"27、阻塞和非阻塞的区别？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"28、并发和并行的区别？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"29、为什么不推荐使用 stop 停止线程？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"30、如何优雅地终止一个线程？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"31、Synchronized 同步锁有哪几种用法？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"32、什么是重入锁（ReentrantLock）？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"33、Synchronized 与 ReentrantLock 的区别？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"34、synchronized 锁的是什么?\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"35、什么是读写锁？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"36、公平锁和非公平锁的区别？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"37、有哪些锁优化的方式？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"38、什么是偏向锁？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"39、什么是轻量级锁？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"40、什么是自旋锁？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"41、什么是锁消除？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"42、什么是锁粗化？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"43、什么是重量级锁？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"44、什么是线程池？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"45、使用线程池有什么好处？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"46、创建一个线程池有哪些核心参数？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"47、线程池的工作流程是怎样的？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"48、Java 里面有哪些内置的线程池？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"49、为什么阿里不让用 Executors 创建线程池？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"50、线程池的拒绝策略有哪几种？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"51、如何提交一个线程到线程池？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"52、线程池 submit 和 execute 有什么区别？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"53、如何查看线程池的运行状态？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"54、如何设置线程池的大小？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"55、如何关闭线程池？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"56、AQS 是什么？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"57、AQS 的底层原理是什么？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"58、Java 中的 Fork Join 框架有什么用？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"59、ThreadLocal 有什么用？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"60、ThreadLocal 有什么副作用？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"61、volatile 关键字有什么用？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"62、volatile 有哪些应用场景？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"63、CyclicBarrier 有什么用？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"64、CountDownLatch 有什么用？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"65、CountDownLatch 与 CyclicBarrier 的区别？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"66、Semaphore 有什么用？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"67、Exchanger 有什么用？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"68、LockSupport 有什么用？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"69、Java 中原子操作的类有哪些？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"70、什么是 ABA 问题？怎么解决？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"71、Java 并发容器，你知道几个？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"72、什么是阻塞队列？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"73、阻塞队列有哪些常用的应用场景？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"74、Java 中的阻塞的队列有哪些？\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"75、什么是幂等性？\")])])])}),[],!1,null,null,null);_.default=n.exports}}]);","extractedComments":[]}