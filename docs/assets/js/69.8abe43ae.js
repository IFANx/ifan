(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{340:function(t,a,s){"use strict";s.r(a);var r=s(14),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"mysql基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql基础"}},[t._v("#")]),t._v(" MySQL基础")]),t._v(" "),a("h1",{attrs:{id:"执行一条-select-语句-期间发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行一条-select-语句-期间发生了什么"}},[t._v("#")]),t._v(" 执行一条 select 语句，期间发生了什么？")]),t._v(" "),a("p",[t._v("大家好，我是小林。")]),t._v(" "),a("p",[t._v("学习 SQL 的时候，大家肯定第一个先学到的就是 select 查询语句了，比如下面这句查询语句：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在 product 表中，查询 id = 1 的记录")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" product "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("但是有没有想过，"),a("strong",[t._v("MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？")])]),t._v(" "),a("p",[t._v("带着这个问题，我们可以很好的了解 MySQL 内部的架构，所以这次小林就带大家拆解一下 MySQL 内部的结构，看看内部里的每一个“零件”具体是负责做什么的。")]),t._v(" "),a("h2",{attrs:{id:"mysql-执行流程是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-执行流程是怎样的"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("MySQL 执行流程是怎样的？")]),t._v(" "),a("p",[t._v("先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png",alt:"查询语句执行流程"}})]),t._v(" "),a("p",[t._v("可以看到， MySQL 的架构共分为两层："),a("strong",[t._v("Server 层和存储引擎层")]),t._v("，")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Server 层负责建立连接、分析和执行 SQL")]),t._v("。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。")]),t._v(" "),a("li",[a("strong",[t._v("存储引擎层负责数据的存储和提取")]),t._v("。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。")])]),t._v(" "),a("p",[t._v("好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。")]),t._v(" "),a("h2",{attrs:{id:"第一步-连接器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一步-连接器"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E7%AC%AC%E4%B8%80%E6%AD%A5-%E8%BF%9E%E6%8E%A5%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("第一步：连接器")]),t._v(" "),a("p",[t._v("如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，普遍我们都是使用下面这条命令进行连接：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -u 指定用户名，管理员角色名为 root；")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码")]),t._v("\nmysql -h"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$ip")]),t._v(" -u"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-p")]),t._v("\n")])])]),a("p",[t._v("连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务并没有启动，则会收到如下的报错：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF.png",alt:"img"}})]),t._v(" "),a("p",[t._v('如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个"Access denied for user"的错误，然后客户端程序结束执行。')]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF.png",alt:"img"}})]),t._v(" "),a("p",[t._v("如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。")]),t._v(" "),a("p",[t._v("所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。")]),t._v(" "),a("blockquote",[a("p",[t._v("如何查看 MySQL 服务被多少个客户端连接了？")])]),t._v(" "),a("p",[t._v("如果你想知道当前 MySQL 服务被多少个客户端连接了，你可以执行 "),a("code",[t._v("show processlist")]),t._v(" 命令进行查看。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5.png",alt:"img"}})]),t._v(" "),a("p",[t._v("比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 "),a("code",[t._v("Sleep")]),t._v(" ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。")]),t._v(" "),a("blockquote",[a("p",[t._v("空闲连接会一直占用着吗？")])]),t._v(" "),a("p",[t._v("当然不是了，MySQL 定义了空闲连接的最大空闲时长，由 "),a("code",[t._v("wait_timeout")]),t._v(" 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("show")]),t._v(" variables "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("like")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'wait_timeout'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("---------------+-------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Variable_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Value")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("---------------+-------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" wait_timeout  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("28800")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("---------------+-------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("row")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.00")]),t._v(" sec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("kill")]),t._v(" connection "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nQuery OK"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("rows")]),t._v(" affected "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.00")]),t._v(" sec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL 的连接数有限制吗？")])]),t._v(" "),a("p",[t._v("MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("show")]),t._v(" variables "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("like")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'max_connections'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-----------------+-------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Variable_name   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Value")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-----------------+-------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" max_connections "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("151")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-----------------+-------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("row")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.00")]),t._v(" sec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 短连接")]),t._v("\n连接 mysql 服务（TCP 三次握手）\n执行sql\n断开 mysql 服务（TCP 四次挥手）\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 长连接")]),t._v("\n连接 mysql 服务（TCP 三次握手）\n执行sql\n执行sql\n执行sql\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n断开 mysql 服务（TCP 四次挥手）\n")])])]),a("p",[t._v("可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。")]),t._v(" "),a("p",[t._v("但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。")]),t._v(" "),a("blockquote",[a("p",[t._v("怎么解决长连接占用内存的问题？")])]),t._v(" "),a("p",[t._v("有两种解决方式。")]),t._v(" "),a("p",[t._v("第一种，"),a("strong",[t._v("定期断开长连接")]),t._v("。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。")]),t._v(" "),a("p",[t._v("第二种，"),a("strong",[t._v("客户端主动重置连接")]),t._v("。MySQL 5.7 版本实现了 "),a("code",[t._v("mysql_reset_connection()")]),t._v(" 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。")]),t._v(" "),a("p",[t._v("至此，连接器的工作做完了，简单总结一下：")]),t._v(" "),a("ul",[a("li",[t._v("与客户端进行 TCP 三次握手建立连接；")]),t._v(" "),a("li",[t._v("校验客户端的用户名和密码，如果用户名或密码不对，则会报错；")]),t._v(" "),a("li",[t._v("如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；")])]),t._v(" "),a("h2",{attrs:{id:"第二步-查询缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二步-查询缓存"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("第二步：查询缓存")]),t._v(" "),a("p",[t._v("连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。")]),t._v(" "),a("p",[t._v("如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。")]),t._v(" "),a("p",[t._v("如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。")]),t._v(" "),a("p",[t._v("这么看，查询缓存还挺有用，但是其实"),a("strong",[t._v("查询缓存挺鸡肋")]),t._v("的。")]),t._v(" "),a("p",[t._v("对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。")]),t._v(" "),a("p",[t._v("所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。")]),t._v(" "),a("p",[t._v("对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。")]),t._v(" "),a("p",[t._v("TIP")]),t._v(" "),a("p",[t._v("这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool。")]),t._v(" "),a("h2",{attrs:{id:"第三步-解析-sql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三步-解析-sql"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E7%AC%AC%E4%B8%89%E6%AD%A5-%E8%A7%A3%E6%9E%90-sql",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("第三步：解析 SQL")]),t._v(" "),a("p",[t._v("在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成。")]),t._v(" "),a("h3",{attrs:{id:"解析器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解析器"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E8%A7%A3%E6%9E%90%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("解析器")]),t._v(" "),a("p",[t._v("解析器会做如下两件事情。")]),t._v(" "),a("p",[t._v("第一件事情，"),a("strong",[t._v("词法分析")]),t._v("。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。")]),t._v(" "),a("p",[t._v("第二件事情，"),a("strong",[t._v("语法分析")]),t._v("。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。")]),t._v(" "),a("p",[t._v("如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF.png",alt:"img"}})]),t._v(" "),a("p",[t._v("但是注意，表不存在或者字段不存在，并不是在解析器里做的，《MySQL 45 讲》说是在解析器做的，但是经过我和朋友看 MySQL 源码（5.7和8.0）得出结论是解析器只负责构建语法树和检查语法，但是不会去查表或者字段存不存在。")]),t._v(" "),a("p",[t._v("那到底谁来做检测表和字段是否存在的工作呢？别急，接下来就是了。")]),t._v(" "),a("h2",{attrs:{id:"第四步-执行-sql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第四步-执行-sql"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E7%AC%AC%E5%9B%9B%E6%AD%A5-%E6%89%A7%E8%A1%8C-sql",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("第四步：执行 SQL")]),t._v(" "),a("p",[t._v("经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条"),a("code",[t._v("SELECT")]),t._v(" 查询语句流程主要可以分为下面这三个阶段：")]),t._v(" "),a("ul",[a("li",[t._v("prepare 阶段，也就是预处理阶段；")]),t._v(" "),a("li",[t._v("optimize 阶段，也就是优化阶段；")]),t._v(" "),a("li",[t._v("execute 阶段，也就是执行阶段；")])]),t._v(" "),a("h3",{attrs:{id:"预处理器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#预处理器"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("预处理器")]),t._v(" "),a("p",[t._v("我们先来说说预处理阶段做了什么事情。")]),t._v(" "),a("ul",[a("li",[t._v("检查 SQL 查询语句中的表或者字段是否存在；")]),t._v(" "),a("li",[t._v("将 "),a("code",[t._v("select *")]),t._v(" 中的 "),a("code",[t._v("*")]),t._v(" 符号，扩展为表上的所有列；")])]),t._v(" "),a("p",[t._v("我下面这条查询语句，test 这张表是不存在的，这时 MySQL 就会在执行 SQL 查询语句的 prepare 阶段中报错。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" test"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nERROR "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1146")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),t._v("S02"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Table")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'mysql.test'")]),t._v(" doesn't exist\n")])])]),a("p",[t._v("这里贴个 MySQL 8.0 源码来证明表或字段是否存在的判断，不是在解析器里做的，而是在 prepare 阶段。（"),a("em",[t._v("PS：下图是公众号「一树一溪」老哥帮我分析的，这位老哥专门写 MySQL 源码文章，感兴趣的朋友，可以微信搜索关注")]),t._v("）")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%A1%A8%E4%B8%8D%E5%AD%98%E5%9C%A8.jpeg",alt:"img"}})]),t._v(" "),a("p",[t._v("上面的中间部分是 MySQL 报错表不存在时的函数调用栈，可以看到表不存在的错误是在get_table_share() 函数里报错的，而这个函数是在 prepare 阶段调用的。")]),t._v(" "),a("p",[t._v("不过，对于 MySQL 5.7 判断表或字段是否存在的工作，是在词法分析&语法分析之后，prepare 阶段之前做的。结论都一样，不是在解析器里做的。代码我就不放了，正因为 MySQL 5.7 代码结构不好，所以 MySQL 8.0 代码结构变化很大，后来判断表或字段是否存在的工作就被放入到 prepare 阶段做了。")]),t._v(" "),a("h3",{attrs:{id:"优化器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化器"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E4%BC%98%E5%8C%96%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("优化器")]),t._v(" "),a("p",[t._v("经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。")]),t._v(" "),a("p",[a("strong",[t._v("优化器主要负责将 SQL 查询语句的执行方案确定下来")]),t._v("，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。")]),t._v(" "),a("p",[t._v("当然，我们本次的查询语句（select * from product where id = 1）很简单，就是选择使用主键索引。")]),t._v(" "),a("p",[t._v("要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 "),a("code",[t._v("explain")]),t._v(" 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，比如下图的 key 为 "),a("code",[t._v("PRIMARY")]),t._v(" 就是使用了主键索引。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png",alt:"img"}})]),t._v(" "),a("p",[t._v("如果查询语句的执行计划里的 key 为 null 说明没有使用索引，那就会全表扫描（type = ALL），这种查询扫描的方式是效率最低档次的，如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F.png",alt:"img"}})]),t._v(" "),a("p",[t._v("这张 product 表只有一个索引就是主键，现在我在表中将 name 设置为普通索引（二级索引）。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E4%BA%A7%E5%93%81%E8%A1%A8.png",alt:"img"}})]),t._v(" "),a("p",[t._v("这时 product 表就有主键索引（id）和普通索引（name）。假设执行了这条查询语句：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" product "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("and")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("like")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'i%'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。")]),t._v(" "),a("p",[t._v("很显然这条查询语句是"),a("strong",[t._v("覆盖索引")]),t._v("，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。")]),t._v(" "),a("p",[t._v("在下图中执行计划，我们可以看到，执行过程中使用了普通索引（name），Exta 为 Using index，这就是表明使用了覆盖索引优化。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"执行器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行器"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E6%89%A7%E8%A1%8C%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("执行器")]),t._v(" "),a("p",[t._v("经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。")]),t._v(" "),a("p",[t._v("接下来，用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程（PS ：为了写好这一部分，特地去看 MySQL 源码，也是第一次看哈哈）。")]),t._v(" "),a("ul",[a("li",[t._v("主键索引查询")]),t._v(" "),a("li",[t._v("全表扫描")]),t._v(" "),a("li",[t._v("索引下推")])]),t._v(" "),a("h4",{attrs:{id:"主键索引查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主键索引查询"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("主键索引查询")]),t._v(" "),a("p",[t._v("以本文开头查询语句为例，看看执行器是怎么工作的。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" product "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：")]),t._v(" "),a("ul",[a("li",[t._v("执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 "),a("code",[t._v("id = 1")]),t._v(" 交给存储引擎，"),a("strong",[t._v("让存储引擎定位符合条件的第一条记录")]),t._v("。")]),t._v(" "),a("li",[t._v("存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；")]),t._v(" "),a("li",[t._v("执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。")]),t._v(" "),a("li",[t._v("执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。")])]),t._v(" "),a("p",[t._v("至此，这个语句就执行完成了。")]),t._v(" "),a("h4",{attrs:{id:"全表扫描"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全表扫描"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("全表扫描")]),t._v(" "),a("p",[t._v("举个全表扫描的例子：")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("select * from product where name = 'iphone';\n")])])]),a("p",[t._v("这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：")]),t._v(" "),a("ul",[a("li",[t._v("执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，"),a("strong",[t._v("让存储引擎读取表中的第一条记录")]),t._v("；")]),t._v(" "),a("li",[t._v("执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。")]),t._v(" "),a("li",[t._v("执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；")]),t._v(" "),a("li",[t._v("一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；")]),t._v(" "),a("li",[t._v("执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。")])]),t._v(" "),a("p",[t._v("至此，这个语句就执行完成了。")]),t._v(" "),a("h4",{attrs:{id:"索引下推"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引下推"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("索引下推")]),t._v(" "),a("p",[t._v("在这部分非常适合讲索引下推（MySQL 5.6 推出的查询优化策略），这样大家能清楚的知道，「下推」这个动作，下推到了哪里。")]),t._v(" "),a("p",[t._v("索引下推能够减少"),a("strong",[t._v("二级索引")]),t._v("在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。")]),t._v(" "),a("p",[t._v("举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%B7%AF%E9%A3%9E%E8%A1%A8.png",alt:"img"}})]),t._v(" "),a("p",[t._v("现在有下面这条查询语句：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" t_user  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("and")]),t._v(" reward "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("联合索引当遇到范围查询 (>、<) 就会停止匹配，也就是 "),a("strong",[t._v("age 字段能用到联合索引，但是 reward 字段则无法利用到索引")]),t._v("。具体原因这里可以看这篇："),a("a",{attrs:{href:"https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB",target:"_blank",rel:"noopener noreferrer"}},[t._v("索引常见面试题(opens new window)"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：")]),t._v(" "),a("ul",[a("li",[t._v("Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；")]),t._v(" "),a("li",[t._v("存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后"),a("strong",[t._v("进行回表操作")]),t._v("，将完整的记录返回给 Server 层；")]),t._v(" "),a("li",[t._v("Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；")]),t._v(" "),a("li",[t._v("接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；")]),t._v(" "),a("li",[t._v("如此往复，直到存储引擎把表中的所有记录读完。")])]),t._v(" "),a("p",[t._v("可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。")]),t._v(" "),a("p",[t._v("而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：")]),t._v(" "),a("ul",[a("li",[t._v("Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；")]),t._v(" "),a("li",[t._v("存储引擎定位到二级索引后，"),a("strong",[t._v("先不执行回表")]),t._v("操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果"),a("strong",[t._v("条件不成立")]),t._v("，则直接"),a("strong",[t._v("跳过该二级索引")]),t._v("。如果"),a("strong",[t._v("成立")]),t._v("，则"),a("strong",[t._v("执行回表")]),t._v("操作，将完成记录返回给 Server 层。")]),t._v(" "),a("li",[t._v("Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。")]),t._v(" "),a("li",[t._v("如此往复，直到存储引擎把表中的所有记录读完。")])]),t._v(" "),a("p",[t._v("可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward = 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。")]),t._v(" "),a("p",[t._v("当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png",alt:"img"}})]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/how_select.html#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("总结")]),t._v(" "),a("p",[t._v("执行一条 SQL 查询语句，期间发生了什么？")]),t._v(" "),a("ul",[a("li",[t._v("连接器：建立连接，管理连接、校验用户身份；")]),t._v(" "),a("li",[t._v("查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；")]),t._v(" "),a("li",[t._v("解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；")]),t._v(" "),a("li",[t._v("执行 SQL：执行 SQL 共有三个阶段：\n"),a("ul",[a("li",[t._v("预处理阶段：检查表或字段是否存在；将 "),a("code",[t._v("select *")]),t._v(" 中的 "),a("code",[t._v("*")]),t._v(" 符号扩展为表上的所有列。")]),t._v(" "),a("li",[t._v("优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；")]),t._v(" "),a("li",[t._v("执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；")])])])]),t._v(" "),a("p",[t._v("怎么样？现在再看这张图，是不是很清晰了。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png",alt:"查询语句执行流程"}})]),t._v(" "),a("h1",{attrs:{id:"mysql-一行记录是怎么存储的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-一行记录是怎么存储的"}},[t._v("#")]),t._v(" MySQL 一行记录是怎么存储的？")]),t._v(" "),a("p",[t._v("大家好，我是小林。")]),t._v(" "),a("p",[t._v("之前有位读者在面字节的时候，被问到这么个问题：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%AF%BB%E8%80%85%E9%97%AE%E9%A2%98.jpeg",alt:"img"}})]),t._v(" "),a("p",[t._v("如果你知道 MySQL 一行记录的存储结构，那么这个问题对你没什么难度。")]),t._v(" "),a("p",[t._v("如果你不知道也没关系，这次我跟大家聊聊 "),a("strong",[t._v("MySQL 一行记录是怎么存储的？")])]),t._v(" "),a("p",[t._v("知道了这个之后，除了能应解锁前面这道面试题，你还会解锁这些面试题：")]),t._v(" "),a("ul",[a("li",[t._v("MySQL 的 NULL 值会占用空间吗？")]),t._v(" "),a("li",[t._v("MySQL 怎么知道 varchar(n) 实际占用数据的大小？")]),t._v(" "),a("li",[t._v("varchar(n) 中 n 最大取值为多少？")]),t._v(" "),a("li",[t._v("行溢出后，MySQL 是怎么处理的？")])]),t._v(" "),a("p",[t._v("这些问题看似毫不相干，其实都是在围绕「 MySQL 一行记录的存储结构」这一个知识点，所以攻破了这个知识点后，这些问题就引刃而解了。")]),t._v(" "),a("p",[t._v("好了，话不多说，发车！")]),t._v(" "),a("h2",{attrs:{id:"mysql-的数据存放在哪个文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-的数据存放在哪个文件"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#mysql-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%96%87%E4%BB%B6",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("MySQL 的数据存放在哪个文件？")]),t._v(" "),a("p",[t._v("大家都知道 MySQL 的数据都是保存在磁盘的，那具体是保存在哪个文件呢？")]),t._v(" "),a("p",[t._v("MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。")]),t._v(" "),a("p",[t._v("InnoDB 是我们常用的存储引擎，也是 MySQL 默认的存储引擎。所以，本文主要以 InnoDB 存储引擎展开讨论。")]),t._v(" "),a("p",[t._v("先来看看 MySQL 数据库的文件存放在哪个目录？")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SHOW")]),t._v(" VARIABLES "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("LIKE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'datadir'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("---------------+-----------------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Variable_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Value")]),t._v("           "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("---------------+-----------------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" datadir       "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("var"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("lib"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("---------------+-----------------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("row")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.00")]),t._v(" sec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。")]),t._v(" "),a("p",[t._v("比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/database.png",alt:"img"}})]),t._v(" "),a("p",[t._v("然后，我们进入 /var/lib/mysql/my_test 目录，看看里面有什么文件？")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("root@xiaolin ~"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#ls /var/lib/mysql/my_test")]),t._v("\ndb.opt  \nt_order.frm  \nt_order.ibd\n")])])]),a("p",[t._v("可以看到，共有三个文件，这三个文件分别代表着：")]),t._v(" "),a("ul",[a("li",[t._v("db.opt，用来存储当前数据库的默认字符集和字符校验规则。")]),t._v(" "),a("li",[t._v("t_order.frm ，t_order 的"),a("strong",[t._v("表结构")]),t._v("会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。")]),t._v(" "),a("li",[t._v("t_order.ibd，t_order 的"),a("strong",[t._v("表数据")]),t._v("会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。")])]),t._v(" "),a("p",[t._v("好了，现在我们知道了一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件。")]),t._v(" "),a("h3",{attrs:{id:"表空间文件的结构是怎么样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表空间文件的结构是怎么样的"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("表空间文件的结构是怎么样的？")]),t._v(" "),a("p",[a("strong",[t._v("表空间由段（segment）、区（extent）、页（page）、行（row）组成")]),t._v("，InnoDB存储引擎的逻辑存储结构大致如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png",alt:"img"}})]),t._v(" "),a("p",[t._v("下面我们从下往上一个个看看。")]),t._v(" "),a("h4",{attrs:{id:"_1、行-row"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、行-row"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#_1%E3%80%81%E8%A1%8C-row",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("1、行（row）")]),t._v(" "),a("p",[t._v("数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。")]),t._v(" "),a("p",[t._v("后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容。")]),t._v(" "),a("h4",{attrs:{id:"_2、页-page"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、页-page"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#_2%E3%80%81%E9%A1%B5-page",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("2、页（page）")]),t._v(" "),a("p",[t._v("记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。")]),t._v(" "),a("p",[t._v("因此，"),a("strong",[t._v("InnoDB 的数据是按「页」为单位来读写的")]),t._v("，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。")]),t._v(" "),a("p",[a("strong",[t._v("默认每个页的大小为 16KB")]),t._v("，也就是最多能保证 16KB 的连续存储空间。")]),t._v(" "),a("p",[t._v("页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。")]),t._v(" "),a("p",[t._v("页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的，数据页的结构这里我就不讲细说了，之前文章有说过，感兴趣的可以去看这篇文章："),a("a",{attrs:{href:"https://xiaolincoding.com/mysql/index/page.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("换一个角度看 B+ 树(opens new window)"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("总之知道表中的记录存储在「数据页」里面就行。")]),t._v(" "),a("h4",{attrs:{id:"_3、区-extent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、区-extent"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#_3%E3%80%81%E5%8C%BA-extent",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("3、区（extent）")]),t._v(" "),a("p",[t._v("我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。")]),t._v(" "),a("p",[t._v("B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。")]),t._v(" "),a("p",[t._v("解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。")]),t._v(" "),a("p",[t._v("那具体怎么解决呢？")]),t._v(" "),a("p",[a("strong",[t._v("在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了")]),t._v("。")]),t._v(" "),a("h4",{attrs:{id:"_4、段-segment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、段-segment"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#_4%E3%80%81%E6%AE%B5-segment",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("4、段（segment）")]),t._v(" "),a("p",[t._v("表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。")]),t._v(" "),a("ul",[a("li",[t._v("索引段：存放 B + 树的非叶子节点的区的集合；")]),t._v(" "),a("li",[t._v("数据段：存放 B + 树的叶子节点的区的集合；")]),t._v(" "),a("li",[t._v("回滚段：存放的是回滚数据的区的集合，之前讲"),a("a",{attrs:{href:"https://xiaolincoding.com/mysql/transaction/mvcc.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("事务隔离 (opens new window)"),a("OutboundLink")],1),t._v("的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。")])]),t._v(" "),a("p",[t._v("好了，终于说完表空间的结构了。接下来，就具体讲一下 InnoDB 的行格式了。")]),t._v(" "),a("p",[t._v("之所以要绕一大圈才讲行记录的格式，主要是想让大家知道行记录是存储在哪个文件，以及行记录在这个表空间文件中的哪个区域，有一个从上往下切入的视角，这样理解起来不会觉得很抽象。")]),t._v(" "),a("h2",{attrs:{id:"innodb-行格式有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb-行格式有哪些"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#innodb-%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("InnoDB 行格式有哪些？")]),t._v(" "),a("p",[t._v("行格式（row_format），就是一条记录的存储结构。")]),t._v(" "),a("p",[t._v("InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。")]),t._v(" "),a("ul",[a("li",[t._v("Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。")]),t._v(" "),a("li",[t._v("由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。")]),t._v(" "),a("li",[t._v("Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。")])]),t._v(" "),a("p",[t._v("Redundant 行格式我这里就不讲了，因为现在基本没人用了，这次重点介绍 Compact 行格式，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。")]),t._v(" "),a("p",[t._v("所以，弄懂了 Compact 行格式，之后你们在去了解其他行格式，很快也能看懂。")]),t._v(" "),a("h2",{attrs:{id:"compact-行格式长什么样"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compact-行格式长什么样"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#compact-%E8%A1%8C%E6%A0%BC%E5%BC%8F%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("COMPACT 行格式长什么样？")]),t._v(" "),a("p",[t._v("先跟 Compact 行格式混个脸熟，它长这样：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png",alt:"img"}})]),t._v(" "),a("p",[t._v("可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。")]),t._v(" "),a("p",[t._v("接下里，分别详细说下。")]),t._v(" "),a("h3",{attrs:{id:"记录的额外信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#记录的额外信息"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#%E8%AE%B0%E5%BD%95%E7%9A%84%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("记录的额外信息")]),t._v(" "),a("p",[t._v("记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。")]),t._v(" "),a("h4",{attrs:{id:"_1-变长字段长度列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-变长字段长度列表"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#_1-%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("1. 变长字段长度列表")]),t._v(" "),a("p",[t._v("varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。")]),t._v(" "),a("p",[t._v("所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。")]),t._v(" "),a("p",[t._v("为了展示「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("t_user"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VARCHAR")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DEFAULT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("phone"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VARCHAR")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DEFAULT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("age"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DEFAULT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PRIMARY")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("KEY")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("USING")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BTREE")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ENGINE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("InnoDB")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DEFAULT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CHARACTER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ascii ROW_FORMAT "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" COMPACT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("现在 t_user 表里有这三条记录：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/t_test.png",alt:"img"}})]),t._v(" "),a("p",[t._v("接下来，我们看看看看这三条记录的行格式中的 「变长字段长度列表」是怎样存储的。")]),t._v(" "),a("p",[t._v("先来看第一条记录：")]),t._v(" "),a("ul",[a("li",[t._v("name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；")]),t._v(" "),a("li",[t._v("phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；")]),t._v(" "),a("li",[t._v("age 列和 id 列不是变长字段，所以这里不用管。")])]),t._v(" "),a("p",[t._v("这些变长字段的真实数据占用的字节数会按照列的顺序"),a("strong",[t._v("逆序存放")]),t._v("（等下会说为什么要这么设计），所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A81.png",alt:"img"}})]),t._v(" "),a("p",[t._v("同样的道理，我们也可以得出"),a("strong",[t._v("第二条记录")]),t._v("的行格式中，「变长字段长度列表」里的内容是「 04 02」，如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A82.png",alt:"img"}})]),t._v(" "),a("p",[a("strong",[t._v("第三条记录")]),t._v("中 phone 列的值是 NULL，"),a("strong",[t._v("NULL 是不会存放在行格式中记录的真实数据部分里的")]),t._v("，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A83.png",alt:"img"}})]),t._v(" "),a("blockquote",[a("p",[t._v("为什么「变长字段长度列表」的信息要按照逆序存放？")])]),t._v(" "),a("p",[t._v("这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。")]),t._v(" "),a("p",[t._v("「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以"),a("strong",[t._v("使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率")]),t._v("。")]),t._v(" "),a("p",[t._v("同样的道理， NULL 值列表的信息也需要逆序存放。")]),t._v(" "),a("p",[t._v("如果你不知道什么是 CPU Cache，可以看"),a("a",{attrs:{href:"https://xiaolincoding.com/os/1_hardware/how_to_make_cpu_run_faster.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("这篇文章 (opens new window)"),a("OutboundLink")],1),t._v("，这属于计算机组成的知识。")]),t._v(" "),a("blockquote",[a("p",[t._v("每个数据库表的行格式都有「变长字段字节数列表」吗？")])]),t._v(" "),a("p",[t._v("其实变长字段字节数列表不是必须的。")]),t._v(" "),a("p",[a("strong",[t._v("当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了")]),t._v("，因为没必要，不如去掉以节省空间。")]),t._v(" "),a("p",[t._v("所以「变长字段长度列表」只出现在数据表有变长字段的时候。")]),t._v(" "),a("h4",{attrs:{id:"_2-null-值列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-null-值列表"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#_2-null-%E5%80%BC%E5%88%97%E8%A1%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("2. NULL 值列表")]),t._v(" "),a("p",[t._v("表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。")]),t._v(" "),a("p",[t._v("如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。")]),t._v(" "),a("ul",[a("li",[t._v("二进制位的值为"),a("code",[t._v("1")]),t._v("时，代表该列的值为NULL。")]),t._v(" "),a("li",[t._v("二进制位的值为"),a("code",[t._v("0")]),t._v("时，代表该列的值不为NULL。")])]),t._v(" "),a("p",[t._v("另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 "),a("code",[t._v("0")]),t._v("。")]),t._v(" "),a("p",[t._v("还是以 t_user 表的这三条记录作为例子：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/t_test.png",alt:"img"}})]),t._v(" "),a("p",[t._v("接下来，我们看看看看这三条记录的行格式中的 NULL 值列表是怎样存储的。")]),t._v(" "),a("p",[t._v("先来看"),a("strong",[t._v("第一条记录")]),t._v("，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是酱紫的：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null%E5%80%BC%E5%88%97%E8%A1%A81.png",alt:"img"}})]),t._v(" "),a("p",[t._v("但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是酱紫的：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null%E5%80%BC%E5%88%97%E8%A1%A82.png",alt:"img"}})]),t._v(" "),a("p",[t._v("所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。")]),t._v(" "),a("p",[t._v("接下来看"),a("strong",[t._v("第二条记录")]),t._v("，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null%E5%80%BC%E5%88%97%E8%A1%A83.png",alt:"img"}})]),t._v(" "),a("p",[t._v("最后"),a("strong",[t._v("第三条记录")]),t._v("，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null%E5%80%BC%E5%88%97%E8%A1%A84.png",alt:"img"}})]),t._v(" "),a("p",[t._v("我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null%E5%80%BC%E5%88%97%E8%A1%A85.png",alt:"img"}})]),t._v(" "),a("blockquote",[a("p",[t._v("每个数据库表的行格式都有「NULL 值列表」吗？")])]),t._v(" "),a("p",[t._v("NULL 值列表也不是必须的。")]),t._v(" "),a("p",[a("strong",[t._v("当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了")]),t._v("。")]),t._v(" "),a("p",[t._v("所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。")]),t._v(" "),a("blockquote",[a("p",[t._v("「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？")])]),t._v(" "),a("p",[t._v("「NULL 值列表」的空间不是固定 1 字节的。")]),t._v(" "),a("p",[t._v("当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。")]),t._v(" "),a("h4",{attrs:{id:"_3-记录头信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-记录头信息"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#_3-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("3. 记录头信息")]),t._v(" "),a("p",[t._v("记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：")]),t._v(" "),a("ul",[a("li",[t._v("delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。")]),t._v(" "),a("li",[t._v("next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。")]),t._v(" "),a("li",[t._v("record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录")])]),t._v(" "),a("h3",{attrs:{id:"记录的真实数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#记录的真实数据"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("记录的真实数据")]),t._v(" "),a("p",[t._v("记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.png",alt:"img"}})]),t._v(" "),a("ul",[a("li",[t._v("row_id")])]),t._v(" "),a("p",[t._v("如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。")]),t._v(" "),a("ul",[a("li",[t._v("trx_id")])]),t._v(" "),a("p",[t._v("事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。")]),t._v(" "),a("ul",[a("li",[t._v("roll_pointer")])]),t._v(" "),a("p",[t._v("这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。")]),t._v(" "),a("p",[t._v("如果你熟悉 MVCC 机制，你应该就清楚 trx_id 和 roll_pointer 的作用了，如果你还不知道 MVCC 机制，可以看完"),a("a",{attrs:{href:"https://xiaolincoding.com/mysql/transaction/mvcc.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("这篇文章 (opens new window)"),a("OutboundLink")],1),t._v("，一定要掌握，面试也很经常问 MVCC 是怎么实现的。")]),t._v(" "),a("h2",{attrs:{id:"varchar-n-中-n-最大取值为多少"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#varchar-n-中-n-最大取值为多少"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#varchar-n-%E4%B8%AD-n-%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC%E4%B8%BA%E5%A4%9A%E5%B0%91",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("varchar(n) 中 n 最大取值为多少？")]),t._v(" "),a("p",[t._v("我们要清楚一点，"),a("strong",[t._v("MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节")]),t._v("。")]),t._v(" "),a("p",[t._v("也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。")]),t._v(" "),a("p",[t._v("知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」")]),t._v(" "),a("p",[t._v("varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。")]),t._v(" "),a("p",[t._v("要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。")]),t._v(" "),a("h3",{attrs:{id:"单字段的情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单字段的情况"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#%E5%8D%95%E5%AD%97%E6%AE%B5%E7%9A%84%E6%83%85%E5%86%B5",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("单字段的情况")]),t._v(" "),a("p",[t._v("前面我们知道了，一行记录最大只能存储 65535 字节的数据。")]),t._v(" "),a("p",[t._v("那假设数据库表只有一个 varchar(n) 类型的列且字符集是 ascii，在这种情况下， varchar(n) 中 n 最大取值是 65535 吗？")]),t._v(" "),a("p",[t._v("不着急说结论，我们先来做个实验验证一下。")]),t._v(" "),a("p",[t._v("我们定义一个 varchar(65535) 类型的字段，字符集为 ascii 的数据库表。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" test "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VARCHAR")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("65535")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ENGINE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("InnoDB")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DEFAULT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CHARACTER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ascii ROW_FORMAT "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" COMPACT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("看能不能成功创建一张表：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/error.png",alt:"img"}})]),t._v(" "),a("p",[t._v("可以看到，创建失败了。")]),t._v(" "),a("p",[t._v("从报错信息就可以知道"),a("strong",[t._v("一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead")]),t._v("。")]),t._v(" "),a("p",[t._v("问题来了，这个 storage overhead 是什么呢？其实就是「变长字段长度列表」和 「NULL 值列表」，也就是说"),a("strong",[t._v("一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的")]),t._v("。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。")]),t._v(" "),a("p",[t._v("这是因为我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：")]),t._v(" "),a("ul",[a("li",[t._v("真实数据")]),t._v(" "),a("li",[t._v("真实数据占用的字节数")]),t._v(" "),a("li",[t._v("NULL 标识，如果不允许为NULL，这部分不需要")])]),t._v(" "),a("blockquote",[a("p",[t._v("本次案例中，「NULL 值列表」所占用的字节数是多少？")])]),t._v(" "),a("p",[t._v("前面我创建表的时候，字段是允许为 NULL 的，所以"),a("strong",[t._v("会用 1 字节来表示「NULL 值列表」")]),t._v("。")]),t._v(" "),a("blockquote",[a("p",[t._v("本次案例中，「变长字段长度列表」所占用的字节数是多少？")])]),t._v(" "),a("p",[t._v("「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和。")]),t._v(" "),a("p",[t._v("所以，我们要先知道每个变长字段的「变长字段长度」需要用多少字节表示？具体情况分为：")]),t._v(" "),a("ul",[a("li",[t._v("条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；")]),t._v(" "),a("li",[t._v("条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；")])]),t._v(" "),a("p",[t._v("我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」。")]),t._v(" "),a("p",[a("strong",[t._v("因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」= 1 个「变长字段长度」占用的字节数，也就是 2 字节")]),t._v("。")]),t._v(" "),a("p",[t._v("因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，"),a("strong",[t._v("在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 = 65535 - 2 - 1 = 65532")]),t._v("。")]),t._v(" "),a("p",[t._v("我们先来测试看看 varchar(65533) 是否可行？")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/65533.png",alt:"img"}})]),t._v(" "),a("p",[t._v("可以看到，还是不行，接下来看看 varchar(65532) 是否可行？")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/65532.png",alt:"img"}})]),t._v(" "),a("p",[t._v("可以看到，创建成功了。说明我们的推论是正确的，在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。")]),t._v(" "),a("p",[t._v("当然，我上面这个例子是针对字符集为 ascii 情况，如果采用的是 UTF-8，varchar(n) 最多能存储的数据计算方式就不一样了：")]),t._v(" "),a("ul",[a("li",[t._v("在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。")])]),t._v(" "),a("p",[t._v("上面所说的只是针对于一个字段的计算方式。")]),t._v(" "),a("h3",{attrs:{id:"多字段的情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多字段的情况"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#%E5%A4%9A%E5%AD%97%E6%AE%B5%E7%9A%84%E6%83%85%E5%86%B5",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("多字段的情况")]),t._v(" "),a("p",[a("strong",[t._v("如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535")]),t._v("。")]),t._v(" "),a("p",[t._v("这里举个多字段的情况的例子（感谢@Emoji同学提供的例子）")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E5%A4%9A%E5%AD%97%E6%AE%B5%E7%9A%84%E6%83%85%E5%86%B5.png",alt:"img"}})]),t._v(" "),a("h2",{attrs:{id:"行溢出后-mysql-是怎么处理的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行溢出后-mysql-是怎么处理的"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#%E8%A1%8C%E6%BA%A2%E5%87%BA%E5%90%8E-mysql-%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("行溢出后，MySQL 是怎么处理的？")]),t._v(" "),a("p",[t._v("MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 "),a("code",[t._v("16KB")]),t._v("，也就是 "),a("code",[t._v("16384字节")]),t._v("，而一个 varchar(n) 类型的列最多可以存储 "),a("code",[t._v("65532字节")]),t._v("，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会"),a("strong",[t._v("发生行溢出，多的数据就会存到另外的「溢出页」中")]),t._v("。")]),t._v(" "),a("p",[t._v("如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。")]),t._v(" "),a("p",[t._v("当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA.png",alt:"img"}})]),t._v(" "),a("p",[t._v("上面这个是 Compact 行格式在发生行溢出后的处理。")]),t._v(" "),a("p",[t._v("Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。")]),t._v(" "),a("p",[t._v("这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA2.png",alt:"img"}})]),t._v(" "),a("h2",{attrs:{id:"总结-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://www.xiaolincoding.com/mysql/base/row_format.html#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("总结")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL 的 NULL 值是怎么存放的？")])]),t._v(" "),a("p",[t._v("MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。")]),t._v(" "),a("p",[t._v("NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL 怎么知道 varchar(n) 实际占用数据的大小？")])]),t._v(" "),a("p",[t._v("MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。")]),t._v(" "),a("blockquote",[a("p",[t._v("varchar(n) 中 n 最大取值为多少？")])]),t._v(" "),a("p",[t._v("一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。")]),t._v(" "),a("p",[t._v("如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。")]),t._v(" "),a("p",[t._v("计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。")]),t._v(" "),a("p",[t._v("如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535。")]),t._v(" "),a("blockquote",[a("p",[t._v("行溢出后，MySQL 是怎么处理的？")])]),t._v(" "),a("p",[t._v("如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。")]),t._v(" "),a("p",[t._v("Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。")]),t._v(" "),a("p",[t._v("Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。")])])}),[],!1,null,null,null);a.default=e.exports}}]);