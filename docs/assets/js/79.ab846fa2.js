(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{354:function(_,v,t){"use strict";t.r(v);var r=t(14),e=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"http详解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http详解"}},[_._v("#")]),_._v(" HTTP详解")]),_._v(" "),v("p",[_._v("https://www.xiaolincoding.com/network/2_http/http_interview.html#http-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://8.130.25.175:8080/img/image-20230614095309457.png",alt:"image-20230614095309457"}})]),_._v(" "),v("p",[v("code",[_._v("1xx")]),_._v(" 类状态码属于"),v("strong",[_._v("提示信息")]),_._v("，是协议处理中的一种中间状态，实际用到的比较少。")]),_._v(" "),v("p",[v("code",[_._v("2xx")]),_._v(" 类状态码表示服务器"),v("strong",[_._v("成功")]),_._v("处理了客户端的请求，也是我们最愿意看到的状态。")]),_._v(" "),v("ul",[v("li",[_._v("「"),v("strong",[_._v("200 OK")]),_._v("」是最常见的成功状态码，表示一切正常。如果是非 "),v("code",[_._v("HEAD")]),_._v(" 请求，服务器返回的响应头都会有 body 数据。")]),_._v(" "),v("li",[_._v("「"),v("strong",[_._v("204 No Content")]),_._v("」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。")]),_._v(" "),v("li",[_._v("「"),v("strong",[_._v("206 Partial Content")]),_._v("」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。")])]),_._v(" "),v("p",[v("code",[_._v("3xx")]),_._v(" 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是"),v("strong",[_._v("重定向")]),_._v("。")]),_._v(" "),v("ul",[v("li",[_._v("「"),v("strong",[_._v("301 Moved Permanently")]),_._v("」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。")]),_._v(" "),v("li",[_._v("「"),v("strong",[_._v("302 Found")]),_._v("」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。")])]),_._v(" "),v("p",[_._v("301 和 302 都会在响应头里使用字段 "),v("code",[_._v("Location")]),_._v("，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。")]),_._v(" "),v("ul",[v("li",[_._v("「"),v("strong",[_._v("304 Not Modified")]),_._v("」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。")])]),_._v(" "),v("p",[v("code",[_._v("4xx")]),_._v(" 类状态码表示客户端发送的"),v("strong",[_._v("报文有误")]),_._v("，服务器无法处理，也就是错误码的含义。")]),_._v(" "),v("ul",[v("li",[_._v("「"),v("strong",[_._v("400 Bad Request")]),_._v("」表示客户端请求的报文有错误，但只是个笼统的错误。")]),_._v(" "),v("li",[_._v("「"),v("strong",[_._v("403 Forbidden")]),_._v("」表示服务器禁止访问资源，并不是客户端的请求出错。")]),_._v(" "),v("li",[_._v("「"),v("strong",[_._v("404 Not Found")]),_._v("」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。")])]),_._v(" "),v("p",[v("code",[_._v("5xx")]),_._v(" 类状态码表示客户端请求报文正确，但是"),v("strong",[_._v("服务器处理时内部发生了错误")]),_._v("，属于服务器端的错误码。")]),_._v(" "),v("ul",[v("li",[_._v("「"),v("strong",[_._v("500 Internal Server Error")]),_._v("」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。")]),_._v(" "),v("li",[_._v("「"),v("strong",[_._v("501 Not Implemented")]),_._v("」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。")]),_._v(" "),v("li",[_._v("「"),v("strong",[_._v("502 Bad Gateway")]),_._v("」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。")]),_._v(" "),v("li",[_._v("「"),v("strong",[_._v("503 Service Unavailable")]),_._v("」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。")])]),_._v(" "),v("h3",{attrs:{id:"get-和-post-方法都是安全和幂等的吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-方法都是安全和幂等的吗"}},[_._v("#")]),_._v(" GET 和 POST 方法都是安全和幂等的吗？")]),_._v(" "),v("p",[_._v("先说明下安全和幂等的概念：")]),_._v(" "),v("ul",[v("li",[_._v("在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。")]),_._v(" "),v("li",[_._v("所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。")])]),_._v(" "),v("p",[_._v("如果从 RFC 规范定义的语义来看：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("GET 方法就是安全且幂等的")]),_._v("，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，"),v("strong",[_._v("可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("POST")]),_._v(" 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是"),v("strong",[_._v("不安全")]),_._v("的，且多次提交数据就会创建多个资源，所以"),v("strong",[_._v("不是幂等")]),_._v("的。所以，"),v("strong",[_._v("浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签")]),_._v("。")])]),_._v(" "),v("p",[_._v("做个简要的小结。")]),_._v(" "),v("p",[_._v("GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。")]),_._v(" "),v("p",[_._v("POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。")]),_._v(" "),v("p",[_._v("注意， 上面是从 RFC 规范定义的语义来分析的。")]),_._v(" "),v("p",[_._v("但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：")]),_._v(" "),v("ul",[v("li",[_._v("可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。")]),_._v(" "),v("li",[_._v("可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。")])]),_._v(" "),v("p",[_._v("如果「安全」放入概念是指信息是否会被泄漏的话，虽然 POST 用 body 传输数据，而 GET 用 URL 传输，这样数据会在浏览器地址拦容易看到，但是并不能说 GET 不如 POST 安全的。")]),_._v(" "),v("p",[_._v("因为 HTTP 传输的内容都是明文的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。")]),_._v(" "),v("p",[_._v("所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。")]),_._v(" "),v("p",[_._v("RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。")]),_._v(" "),v("p",[_._v("另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。")]),_._v(" "),v("h2",{attrs:{id:"http-缓存技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存技术"}},[_._v("#")]),_._v(" HTTP 缓存技术")]),_._v(" "),v("h3",{attrs:{id:"http-缓存有哪些实现方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存有哪些实现方式"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/network/2_http/http_interview.html#http-%E7%BC%93%E5%AD%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("HTTP 缓存有哪些实现方式？")]),_._v(" "),v("p",[_._v("对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都"),v("strong",[_._v("缓存在本地")]),_._v("，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。")]),_._v(" "),v("p",[_._v("所以，避免发送 HTTP 请求的方法就是通过"),v("strong",[_._v("缓存技术")]),_._v("，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。")]),_._v(" "),v("p",[_._v("HTTP 缓存有两种实现方式，分别是"),v("strong",[_._v("强制缓存和协商缓存")]),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"什么是强制缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是强制缓存"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("什么是强制缓存？")]),_._v(" "),v("p",[_._v("强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。")]),_._v(" "),v("p",[_._v("如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/1cb6bc37597e4af8adfef412bfc57a42.png",alt:"img"}})]),_._v(" "),v("p",[_._v("强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("Cache-Control")]),_._v("， 是一个相对时间；")]),_._v(" "),v("li",[v("code",[_._v("Expires")]),_._v("，是一个绝对时间；")])]),_._v(" "),v("p",[_._v("如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，"),v("strong",[_._v("Cache-Control 的优先级高于 Expires")]),_._v(" 。")]),_._v(" "),v("p",[_._v("Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：")]),_._v(" "),v("ul",[v("li",[_._v("当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；")]),_._v(" "),v("li",[_._v("浏览器再次请求访问服务器中的该资源时，会先"),v("strong",[_._v("通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期")]),_._v("，如果没有，则使用该缓存，否则重新请求服务器；")]),_._v(" "),v("li",[_._v("服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。")])]),_._v(" "),v("h3",{attrs:{id:"什么是协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是协商缓存"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("什么是协商缓存？")]),_._v(" "),v("p",[_._v("当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 "),v("code",[_._v("304")]),_._v("，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png",alt:"img"}})]),_._v(" "),v("p",[_._v("上图就是一个协商缓存的过程，所以"),v("strong",[_._v("协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存")]),_._v("。")]),_._v(" "),v("p",[_._v("协商缓存可以基于两种头部来实现。")]),_._v(" "),v("p",[_._v("第一种：请求头部中的 "),v("code",[_._v("If-Modified-Since")]),_._v(" 字段与响应头部中的 "),v("code",[_._v("Last-Modified")]),_._v(" 字段实现，这两个字段的意思是：")]),_._v(" "),v("ul",[v("li",[_._v("响应头部中的 "),v("code",[_._v("Last-Modified")]),_._v("：标示这个响应资源的最后修改时间；")]),_._v(" "),v("li",[_._v("请求头部中的 "),v("code",[_._v("If-Modified-Since")]),_._v("：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。")])]),_._v(" "),v("p",[_._v("第二种：请求头部中的 "),v("code",[_._v("If-None-Match")]),_._v(" 字段与响应头部中的 "),v("code",[_._v("ETag")]),_._v(" 字段，这两个字段的意思是：")]),_._v(" "),v("ul",[v("li",[_._v("响应头部中 "),v("code",[_._v("Etag")]),_._v("：唯一标识响应资源；")]),_._v(" "),v("li",[_._v("请求头部中的 "),v("code",[_._v("If-None-Match")]),_._v("：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。")])]),_._v(" "),v("p",[_._v("第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。")]),_._v(" "),v("p",[_._v("如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，"),v("strong",[_._v("这时 Etag 的优先级更高")]),_._v("，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。")]),_._v(" "),v("p",[_._v("**为什么 ETag 的优先级更高？**这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：")]),_._v(" "),v("ol",[v("li",[_._v("在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；")]),_._v(" "),v("li",[_._v("可能有些文件是在秒级以内修改的，"),v("code",[_._v("If-Modified-Since")]),_._v(" 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；")]),_._v(" "),v("li",[_._v("有些服务器不能精确获取文件的最后修改时间。")])]),_._v(" "),v("p",[_._v("注意，"),v("strong",[_._v("协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求")]),_._v("。")]),_._v(" "),v("p",[_._v("下图是强制缓存和协商缓存的工作流程：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png",alt:"img"}})]),_._v(" "),v("p",[_._v("当使用 ETag 字段实现的协商缓存的过程：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；")])]),_._v(" "),v("li",[v("p",[_._v("当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：")]),_._v(" "),v("ul",[v("li",[_._v("如果没有过期，则直接使用本地缓存；")]),_._v(" "),v("li",[_._v("如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；")])])]),_._v(" "),v("li",[v("p",[_._v("服务器再次收到请求后，")]),_._v(" "),v("p",[_._v("会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较")]),_._v(" "),v("p",[_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("如果值相等，则返回 304 Not Modified，不会返回资源")]),_._v("；")]),_._v(" "),v("li",[_._v("如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；")])])]),_._v(" "),v("li",[v("p",[_._v("如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。")])])]),_._v(" "),v("h2",{attrs:{id:""}},[v("a",{staticClass:"header-anchor",attrs:{href:"#"}},[_._v("#")])]),_._v(" "),v("h2",{attrs:{id:"http协议-http1-1-http2-0-http3-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http协议-http1-1-http2-0-http3-0"}},[_._v("#")]),_._v(" HTTP协议(HTTP1.1\\HTTP2.0\\HTTP3.0)")]),_._v(" "),v("p",[_._v("https://www.xiaolincoding.com/network/2_http/http_interview.html#http-1-1-%E7%9A%84%E4%BC%98%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B")]),_._v(" "),v("ul",[v("li",[_._v("HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层；")]),_._v(" "),v("li",[_._v("HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议。")])]),_._v(" "),v("h2",{attrs:{id:"http和https的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http和https的关系"}},[_._v("#")]),_._v(" HTTP和HTTPS的关系")]),_._v(" "),v("p",[_._v("https://www.xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https")]),_._v(" "),v("h3",{attrs:{id:"http-与-https-有哪些区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-与-https-有哪些区别"}},[_._v("#")]),_._v(" HTTP 与 HTTPS 有哪些区别？")]),_._v(" "),v("ul",[v("li",[_._v("HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。")]),_._v(" "),v("li",[_._v("HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。")]),_._v(" "),v("li",[_._v("两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。")]),_._v(" "),v("li",[_._v("HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。")])]),_._v(" "),v("h3",{attrs:{id:"https-解决了-http-的哪些问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-解决了-http-的哪些问题"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/network/2_http/http_interview.html#https-%E8%A7%A3%E5%86%B3%E4%BA%86-http-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("HTTPS 解决了 HTTP 的哪些问题？")]),_._v(" "),v("p",[_._v("HTTP 由于是明文传输，所以安全上存在以下三个风险：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("窃听风险")]),_._v("，比如通信链路上可以获取通信内容，用户号容易没。")]),_._v(" "),v("li",[v("strong",[_._v("篡改风险")]),_._v("，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。")]),_._v(" "),v("li",[v("strong",[_._v("冒充风险")]),_._v("，比如冒充淘宝网站，用户钱容易没。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png",alt:"HTTP 与 HTTPS 网络层"}})]),_._v(" "),v("p",[_._v("HTTP"),v("strong",[_._v("S")]),_._v(" 在 HTTP 与 TCP 层之间加入了 "),v("code",[_._v("SSL/TLS")]),_._v(" 协议，可以很好的解决了上述的风险：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("信息加密")]),_._v("：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。")]),_._v(" "),v("li",[v("strong",[_._v("校验机制")]),_._v("：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。")]),_._v(" "),v("li",[v("strong",[_._v("身份证书")]),_._v("：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。")])]),_._v(" "),v("p",[_._v("可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。")]),_._v(" "),v("blockquote",[v("p",[_._v("HTTPS 是如何解决上面的三个风险的？")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("混合加密")]),_._v("的方式实现信息的"),v("strong",[_._v("机密性")]),_._v("，解决了窃听的风险。")]),_._v(" "),v("li",[v("strong",[_._v("摘要算法")]),_._v("的方式来实现"),v("strong",[_._v("完整性")]),_._v("，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。")]),_._v(" "),v("li",[_._v("将服务器公钥放入到"),v("strong",[_._v("数字证书")]),_._v("中，解决了冒充的风险。")])]),_._v(" "),v("p",[v("em",[_._v("1. 混合加密")])]),_._v(" "),v("p",[_._v("通过"),v("strong",[_._v("混合加密")]),_._v("的方式可以保证信息的"),v("strong",[_._v("机密性")]),_._v("，解决了窃听的风险。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/20-%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png",alt:"混合加密"}})]),_._v(" "),v("p",[_._v("HTTPS 采用的是"),v("strong",[_._v("对称加密")]),_._v("和"),v("strong",[_._v("非对称加密")]),_._v("结合的「混合加密」方式：")]),_._v(" "),v("ul",[v("li",[_._v("在通信建立前采用"),v("strong",[_._v("非对称加密")]),_._v("的方式交换「会话秘钥」，后续就不再使用非对称加密。")]),_._v(" "),v("li",[_._v("在通信过程中全部使用"),v("strong",[_._v("对称加密")]),_._v("的「会话秘钥」的方式加密明文数据。")])]),_._v(" "),v("p",[_._v("采用「混合加密」的方式的原因：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("对称加密")]),_._v("只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。")]),_._v(" "),v("li",[v("strong",[_._v("非对称加密")]),_._v("使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。")])]),_._v(" "),v("p",[v("em",[_._v("2. 摘要算法 + 数字签名")])]),_._v(" "),v("p",[_._v("为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。")]),_._v(" "),v("p",[_._v("对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。")]),_._v(" "),v("p",[_._v("那么，在计算机里会"),v("strong",[_._v("用摘要算法（哈希函数）来计算出内容的哈希值")]),_._v("，也就是内容的「指纹」，这个"),v("strong",[_._v("哈希值是唯一的，且无法通过哈希值推导出内容")]),_._v("。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png",alt:"img"}})]),_._v(" "),v("p",[_._v("通过哈希算法可以确保内容不会被篡改，"),v("strong",[_._v("但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明")]),_._v("。")]),_._v(" "),v("p",[_._v("举个例子，你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假。")]),_._v(" "),v("p",[_._v("但是你有模仿你爸爸字迹的能力，你用你爸爸的字迹写了一份请假理由然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是你爸爸写的，就会允许你请假。")]),_._v(" "),v("p",[_._v("那作为老师，要如何避免这种情况发生呢？现实生活中的，可以通过电话或视频来确认是否是由父母发出的请假，但是计算机里可没有这种操作。")]),_._v(" "),v("p",[_._v("那为了避免这种情况，计算机里会用"),v("strong",[_._v("非对称加密算法")]),_._v("来解决，共有两个密钥：")]),_._v(" "),v("ul",[v("li",[_._v("一个是公钥，这个是可以公开给所有人的；")]),_._v(" "),v("li",[_._v("一个是私钥，这个必须由本人管理，不可泄露。")])]),_._v(" "),v("p",[_._v("这两个密钥可以"),v("strong",[_._v("双向加解密")]),_._v("的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。")]),_._v(" "),v("p",[_._v("流程的不同，意味着目的也不相同：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；")])]),_._v(" "),v("li",[v("strong",[_._v("私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。")])])]),_._v(" "),v("p",[_._v("一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。")]),_._v(" "),v("p",[_._v("所以非对称加密的用途主要在于"),v("strong",[_._v("通过「私钥加密，公钥解密」的方式，来确认消息的身份")]),_._v("，我们常说的"),v("strong",[_._v("数字签名算法")]),_._v("，就是用的是这种方式，不过私钥加密内容不是内容本身，而是"),v("strong",[_._v("对内容的哈希值加密")]),_._v("。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png",alt:"img"}})]),_._v(" "),v("p",[_._v("私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。")]),_._v(" "),v("p",[_._v("引入了数字签名算法后，你就无法模仿你爸爸的字迹来请假了，你爸爸手上持有着私钥，你老师持有着公钥。")]),_._v(" "),v("p",[_._v("这样只有用你爸爸手上的私钥才对请假条进行「签名」，老师通过公钥看能不能解出这个「签名」，如果能解出并且确认内容的完整性，就能证明是由你爸爸发起的请假条，这样老师才允许你请假，否则老师就不认。")]),_._v(" "),v("p",[v("em",[_._v("3. 数字证书")])]),_._v(" "),v("p",[_._v("前面我们知道：")]),_._v(" "),v("ul",[v("li",[_._v("可以通过哈希算法来保证消息的完整性；")]),_._v(" "),v("li",[_._v("可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；")])]),_._v(" "),v("p",[_._v("但是这还远远不够，"),v("strong",[_._v("还缺少身份验证的环节")]),_._v("，万一公钥是被伪造的呢？")]),_._v(" "),v("p",[_._v("还是拿请假的例子，虽然你爸爸持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。")]),_._v(" "),v("p",[_._v("但是我们还可以自己伪造出一对公私钥啊！")]),_._v(" "),v("p",[_._v("你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了「数字签名」。")]),_._v(" "),v("p",[_._v("但是老师并不知道自己的公钥被你替换过了，所以他还是按照往常一样用公钥解密，由于这个公钥和你的私钥是配对的，老师当然能用这个被替换的公钥解密出来，并且确认了内容的完整性，于是老师就会以为是你父亲写的请假条，又允许你请假了。")]),_._v(" "),v("p",[_._v("好家伙，为了一个请假，真的是斗智斗勇。")]),_._v(" "),v("p",[_._v("后面你的老师和父亲发现了你伪造公私钥的事情后，决定重新商量一个对策来应对你这个臭家伙。")]),_._v(" "),v("p",[_._v("正所谓魔高一丈，道高一尺。")]),_._v(" "),v("p",[_._v("既然伪造公私钥那么随意，所以你爸把他的公钥注册到"),v("strong",[_._v("警察局")]),_._v("，警察局用他们自己的私钥对你父亲的公钥做了个数字签名，然后把你爸爸的「个人信息 + 公钥 + 数字签名」打包成一个"),v("strong",[_._v("数字证书，也就是说这个数字证书包含你爸爸的公钥。")])]),_._v(" "),v("p",[_._v("这样，你爸爸如果因为家里确实有事要向老师帮你请假的时候，不仅会用自己的私钥对内容进行签名，还会把数字证书给到老师。")]),_._v(" "),v("p",[_._v("老师拿到了数字证书后，"),v("strong",[_._v("首先会去警察局验证这个数字证书是否合法")]),_._v("，因为数字证书里有警察局的数字签名，警察局要验证证书合法性的时候，用自己的公钥解密，如果能解密成功，就说明这个数字证书是在警察局注册过的，就认为该数字证书是合法的，然后就会把数字证书里头的公钥（你爸爸的）给到老师。")]),_._v(" "),v("p",[v("strong",[_._v("由于通过警察局验证了数字证书是合法的，那么就能证明这个公钥就是你父亲的")]),_._v("，于是老师就可以安心的用这个公钥解密出请假条，如果能解密出，就证明是你爸爸写的请假条。")]),_._v(" "),v("p",[_._v("正是通过了一个权威的机构来证明你爸爸的身份，所以你的伪造公私钥这个小伎俩就没用了。")]),_._v(" "),v("p",[_._v("在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。")]),_._v(" "),v("p",[_._v("数字证书的工作流程，我也画了一张图，方便大家理解：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png",alt:"数子证书工作流程"}})]),_._v(" "),v("p",[_._v("通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。")]),_._v(" "),v("h3",{attrs:{id:"-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[_._v("#")])]),_._v(" "),v("h3",{attrs:{id:"https-是如何建立连接的-其间交互了什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-是如何建立连接的-其间交互了什么"}},[_._v("#")]),_._v(" HTTPS 是如何建立连接的？其间交互了什么？")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png",alt:"19-HTTPS与HTTP"}})]),_._v(" "),v("p",[_._v("SSL/TLS 协议基本流程：")]),_._v(" "),v("ul",[v("li",[_._v("客户端向服务器索要并验证服务器的公钥。")]),_._v(" "),v("li",[_._v("双方协商生产「会话秘钥」。")]),_._v(" "),v("li",[_._v("双方采用「会话秘钥」进行加密通信。")])]),_._v(" "),v("p",[_._v("前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。")]),_._v(" "),v("p",[_._v("TLS 的「握手阶段」涉及"),v("strong",[_._v("四次")]),_._v("通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种："),v("a",{attrs:{href:"https://xiaolincoding.com/network/2_http/https_rsa.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("RSA 算法 (opens new window)"),v("OutboundLink")],1),_._v("和 "),v("a",{attrs:{href:"https://xiaolincoding.com/network/2_http/https_ecdhe.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("ECDHE 算法 (opens new window)"),v("OutboundLink")],1),_._v("。")]),_._v(" "),v("p",[_._v("基于 RSA 算法的 TLS 握手过程比较容易理解，所以这里先用这个给大家展示 TLS 握手过程，如下图：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png",alt:"HTTPS 连接建立过程"}})]),_._v(" "),v("p",[_._v("TLS 协议建立的详细流程："),v("strong",[_._v("安全传输层"),v("em",[_._v("协议")]),_._v("（Transport Layer Security）用于在两个通信应用程序之间提供保密性和数据完整性。该"),v("em",[_._v("协议")]),_._v("由两层组成： "),v("em",[_._v("TLS")]),_._v(" 记录"),v("em",[_._v("协议")]),_._v("（"),v("em",[_._v("TLS")]),_._v(" Record）和 "),v("em",[_._v("TLS")]),_._v(" 握手"),v("em",[_._v("协议")]),_._v("（"),v("em",[_._v("TLS")]),_._v(" Handshake）")])]),_._v(" "),v("p",[v("em",[_._v("1. ClientHello")])]),_._v(" "),v("p",[_._v("首先，由客户端向服务器发起加密通信请求，也就是 "),v("code",[_._v("ClientHello")]),_._v(" 请求。")]),_._v(" "),v("p",[_._v("在这一步，客户端主要向服务器发送以下信息：")]),_._v(" "),v("p",[_._v("（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。")]),_._v(" "),v("p",[_._v("（2）客户端生产的随机数（"),v("code",[_._v("Client Random")]),_._v("），后面用于生成「会话秘钥」条件之一。")]),_._v(" "),v("p",[_._v("（3）客户端支持的密码套件列表，如 RSA 加密算法。")]),_._v(" "),v("p",[v("em",[_._v("2. SeverHello")])]),_._v(" "),v("p",[_._v("服务器收到客户端请求后，向客户端发出响应，也就是 "),v("code",[_._v("SeverHello")]),_._v("。服务器回应的内容有如下内容：")]),_._v(" "),v("p",[_._v("（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。")]),_._v(" "),v("p",[_._v("（2）服务器生产的随机数（"),v("code",[_._v("Server Random")]),_._v("），也是后面用于生产「会话秘钥」条件之一。")]),_._v(" "),v("p",[_._v("（3）确认的密码套件列表，如 RSA 加密算法。")]),_._v(" "),v("p",[_._v("（4）服务器的数字证书。")]),_._v(" "),v("p",[v("em",[_._v("3.客户端回应")])]),_._v(" "),v("p",[_._v("客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。")]),_._v(" "),v("p",[_._v("如果证书没有问题，客户端会"),v("strong",[_._v("从数字证书中取出服务器的公钥")]),_._v("，然后使用它加密报文，向服务器发送如下信息：")]),_._v(" "),v("p",[_._v("（1）一个随机数（"),v("code",[_._v("pre-master key")]),_._v("）。该随机数会被服务器公钥加密。")]),_._v(" "),v("p",[_._v("（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")]),_._v(" "),v("p",[_._v("（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。")]),_._v(" "),v("p",[_._v("上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。")]),_._v(" "),v("p",[v("strong",[_._v("服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」")]),_._v("。")]),_._v(" "),v("p",[v("em",[_._v("4. 服务器的最后回应")])]),_._v(" "),v("p",[_._v("服务器收到客户端的第三个随机数（"),v("code",[_._v("pre-master key")]),_._v("）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。")]),_._v(" "),v("p",[_._v("然后，向客户端发送最后的信息：")]),_._v(" "),v("p",[_._v("（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")]),_._v(" "),v("p",[_._v("（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。")]),_._v(" "),v("p",[_._v("至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。")]),_._v(" "),v("p",[_._v("HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。")]),_._v(" "),v("h2",{attrs:{id:"rsa-握手过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rsa-握手过程"}},[_._v("#")]),_._v(" RSA 握手过程")]),_._v(" "),v("p",[_._v("传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。")]),_._v(" "),v("p",[_._v("在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。")]),_._v(" "),v("p",[_._v("我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历了四次握手：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/tls%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png",alt:"img"}})]),_._v(" "),v("p",[_._v("对应 Wireshark 的抓包，我也画了一幅图，你可以从下图很清晰地看到该过程：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/https_rsa.png",alt:"img"}})]),_._v(" "),v("p",[_._v("那么，接下来针对每一个 TLS 握手做进一步的介绍。")]),_._v(" "),v("h3",{attrs:{id:"tls-第一次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tls-第一次握手"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("TLS 第一次握手")]),_._v(" "),v("p",[_._v("客户端首先会发一个「"),v("strong",[_._v("Client Hello")]),_._v("」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/clienthello.png",alt:"img"}})]),_._v(" "),v("p",[_._v("消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的"),v("strong",[_._v("随机数（*Client Random*）")]),_._v("，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。")]),_._v(" "),v("h3",{attrs:{id:"tls-第二次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tls-第二次握手"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("TLS 第二次握手")]),_._v(" "),v("p",[_._v("当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成"),v("strong",[_._v("随机数（*Server Random*）")]),_._v("。")]),_._v(" "),v("p",[_._v("接着，返回「"),v("strong",[_._v("Server Hello")]),_._v("」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/serverhello.png",alt:"img"}})]),_._v(" "),v("p",[_._v("可以看到，服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。")]),_._v(" "),v("p",[_._v("这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「"),v("strong",[_._v("密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法")]),_._v("」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：")]),_._v(" "),v("ul",[v("li",[_._v("由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；")]),_._v(" "),v("li",[_._v("握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；")]),_._v(" "),v("li",[_._v("摘要算法 SHA256 用于消息认证和产生随机数；")])]),_._v(" "),v("p",[_._v("就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。")]),_._v(" "),v("p",[_._v("那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。")]),_._v(" "),v("p",[_._v("然后，服务端为了证明自己的身份，会发送「"),v("strong",[_._v("Server Certificate")]),_._v("」给客户端，这个消息里含有数字证书。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/certificate.png",alt:"img"}})]),_._v(" "),v("p",[_._v("随后，服务端发了「"),v("strong",[_._v("Server Hello Done")]),_._v("」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/serverhellodone.png",alt:"img"}})]),_._v(" "),v("h3",{attrs:{id:"客户端验证证书"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#客户端验证证书"}},[_._v("#")]),_._v(" 客户端验证证书")]),_._v(" "),v("p",[_._v("在这里刹个车，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？")]),_._v(" "),v("h4",{attrs:{id:"数字证书和-ca-机构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数字证书和-ca-机构"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://xiaolincoding.com/network/2_http/https_rsa.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%92%8C-ca-%E6%9C%BA%E6%9E%84",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("数字证书和 CA 机构")]),_._v(" "),v("p",[_._v("在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，一个数字证书通常包含了：")]),_._v(" "),v("ul",[v("li",[_._v("公钥；")]),_._v(" "),v("li",[_._v("持有者信息；")]),_._v(" "),v("li",[_._v("证书认证机构（CA）的信息；")]),_._v(" "),v("li",[_._v("CA 对这份文件的数字签名及使用的算法；")]),_._v(" "),v("li",[_._v("证书有效期；")]),_._v(" "),v("li",[_._v("还有一些其他额外信息；")])]),_._v(" "),v("p",[_._v("那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。")]),_._v(" "),v("p",[_._v("我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？")]),_._v(" "),v("p",[_._v("为了让服务端的公钥被大家信任，服务端的证书都是由 CA （"),v("em",[_._v("Certificate Authority")]),_._v("，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。")]),_._v(" "),v("p",[_._v("之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。")]),_._v(" "),v("h4",{attrs:{id:"数字证书签发和验证流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数字证书签发和验证流程"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://xiaolincoding.com/network/2_http/https_rsa.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E5%92%8C%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("数字证书签发和验证流程")]),_._v(" "),v("p",[_._v("如下图图所示，为数字证书签发和验证流程：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png",alt:"img"}})]),_._v(" "),v("p",[_._v("CA 签发证书的过程，如上图左边部分：")]),_._v(" "),v("ul",[v("li",[_._v("首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；")]),_._v(" "),v("li",[_._v("然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；")]),_._v(" "),v("li",[_._v("最后将 Certificate Signature 添加在文件证书上，形成数字证书；")])]),_._v(" "),v("p",[_._v("客户端校验服务端的数字证书的过程，如上图右边部分：")]),_._v(" "),v("ul",[v("li",[_._v("首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；")]),_._v(" "),v("li",[_._v("通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；")]),_._v(" "),v("li",[_._v("最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。")])]),_._v(" "),v("h4",{attrs:{id:"-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#-3"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://xiaolincoding.com/network/2_http/https_rsa.html#%E8%AF%81%E4%B9%A6%E9%93%BE",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1)]),_._v(" "),v("h3",{attrs:{id:"tls-第三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tls-第三次握手"}},[_._v("#")]),_._v(" TLS 第三次握手")]),_._v(" "),v("p",[_._v("客户端验证完证书后，认为可信则继续往下走。")]),_._v(" "),v("p",[_._v("接着，客户端就会生成一个新的"),v("strong",[_._v("随机数 (*pre-master*)")]),_._v("，用服务器的 RSA 公钥加密该随机数，通过「"),v("strong",[_._v("Client Key Exchange")]),_._v("」消息传给服务端。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/clietnkeyexchange.png",alt:"img"}})]),_._v(" "),v("p",[_._v("服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。")]),_._v(" "),v("p",[_._v("至此，"),v("strong",[_._v("客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master")]),_._v("。")]),_._v(" "),v("p",[_._v("于是，双方根据已经得到的三个随机数，生成"),v("strong",[_._v("会话密钥（Master Secret）")]),_._v("，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。")]),_._v(" "),v("p",[_._v("生成完「会话密钥」后，然后客户端发一个「"),v("strong",[_._v("Change Cipher Spec")]),_._v("」，告诉服务端开始使用加密方式发送消息。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/cipherspecmessage.png",alt:"img"}})]),_._v(" "),v("p",[_._v("然后，客户端再发一个「"),v("strong",[_._v("Encrypted Handshake Message（Finishd）")]),_._v("」消息，把之前所有发送的数据做个"),v("strong",[_._v("摘要")]),_._v("，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/encryptd.png",alt:"img"}})]),_._v(" "),v("p",[_._v("可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。")]),_._v(" "),v("h3",{attrs:{id:"tls-第四次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tls-第四次握手"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("TLS 第四次握手")]),_._v(" "),v("p",[_._v("服务器也是同样的操作，发「"),v("strong",[_._v("Change Cipher Spec")]),_._v("」和「"),v("strong",[_._v("Encrypted Handshake Message")]),_._v("」消息，如果双方都验证加密和解密没问题，那么握手正式完成。")]),_._v(" "),v("p",[_._v("最后，就用「会话密钥」加解密 HTTP 请求和响应了。")]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"rsa-算法的缺陷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rsa-算法的缺陷"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://xiaolincoding.com/network/2_http/https_rsa.html#rsa-%E7%AE%97%E6%B3%95%E7%9A%84%E7%BC%BA%E9%99%B7",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("RSA 算法的缺陷")]),_._v(" "),v("p",[v("strong",[_._v("使用 RSA 密钥协商算法的最大问题是不支持前向保密")]),_._v("。")]),_._v(" "),v("p",[_._v("因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。")]),_._v(" "),v("p",[_._v("为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法，关于 ECDHE 握手的过程，将在下一篇揭晓。")])])}),[],!1,null,null,null);v.default=e.exports}}]);