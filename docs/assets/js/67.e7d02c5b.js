(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{341:function(v,_,e){"use strict";e.r(_);var s=e(14),t=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"aof-持久化是怎么实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof-持久化是怎么实现的"}},[v._v("#")]),v._v(" AOF 持久化是怎么实现的？")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/40ddab878c91fb6bb0f92789196bfc67.png",alt:"img"}})]),v._v(" "),_("h2",{attrs:{id:"aof-日志"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof-日志"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/aof.html#aof-%E6%97%A5%E5%BF%97",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("AOF 日志")]),v._v(" "),_("p",[v._v("试想一下，如果 Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，然后重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，这不就相当于恢复了缓存数据了吗？")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/6f0ab40396b7fc2c15e6f4487d3a0ad7.png",alt:"img"}})]),v._v(" "),_("p",[v._v("这种保存写操作命令到日志的持久化方式，就是 Redis 里的 "),_("strong",[v._v("AOF(*Append Only File*)")]),v._v(" 持久化功能，"),_("strong",[v._v("注意只会记录写操作命令，读操作命令是不会被记录的")]),v._v("，因为没意义。")]),v._v(" "),_("p",[v._v("在 Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 "),_("code",[v._v("redis.conf")]),v._v(" 配置文件中的以下参数：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/0e2d081af084c41802c7b5de8aa41bd4.png",alt:"img"}})]),v._v(" "),_("p",[v._v("AOF 日志文件其实就是普通的文本，我们可以通过 "),_("code",[v._v("cat")]),v._v(" 命令查看里面的内容，不过里面的内容如果不知道一定的规则的话，可能会看不懂。")]),v._v(" "),_("p",[v._v("我这里以「"),_("em",[v._v("set name xiaolin")]),v._v("」命令作为例子，Redis 执行了这条命令后，记录在 AOF 日志里的内容如下图：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/337021a153944fd0f964ca834e34d0f2.png",alt:"img"}})]),v._v(" "),_("p",[v._v("我这里给大家解释下。")]),v._v(" "),_("p",[v._v("「"),_("code",[v._v("*3")]),v._v("」表示当前命令有三个部分，每部分都是以「"),_("code",[v._v("$+数字")]),v._v("」开头，后面紧跟着具体的命令、键或值。然后，这里的「"),_("code",[v._v("数字")]),v._v("」表示这部分中的命令、键或值一共有多少字节。例如，「"),_("code",[v._v("$3 set")]),v._v("」表示这部分有 3 个字节，也就是「"),_("code",[v._v("set")]),v._v("」命令这个字符串的长度。")]),v._v(" "),_("p",[v._v("不知道大家注意到没有，Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。")]),v._v(" "),_("p",[v._v("第一个好处，"),_("strong",[v._v("避免额外的检查开销。")])]),v._v(" "),_("p",[v._v("因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。")]),v._v(" "),_("p",[v._v("而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，保证记录在 AOF 日志里的命令都是可执行并且正确的。")]),v._v(" "),_("p",[v._v("第二个好处，"),_("strong",[v._v("不会阻塞当前写操作命令的执行")]),v._v("，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。")]),v._v(" "),_("p",[v._v("当然，AOF 持久化功能也不是没有潜在风险。")]),v._v(" "),_("p",[v._v("第一个风险，执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有"),_("strong",[v._v("丢失的风险")]),v._v("。")]),v._v(" "),_("p",[v._v("第二个风险，前面说道，由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是"),_("strong",[v._v("可能会给「下一个」命令带来阻塞风险")]),v._v("。")]),v._v(" "),_("p",[v._v("因为将命令写入到日志的这个操作也是在主进程完成的（执行命令也是在主进程），也就是说这两个操作是同步的。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/28afd536c57a46447ddab0a2062abe84.png",alt:"img"}})]),v._v(" "),_("p",[v._v("如果在将日志内容写入到硬盘时，服务器的硬盘的 I/O 压力太大，就会导致写硬盘的速度很慢，进而阻塞住了，也就会导致后续的命令无法执行。")]),v._v(" "),_("p",[v._v("认真分析一下，其实这两个风险都有一个共性，都跟「 AOF 日志写回硬盘的时机」有关。")]),v._v(" "),_("h2",{attrs:{id:"三种写回策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三种写回策略"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/aof.html#%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("三种写回策略")]),v._v(" "),_("p",[v._v("Redis 写入 AOF 日志的过程，如下图：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png",alt:"img"}})]),v._v(" "),_("p",[v._v("我先来具体说说：")]),v._v(" "),_("ol",[_("li",[v._v("Redis 执行完写操作命令后，会将命令追加到 "),_("code",[v._v("server.aof_buf")]),v._v(" 缓冲区；")]),v._v(" "),_("li",[v._v("然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；")]),v._v(" "),_("li",[v._v("具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。")])]),v._v(" "),_("p",[v._v("Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。")]),v._v(" "),_("p",[v._v("在 "),_("code",[v._v("redis.conf")]),v._v(" 配置文件中的 "),_("code",[v._v("appendfsync")]),v._v(" 配置项可以有以下 3 种参数可填：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("Always")]),v._v("，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；")]),v._v(" "),_("li",[_("strong",[v._v("Everysec")]),v._v("，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；")]),v._v(" "),_("li",[_("strong",[v._v("No")]),v._v("，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。")])]),v._v(" "),_("p",[v._v("这 3 种写回策略都无法能完美解决「主进程阻塞」和「减少数据丢失」的问题，因为两个问题是对立的，偏向于一边的话，就会要牺牲另外一边，原因如下：")]),v._v(" "),_("ul",[_("li",[v._v("Always 策略的话，可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以是不可避免会影响主进程的性能；")]),v._v(" "),_("li",[v._v("No 策略的话，是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。")]),v._v(" "),_("li",[v._v("Everysec 策略的话，是折中的一种方式，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。")])]),v._v(" "),_("p",[v._v("大家根据自己的业务场景进行选择：")]),v._v(" "),_("ul",[_("li",[v._v("如果要高性能，就选择 No 策略；")]),v._v(" "),_("li",[v._v("如果要高可靠，就选择 Always 策略；")]),v._v(" "),_("li",[v._v("如果允许数据丢失一点，但又想性能高，就选择 Everysec 策略。")])]),v._v(" "),_("p",[v._v("我也把这 3 个写回策略的优缺点总结成了一张表格：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a.png",alt:"img"}})]),v._v(" "),_("p",[v._v("大家知道这三种策略是怎么实现的吗？")]),v._v(" "),_("p",[v._v("深入到源码后，你就会发现这三种策略只是在控制 "),_("code",[v._v("fsync()")]),v._v(" 函数的调用时机。")]),v._v(" "),_("p",[v._v("当应用程序向文件写入数据时，内核通常先将数据复制到内核缓冲区中，然后排入队列，然后由内核决定何时写入硬盘。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/f64829ffc2e9e006b090f9aae51035ee.png",alt:"img"}})]),v._v(" "),_("p",[v._v("如果想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用 "),_("code",[v._v("fsync()")]),v._v(" 函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。")]),v._v(" "),_("ul",[_("li",[v._v("Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；")]),v._v(" "),_("li",[v._v("Everysec 策略就会创建一个异步任务来执行 fsync() 函数；")]),v._v(" "),_("li",[v._v("No 策略就是永不执行 fsync() 函数;")])]),v._v(" "),_("h2",{attrs:{id:"aof-重写机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写机制"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/aof.html#aof-%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("AOF 重写机制")]),v._v(" "),_("p",[v._v("AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。")]),v._v(" "),_("p",[v._v("如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。")]),v._v(" "),_("p",[v._v("所以，Redis 为了避免 AOF 文件越写越大，提供了 "),_("strong",[v._v("AOF 重写机制")]),v._v("，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。")]),v._v(" "),_("p",[v._v("AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。")]),v._v(" "),_("p",[v._v("举个例子，在没有使用重写机制前，假设前后执行了「"),_("em",[v._v("set name xiaolin")]),v._v("」和「"),_("em",[v._v("set name xiaolincoding")]),v._v("」这两个命令的话，就会将这两个命令记录到 AOF 文件。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/723d6c580c05400b3841bc69566dd61b.png",alt:"img"}})]),v._v(" "),_("p",[v._v("但是"),_("strong",[v._v("在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件")]),v._v("，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。")]),v._v(" "),_("p",[v._v("重写工作完成后，就会将新的 AOF 文件覆盖现有的 AOF 文件，这就相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。")]),v._v(" "),_("p",[v._v("然后，在通过 AOF 日志恢复数据时，只用执行这条命令，就可以直接完成这个键值对的写入了。")]),v._v(" "),_("p",[v._v("所以，重写机制的妙处在于，尽管某个键值对被多条写命令反复修改，"),_("strong",[v._v("最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对")]),v._v("，代替之前记录这个键值对的多条命令，这样就减少了 AOF 文件中的命令数量。最后在重写工作完成后，将新的 AOF 文件覆盖现有的 AOF 文件。")]),v._v(" "),_("p",[v._v("这里说一下为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去。")]),v._v(" "),_("p",[v._v("因为"),_("strong",[v._v("如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染")]),v._v("，可能无法用于恢复使用。")]),v._v(" "),_("p",[v._v("所以 AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。")]),v._v(" "),_("h2",{attrs:{id:"aof-后台重写"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof-后台重写"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/aof.html#aof-%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("AOF 后台重写")]),v._v(" "),_("p",[v._v("写入 AOF 日志的操作虽然是在主进程完成的，因为它写入的内容不多，所以一般不太影响命令的操作。")]),v._v(" "),_("p",[v._v("但是在触发 AOF 重写时，比如当 AOF 文件大于 64M 时，就会对 AOF 文件进行重写，这时是需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件，重写完后，就把现在的 AOF 文件替换掉。")]),v._v(" "),_("p",[v._v("这个过程其实是很耗时的，所以重写的操作不能放在主进程里。")]),v._v(" "),_("p",[v._v("所以，Redis 的"),_("strong",[v._v("重写 AOF 过程是由后台子进程 *bgrewriteaof* 来完成的")]),v._v("，这么做可以达到两个好处：")]),v._v(" "),_("ul",[_("li",[v._v("子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；")]),v._v(" "),_("li",[v._v("子进程带有主进程的数据副本（"),_("em",[v._v("数据副本怎么产生的后面会说")]),v._v("），这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。")])]),v._v(" "),_("p",[v._v("子进程是怎么拥有主进程一样的数据副本的呢？")]),v._v(" "),_("p",[v._v("主进程在通过 "),_("code",[v._v("fork")]),v._v(" 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的「"),_("strong",[v._v("页表")]),v._v("」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/5a1f2a90b5f3821c19bea3b7a5f27fa1.png",alt:"img"}})]),v._v(" "),_("p",[v._v("这样一来，子进程就共享了父进程的物理内存数据了，这样能够"),_("strong",[v._v("节约物理内存资源")]),v._v("，页表对应的页表项的属性会标记该物理内存的权限为"),_("strong",[v._v("只读")]),v._v("。")]),v._v(" "),_("p",[v._v("不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发"),_("strong",[v._v("写保护中断")]),v._v("，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行"),_("strong",[v._v("物理内存的复制")]),v._v("，并重新设置其内存映射关系，将父子进程的内存读写权限设置为"),_("strong",[v._v("可读写")]),v._v("，最后才会对内存进行写操作，这个过程被称为「"),_("strong",[v._v("写时复制(*Copy On Write*)")]),v._v("」。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/d4cfac545377b54dd035c775603b4936.png",alt:"img"}})]),v._v(" "),_("p",[v._v("写时复制顾名思义，"),_("strong",[v._v("在发生写操作的时候，操作系统才会去复制物理内存")]),v._v("，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。")]),v._v(" "),_("p",[v._v("当然，操作系统复制父进程页表的时候，父进程也是阻塞中的，不过页表的大小相比实际的物理内存小很多，所以通常复制页表的过程是比较快的。")]),v._v(" "),_("p",[v._v("不过，如果父进程的内存数据非常大，那自然页表也会很大，这时父进程在通过 fork 创建子进程的时候，阻塞的时间也越久。")]),v._v(" "),_("p",[v._v("所以，有两个阶段会导致阻塞父进程：")]),v._v(" "),_("ul",[_("li",[v._v("创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；")]),v._v(" "),_("li",[v._v("创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；")])]),v._v(" "),_("p",[v._v("触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。")]),v._v(" "),_("p",[v._v("但是子进程重写过程中，主进程依然可以正常处理命令。")]),v._v(" "),_("p",[v._v("如果此时"),_("strong",[v._v("主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的")]),v._v("。")]),v._v(" "),_("p",[v._v("所以如果这个阶段修改的是一个 bigkey，也就是数据量比较大的 key-value 的时候，这时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。")]),v._v(" "),_("p",[v._v("还有个问题，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？")]),v._v(" "),_("p",[v._v("为了解决这种数据不一致问题，Redis 设置了一个 "),_("strong",[v._v("AOF 重写缓冲区")]),v._v("，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。")]),v._v(" "),_("p",[v._v("在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会"),_("strong",[v._v("同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」")]),v._v("。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309231944807.png",alt:"在这里插入图片描述"}})]),v._v(" "),_("p",[v._v("也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:")]),v._v(" "),_("ul",[_("li",[v._v("执行客户端发来的命令；")]),v._v(" "),_("li",[v._v("将执行后的写命令追加到 「AOF 缓冲区」；")]),v._v(" "),_("li",[v._v("将执行后的写命令追加到 「AOF 重写缓冲区」；")])]),v._v(" "),_("p",[v._v("当子进程完成 AOF 重写工作（"),_("em",[v._v("扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志")]),v._v("）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。")]),v._v(" "),_("p",[v._v("主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：")]),v._v(" "),_("ul",[_("li",[v._v("将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；")]),v._v(" "),_("li",[v._v("新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。")])]),v._v(" "),_("p",[v._v("信号函数执行完后，主进程就可以继续像往常一样处理命令了。")]),v._v(" "),_("p",[v._v("在整个 AOF 后台重写过程中，除了发生写时复制会对主进程造成阻塞，还有信号处理函数执行时也会对主进程造成阻塞，在其他时候，AOF 后台重写都不会阻塞主进程。")]),v._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/aof.html#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("总结")]),v._v(" "),_("p",[v._v("这次小林给大家介绍了 Redis 持久化技术中的 AOF 方法，这个方法是每执行一条写操作命令，就将该命令以追加的方式写入到 AOF 文件，然后在恢复时，以逐一执行命令的方式来进行数据恢复。")]),v._v(" "),_("p",[v._v("Redis 提供了三种将 AOF 日志写回硬盘的策略，分别是 Always、Everysec 和 No，这三种策略在可靠性上是从高到低，而在性能上则是从低到高。")]),v._v(" "),_("p",[v._v("随着执行的命令越多，AOF 文件的体积自然也会越来越大，为了避免日志文件过大， Redis 提供了 AOF 重写机制，它会直接扫描数据中所有的键值对数据，然后为每一个键值对生成一条写操作命令，接着将该命令写入到新的 AOF 文件，重写完成后，就替换掉现有的 AOF 日志。重写的过程是由后台子进程完成的，这样可以使得主进程可以继续正常处理命令。")]),v._v(" "),_("p",[v._v("用 AOF 日志的方式来恢复数据其实是很慢的，因为 Redis 执行命令由单线程负责的，而 AOF 日志恢复数据的方式是顺序执行日志里的每一条命令，如果 AOF 日志很大，这个「重放」的过程就会很慢了。")]),v._v(" "),_("hr"),v._v(" "),_("h4",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/aof.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("参考资料")]),v._v(" "),_("ul",[_("li",[v._v("《Redis设计与实现》")]),v._v(" "),_("li",[v._v("《Redis核心技术与实战-极客时间》")]),v._v(" "),_("li",[v._v("《Redis源码分析》")])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/3e6afdfd91db015a8155f54355e133de.png",alt:"img"}})]),v._v(" "),_("h1",{attrs:{id:"rdb-快照是怎么实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rdb-快照是怎么实现的"}},[v._v("#")]),v._v(" RDB 快照是怎么实现的？")]),v._v(" "),_("p",[v._v("大家好，我是小林哥。")]),v._v(" "),_("p",[v._v("虽说 Redis 是内存数据库，但是它为数据的持久化提供了两个技术。")]),v._v(" "),_("p",[v._v("分别是「 AOF 日志和 RDB 快照」。")]),v._v(" "),_("p",[v._v("这两种技术都会用各用一个日志文件来记录信息，但是记录的内容是不同的。")]),v._v(" "),_("ul",[_("li",[v._v("AOF 文件的内容是操作命令；")]),v._v(" "),_("li",[v._v("RDB 文件的内容是二进制数据。")])]),v._v(" "),_("p",[v._v("关于 AOF 持久化的原理我在上一篇已经介绍了，今天主要讲下 "),_("strong",[v._v("RDB 快照")]),v._v("。")]),v._v(" "),_("p",[v._v("所谓的快照，就是记录某一个瞬间东西，比如当我们给风景拍照时，那一个瞬间的画面和信息就记录到了一张照片。")]),v._v(" "),_("p",[v._v("所以，RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。")]),v._v(" "),_("p",[v._v("因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。")]),v._v(" "),_("p",[v._v("接下来，就来具体聊聊 RDB 快照 。")]),v._v(" "),_("h2",{attrs:{id:"快照怎么用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#快照怎么用"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/rdb.html#%E5%BF%AB%E7%85%A7%E6%80%8E%E4%B9%88%E7%94%A8",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("快照怎么用？")]),v._v(" "),_("p",[v._v("要熟悉一个东西，先看看怎么用是比较好的方式。")]),v._v(" "),_("p",[v._v("Redis 提供了两个命令来生成 RDB 文件，分别是 "),_("code",[v._v("save")]),v._v(" 和 "),_("code",[v._v("bgsave")]),v._v("，他们的区别就在于是否在「主线程」里执行：")]),v._v(" "),_("ul",[_("li",[v._v("执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，"),_("strong",[v._v("会阻塞主线程")]),v._v("；")]),v._v(" "),_("li",[v._v("执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以"),_("strong",[v._v("避免主线程的阻塞")]),v._v("；")])]),v._v(" "),_("p",[v._v("RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。")]),v._v(" "),_("p",[v._v("Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：")]),v._v(" "),_("div",{staticClass:"language-text extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("save 900 1\nsave 300 10\nsave 60 10000\n")])])]),_("p",[v._v("别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。")]),v._v(" "),_("p",[v._v("只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：")]),v._v(" "),_("ul",[_("li",[v._v("900 秒之内，对数据库进行了至少 1 次修改；")]),v._v(" "),_("li",[v._v("300 秒之内，对数据库进行了至少 10 次修改；")]),v._v(" "),_("li",[v._v("60 秒之内，对数据库进行了至少 10000 次修改。")])]),v._v(" "),_("p",[v._v("这里提一点，Redis 的快照是"),_("strong",[v._v("全量快照")]),v._v("，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。")]),v._v(" "),_("p",[v._v("所以可以认为，执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。")]),v._v(" "),_("p",[v._v("通常可能设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据。")]),v._v(" "),_("p",[v._v("这就是 RDB 快照的缺点，在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能，而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少。")]),v._v(" "),_("h2",{attrs:{id:"执行快照时-数据能被修改吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行快照时-数据能被修改吗"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/rdb.html#%E6%89%A7%E8%A1%8C%E5%BF%AB%E7%85%A7%E6%97%B6-%E6%95%B0%E6%8D%AE%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%97",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("执行快照时，数据能被修改吗？")]),v._v(" "),_("p",[v._v("那问题来了，执行 bgsave 过程中，由于是交给子进程来构建 RDB 文件，主线程还是可以继续工作的，此时主线程可以修改数据吗？")]),v._v(" "),_("p",[v._v("如果不可以修改数据的话，那这样性能一下就降低了很多。如果可以修改数据，又是如何做到到呢？")]),v._v(" "),_("p",[v._v("直接说结论吧，执行 bgsave 过程中，Redis 依然"),_("strong",[v._v("可以继续处理操作命令")]),v._v("的，也就是数据是能被修改的。")]),v._v(" "),_("p",[v._v("那具体如何做到到呢？关键的技术就在于"),_("strong",[v._v("写时复制技术（Copy-On-Write, COW）。")])]),v._v(" "),_("p",[v._v("执行 bgsave 命令的时候，会通过 "),_("code",[v._v("fork()")]),v._v(" 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/c34a9d1f58d602ff1fe8601f7270baa7.png",alt:"图片"}})]),v._v(" "),_("p",[v._v("只有在发生修改内存数据的情况时，物理内存才会被复制一份。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/ebd620db8a1af66fbeb8f4d4ef6adc68.png",alt:"图片"}})]),v._v(" "),_("p",[v._v("这样的目的是为了减少创建子进程时的性能损耗，从而加快创建子进程的速度，毕竟创建子进程的过程中，是会阻塞主线程的。")]),v._v(" "),_("p",[v._v("所以，创建 bgsave 子进程后，由于共享父进程的所有内存数据，于是就可以直接读取主线程（父进程）里的内存数据，并将数据写入到 RDB 文件。")]),v._v(" "),_("p",[v._v("当主线程（父进程）对这些共享的内存数据也都是只读操作，那么，主线程（父进程）和 bgsave 子进程相互不影响。")]),v._v(" "),_("p",[v._v("但是，如果主线程（父进程）要"),_("strong",[v._v("修改共享数据里的某一块数据")]),v._v("（比如键值对 "),_("code",[v._v("A")]),v._v("）时，就会发生写时复制，于是这块数据的"),_("strong",[v._v("物理内存就会被复制一份（键值对 "),_("code",[v._v("A'")]),v._v("）")]),v._v("，然后"),_("strong",[v._v("主线程在这个数据副本（键值对 "),_("code",[v._v("A'")]),v._v("）进行修改操作")]),v._v("。与此同时，"),_("strong",[v._v("bgsave 子进程可以继续把原来的数据（键值对 "),_("code",[v._v("A")]),v._v("）写入到 RDB 文件")]),v._v("。")]),v._v(" "),_("p",[v._v("就是这样，Redis 使用 bgsave 对当前内存中的所有数据做快照，这个操作是由 bgsave 子进程在后台完成的，执行时不会阻塞主线程，这就使得主线程同时可以修改数据。")]),v._v(" "),_("p",[v._v("细心的同学，肯定发现了，bgsave 快照过程中，如果主线程修改了共享数据，"),_("strong",[v._v("发生了写时复制后，RDB 快照保存的是原本的内存数据")]),v._v("，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。")]),v._v(" "),_("p",[v._v("所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。")]),v._v(" "),_("p",[v._v("如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。")]),v._v(" "),_("p",[v._v("另外，写时复制的时候会出现这么个极端的情况。")]),v._v(" "),_("p",[v._v("在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。")]),v._v(" "),_("p",[v._v("那么极端情况下，"),_("strong",[v._v("如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。")])]),v._v(" "),_("p",[v._v("所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。")]),v._v(" "),_("h2",{attrs:{id:"rdb-和-aof-合体"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rdb-和-aof-合体"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/rdb.html#rdb-%E5%92%8C-aof-%E5%90%88%E4%BD%93",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("RDB 和 AOF 合体")]),v._v(" "),_("p",[v._v("尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：")]),v._v(" "),_("ul",[_("li",[v._v("如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；")]),v._v(" "),_("li",[v._v("如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。")])]),v._v(" "),_("p",[v._v("那有没有什么方法不仅有 RDB 恢复速度快的优点和，又有 AOF 丢失数据少的优点呢？")]),v._v(" "),_("p",[v._v("当然有，那就是将 RDB 和 AOF 合体使用，这个方法是在 Redis 4.0 提出的，该方法叫"),_("strong",[v._v("混合使用 AOF 日志和内存快照")]),v._v("，也叫混合持久化。")]),v._v(" "),_("p",[v._v("如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：")]),v._v(" "),_("div",{staticClass:"language-text extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("aof-use-rdb-preamble yes\n")])])]),_("p",[v._v("混合持久化工作在 "),_("strong",[v._v("AOF 日志重写过程")]),v._v("。")]),v._v(" "),_("p",[v._v("当开启了混合持久化时，在 AOF 重写日志时，"),_("code",[v._v("fork")]),v._v(" 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。")]),v._v(" "),_("p",[v._v("也就是说，使用了混合持久化，AOF 文件的"),_("strong",[v._v("前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据")]),v._v("。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/f67379b60d151262753fec3b817b8617.png",alt:"图片"}})]),v._v(" "),_("p",[v._v("这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样"),_("strong",[v._v("加载的时候速度会很快")]),v._v("。")]),v._v(" "),_("p",[v._v("加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得"),_("strong",[v._v("数据更少的丢失")]),v._v("。")]),v._v(" "),_("h1",{attrs:{id:"redis-大-key-对持久化有什么影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-大-key-对持久化有什么影响"}},[v._v("#")]),v._v(" Redis 大 Key 对持久化有什么影响？")]),v._v(" "),_("p",[v._v("大家好，我是小林。")]),v._v(" "),_("p",[v._v("上周有位读者字节一二面时，被问到："),_("strong",[v._v("Redis 的大 Key 对持久化有什么影响？")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/2ae06f60d9614da0be4729944b2a317c.png",alt:"·"}})]),v._v(" "),_("p",[v._v("Redis 的持久化方式有两种：AOF 日志和 RDB 快照。")]),v._v(" "),_("p",[v._v("所以接下来，针对这两种持久化方式具体分析分析。")]),v._v(" "),_("h2",{attrs:{id:"大-key-对-aof-日志的影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#大-key-对-aof-日志的影响"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/bigkey_aof_rdb.html#%E5%A4%A7-key-%E5%AF%B9-aof-%E6%97%A5%E5%BF%97%E7%9A%84%E5%BD%B1%E5%93%8D",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("大 Key 对 AOF 日志的影响")]),v._v(" "),_("blockquote",[_("p",[v._v("先说说 AOF 日志三种写回磁盘的策略")])]),v._v(" "),_("p",[v._v("Redis 提供了 3 种 AOF 日志写回硬盘的策略，分别是：")]),v._v(" "),_("ul",[_("li",[v._v("Always，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；")]),v._v(" "),_("li",[v._v("Everysec，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；")]),v._v(" "),_("li",[v._v("No，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。")])]),v._v(" "),_("p",[v._v("这三种策略只是在控制 fsync() 函数的调用时机。")]),v._v(" "),_("p",[v._v("当应用程序向文件写入数据时，内核通常先将数据复制到内核缓冲区中，然后排入队列，然后由内核决定何时写入硬盘。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/def7d5328829470c9f3cfd15bbcc6814.png",alt:"img"}})]),v._v(" "),_("p",[v._v("如果想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用 fsync() 函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。")]),v._v(" "),_("ul",[_("li",[v._v("Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；")]),v._v(" "),_("li",[v._v("Everysec 策略就会创建一个异步任务来执行 fsync() 函数；")]),v._v(" "),_("li",[v._v("No 策略就是永不执行 fsync() 函数;")])]),v._v(" "),_("blockquote",[_("p",[v._v("分别说说这三种策略，在持久化大 Key 的时候，会影响什么？")])]),v._v(" "),_("p",[v._v("在使用 Always 策略的时候，主线程在执行完命令后，会把数据写入到 AOF 日志文件，然后会调用 fsync() 函数，将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。")]),v._v(" "),_("p",[_("strong",[v._v("当使用 Always 策略的时候，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的")]),v._v("。")]),v._v(" "),_("p",[v._v("当使用 Everysec 策略的时候，由于是异步执行 fsync() 函数，所以大 Key 持久化的过程（数据同步磁盘）不会影响主线程。")]),v._v(" "),_("p",[v._v("当使用 No 策略的时候，由于永不执行 fsync() 函数，所以大 Key 持久化的过程不会影响主线程。")]),v._v(" "),_("h2",{attrs:{id:"大-key-对-aof-重写和-rdb-的影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#大-key-对-aof-重写和-rdb-的影响"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/bigkey_aof_rdb.html#%E5%A4%A7-key-%E5%AF%B9-aof-%E9%87%8D%E5%86%99%E5%92%8C-rdb-%E7%9A%84%E5%BD%B1%E5%93%8D",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("大 Key 对 AOF 重写和 RDB 的影响")]),v._v(" "),_("p",[v._v("当 AOF 日志写入了很多的大 Key，AOF 日志文件的大小会很大，那么很快就会触发 "),_("strong",[v._v("AOF 重写机制")]),v._v("。")]),v._v(" "),_("p",[v._v("AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 "),_("code",[v._v("fork()")]),v._v(" 函数创建一个子进程来处理任务。")]),v._v(" "),_("p",[v._v("在创建子进程的过程中，操作系统会把父进程的「页表」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/06657cb93ffa4a24b8fc5b3069cb29bf.png",alt:"img"}}),v._v(" 这样一来，子进程就共享了父进程的物理内存数据了，这样能够节约物理内存资源，页表对应的页表项的属性会标记该物理内存的权限为"),_("strong",[v._v("只读")]),v._v("。")]),v._v(" "),_("p",[v._v("随着 Redis 存在越来越多的大 Key，那么 Redis 就会占用很多内存，对应的页表就会越大。")]),v._v(" "),_("p",[v._v("在通过 "),_("code",[v._v("fork()")]),v._v(" 函数创建子进程的时候，虽然不会复制父进程的物理内存，但是"),_("strong",[v._v("内核会把父进程的页表复制一份给子进程，如果页表很大，那么这个复制过程是会很耗时的，那么在执行 fork 函数的时候就会发生阻塞现象")]),v._v("。")]),v._v(" "),_("p",[v._v("而且，fork 函数是由 Redis 主线程调用的，如果 fork 函数发生阻塞，那么意味着就会阻塞 Redis 主线程。由于 Redis 执行命令是在主线程处理的，所以当 Redis 主线程发生阻塞，就无法处理后续客户端发来的命令。")]),v._v(" "),_("p",[v._v("我们可以执行 "),_("code",[v._v("info")]),v._v(" 命令获取到 latest_fork_usec 指标，表示 Redis 最近一次 fork 操作耗时。")]),v._v(" "),_("div",{staticClass:"language-sql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 最近一次 fork 操作耗时")]),v._v("\nlatest_fork_usec:"),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("315")]),v._v("\n")])])]),_("p",[v._v("如果 fork 耗时很大，比如超过1秒，则需要做出优化调整：")]),v._v(" "),_("ul",[_("li",[v._v("单个实例的内存占用控制在 10 GB 以下，这样 fork 函数就能很快返回。")]),v._v(" "),_("li",[v._v("如果 Redis 只是当作纯缓存使用，不关心 Redis 数据安全性问题，可以考虑关闭 AOF 和 AOF 重写，这样就不会调用 fork 函数了。")]),v._v(" "),_("li",[v._v("在主从架构中，要适当调大 repl-backlog-size，避免因为 repl_backlog_buffer 不够大，导致主节点频繁地使用全量同步的方式，全量同步的时候，是会创建 RDB 文件的，也就是会调用 fork 函数。")])]),v._v(" "),_("blockquote",[_("p",[v._v("那什么时候会发生物理内存的复制呢？")])]),v._v(" "),_("p",[v._v("当父进程或者子进程在向共享内存发起写操作时，CPU 就会触发"),_("strong",[v._v("写保护中断")]),v._v("，这个「写保护中断」是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行物理内存的复制，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，最后才会对内存进行写操作，这个过程被称为「"),_("strong",[v._v("写时复制(Copy On Write)")]),v._v("」。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/451024fe10374431aff6f93a8fed4638.png",alt:"img"}})]),v._v(" "),_("p",[v._v("写时复制顾名思义，在发生写操作的时候，操作系统才会去复制物理内存，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。")]),v._v(" "),_("p",[v._v("如果创建完子进程后，"),_("strong",[v._v("父进程对共享内存中的大 Key 进行了修改，那么内核就会发生写时复制，会把物理内存复制一份，由于大 Key 占用的物理内存是比较大的，那么在复制物理内存这一过程中，也是比较耗时的，于是父进程（主线程）就会发生阻塞")]),v._v("。")]),v._v(" "),_("p",[v._v("所以，有两个阶段会导致阻塞父进程：")]),v._v(" "),_("ul",[_("li",[v._v("创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；")]),v._v(" "),_("li",[v._v("创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；")])]),v._v(" "),_("p",[v._v("这里额外提一下， 如果 "),_("strong",[v._v("Linux 开启了内存大页，会影响 Redis 的性能的")]),v._v("。")]),v._v(" "),_("p",[v._v("Linux 内核从 2.6.38 开始支持内存大页机制，该机制支持 2MB 大小的内存页分配，而常规的内存页分配是按 4KB 的粒度来执行的。")]),v._v(" "),_("p",[v._v("如果采用了内存大页，那么即使客户端请求只修改 100B 的数据，在发生写时复制后，Redis 也需要拷贝 2MB 的大页。相反，如果是常规内存页机制，只用拷贝 4KB。")]),v._v(" "),_("p",[v._v("两者相比，你可以看到，每次写命令引起的"),_("strong",[v._v("复制内存页单位放大了 512 倍，会拖慢写操作的执行时间，最终导致 Redis 性能变慢")]),v._v("。")]),v._v(" "),_("p",[v._v("那该怎么办呢？很简单，关闭内存大页（默认是关闭的）。")]),v._v(" "),_("p",[v._v("禁用方法如下：")]),v._v(" "),_("div",{staticClass:"language-shell extra-class"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[_("span",{pre:!0,attrs:{class:"token builtin class-name"}},[v._v("echo")]),v._v(" never "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("  /sys/kernel/mm/transparent_hugepage/enabled\n")])])]),_("h2",{attrs:{id:"总结-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[v._v("#")]),v._v(" "),_("a",{attrs:{href:"https://www.xiaolincoding.com/redis/storage/bigkey_aof_rdb.html#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"}},[v._v("#"),_("OutboundLink")],1),v._v("总结")]),v._v(" "),_("p",[v._v("当 AOF 写回策略配置了 Always 策略，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。")]),v._v(" "),_("p",[v._v("AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 "),_("code",[v._v("fork()")]),v._v(" 函数创建一个子进程来处理任务。会有两个阶段会导致阻塞父进程（主线程）：")]),v._v(" "),_("ul",[_("li",[v._v("创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；")]),v._v(" "),_("li",[v._v("创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。")])]),v._v(" "),_("p",[v._v("大 key 除了会影响持久化之外，还会有以下的影响。")]),v._v(" "),_("ul",[_("li",[v._v("客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。")]),v._v(" "),_("li",[v._v("引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。")]),v._v(" "),_("li",[v._v("阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。")]),v._v(" "),_("li",[v._v("内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。")])]),v._v(" "),_("p",[v._v("如何避免大 Key 呢？")]),v._v(" "),_("p",[v._v("最好在设计阶段，就把大 key 拆分成一个一个小 key。或者，定时检查 Redis 是否存在大 key ，如果该大 key 是可以删除的，不要使用 DEL 命令删除，因为该命令删除过程会阻塞主线程，而是用 unlink 命令（Redis 4.0+）删除大 key，因为该命令的删除过程是异步的，不会阻塞主线程。")])])}),[],!1,null,null,null);_.default=t.exports}}]);