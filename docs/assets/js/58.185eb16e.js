(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{327:function(t,a,e){"use strict";e.r(a);var s=e(14),n=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[t._v("#")]),t._v(" 面试题")]),t._v(" "),a("h3",{attrs:{id:"_1-高并发秒杀超卖问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-高并发秒杀超卖问题"}},[t._v("#")]),t._v(" "),a("strong",[t._v("1.高并发秒杀超卖问题")])]),t._v(" "),a("p",[t._v("1.数据库层面的互斥锁，2.应用层面的分布式锁，3.redis的单线程特性+内存运行（预减库存，但存在缓存数据一致性问题）")]),t._v(" "),a("h3",{attrs:{id:"_2-测试-淘宝购物车"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-测试-淘宝购物车"}},[t._v("#")]),t._v(" "),a("strong",[t._v("2.测试-淘宝购物车")])]),t._v(" "),a("p",[t._v("界面测试-功能测试-性能测试-兼容性测试-网络环境测试-异常测试（内存，网络，商品操作是清理后台应用有何影响）-本地-国际化测试（习俗，文化，语言）")]),t._v(" "),a("h3",{attrs:{id:"_3-典型电商促销场景下的云端压力测试实战"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-典型电商促销场景下的云端压力测试实战"}},[t._v("#")]),t._v(" "),a("strong",[t._v("3.典型电商促销场景下的云端压力测试实战")])]),t._v(" "),a("p",[t._v("瞬间集中并发，传统压测工具Loadrunner和Jmeter，基础数据，热点数据，缓存数据，一次性数据")]),t._v(" "),a("p",[a("strong",[t._v("压测场景建模")])]),t._v(" "),a("p",[t._v("完成业务场景建模后，基于其进行压测场景建模，这里要考虑到采用的测试策略，当然，测试策略的制定需要结合系统架构（需要梳理清各服务间的依赖和调用关系）和业务特点来说。")]),t._v(" "),a("p",[t._v("比如抽奖抢券秒杀场景，就需要采用并发测试以及超卖验证等测试策略。")]),t._v(" "),a("p",[t._v("考虑到业务配比的情况，我们还需要进行单接口的基准测试以及单机混合场景容量测试。")]),t._v(" "),a("p",[t._v("核心业务流程，其特性要求系统具备高可用和稳定性，那么测试策略就需要采用高可用测试和稳定性测试。")]),t._v(" "),a("p",[a("strong",[t._v("1、压测")])]),t._v(" "),a("p",[t._v("压测工作主要有如下几种情景，按照预先制定的测试策略执行即可（不排除临时特殊情况，这里需灵活调整）。")]),t._v(" "),a("p",[a("strong",[t._v("①、单机单接口测试")]),t._v("：该策略主要是为了验证单接口的性能基准，避免整个调用链路过程中某个服务/接口成为瓶颈；")]),t._v(" "),a("p",[a("strong",[t._v("②、单机多接口测试")]),t._v("：相较于微服务架构的服务解耦，有时候某些服务间互相调用依赖的强关系可能会造成资源竞争等情况，需要通过这种方式来排查验证；")]),t._v(" "),a("p",[a("strong",[t._v("③、单机混合场景测试")]),t._v("：这种测试方式的主要作用是得到一个单机混合场景下的最优性能表现，为服务扩容和线上容量规划提供参考数据；")]),t._v(" "),a("p",[a("strong",[t._v("④、多节点测试")]),t._v("：现在大多数的互联网企业都采用的集群/分布式/微服务架构，在多节点部署时候，考虑到SLB的边际递减效应，需要进行多节点测试；")]),t._v(" "),a("p",[t._v("通过该种方式，来验证负载均衡递减比率，为生产扩容提供精确的参考依据；")]),t._v(" "),a("p",[a("strong",[t._v("⑤、高可用测试")]),t._v("：高可用主要验证2点："),a("strong",[t._v("服务异常/宕机是否可以恢复")]),t._v("以及"),a("strong",[t._v("恢复到正常水*所耗费的时间")]),t._v("（越短越好）。")]),t._v(" "),a("p",[a("strong",[t._v("⑥、稳定性测试")]),t._v("：前面提到了核心业务流程必须保证稳定性，稳定性测试一般根据系统特点和业务类型，分为两类：5d"),a("em",[t._v("12h、7d")]),t._v("24h。")]),t._v(" "),a("p",[t._v("一般来说，稳定性测试的执行时间，12h即可（当然，24h或者更长也可以，根据具体情况灵活调整）。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img2018.cnblogs.com/blog/983980/201906/983980-20190624003458858-843470018.png",alt:"983980-20190624003458858-843470018"}})]),t._v(" "),a("p",[t._v("临时扩容或者服务降级限流甚至熔断等机制，保证系统在峰值流量下保持服务可用。")]),t._v(" "),a("h3",{attrs:{id:"_4-liunx下怎么查进程-怎么查端口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-liunx下怎么查进程-怎么查端口"}},[t._v("#")]),t._v(" "),a("strong",[t._v("4.liunx下怎么查进程，怎么查端口")])]),t._v(" "),a("p",[t._v("1、利用lsof命令查看，当命令参数设置为“-i”时用以显示符合条件的进程情况，语法为“lsof -i:端口号”；")]),t._v(" "),a("p",[t._v("2、利用netstat命令查看，该命令会列出端口所有状态的连接，语法为“netstat-tunlp|grep 端口号”。")]),t._v(" "),a("h3",{attrs:{id:"_5-线程池核心参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-线程池核心参数"}},[t._v("#")]),t._v(" "),a("strong",[t._v("5.线程池核心参数")])]),t._v(" "),a("ol",[a("li",[t._v("corePoolSize：核心线程数。")]),t._v(" "),a("li",[t._v("maximumPoolSize：最大线程数。"),a("strong",[t._v("线程池允许创建的最大线程数量，当线程池的任务队列满了之后，可以创建的最大线程数。")])]),t._v(" "),a("li",[t._v("keepAliveTime：空闲线程存活时间。")]),t._v(" "),a("li",[t._v("TimeUnit：时间单位。")]),t._v(" "),a("li",[t._v("BlockingQueue：线程池任务队列。")]),t._v(" "),a("li",[t._v("ThreadFactory：创建线程的工厂。")]),t._v(" "),a("li",[t._v("RejectedExecutionHandler：拒绝策略。")])]),t._v(" "),a("p",[a("strong",[t._v("拒绝策略：当线程池的任务超出线程池队列可以存储的最大值之后，执行的策略。")]),t._v("\n默认的拒绝策略有以下 4 种：")]),t._v(" "),a("ul",[a("li",[t._v("AbortPolicy：拒绝并抛出异常。")]),t._v(" "),a("li",[t._v("CallerRunsPolicy：使用当前调用的线程来执行此任务。")]),t._v(" "),a("li",[t._v("DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。")]),t._v(" "),a("li",[t._v("DiscardPolicy：忽略并抛弃当前任务。")])]),t._v(" "),a("p",[t._v("线程池的默认策略是 AbortPolicy 拒绝并抛出异常。")]),t._v(" "),a("h3",{attrs:{id:"_6-spring-涉及到的设计模式汇总"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-spring-涉及到的设计模式汇总"}},[t._v("#")]),t._v(" "),a("strong",[t._v("6.Spring-涉及到的设计模式汇总")])]),t._v(" "),a("p",[a("strong",[t._v("1. 简单工厂")])]),t._v(" "),a("p",[t._v("简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。")]),t._v(" "),a("p",[t._v("Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。")]),t._v(" "),a("p",[a("strong",[t._v("2. 工厂方法（Factory Method）")])]),t._v(" "),a("p",[t._v("定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。")]),t._v(" "),a("p",[a("strong",[t._v("3. 单例（Singleton）")])]),t._v(" "),a("p",[t._v("保证一个类仅有一个实例，并提供一个访问它的全局访问点。")]),t._v(" "),a("p",[t._v("Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为Spring管理的是是任意的Java对象。")]),t._v(" "),a("p",[a("strong",[t._v("4. 适配器（Adapter）")])]),t._v(" "),a("p",[t._v("将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。")]),t._v(" "),a("p",[t._v("Spring中在对于AOP的处理中有Adapter模式的例子")]),t._v(" "),a("p",[a("strong",[t._v("5.包装器（Decorator）")])]),t._v(" "),a("p",[t._v("动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。")]),t._v(" "),a("p",[a("strong",[t._v("6. 代理（Proxy）")])]),t._v(" "),a("p",[t._v("为其他对象提供一种代理以控制对这个对象的访问。")]),t._v(" "),a("p",[t._v("从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。")]),t._v(" "),a("p",[a("strong",[t._v("7.观察者（Observer）")])]),t._v(" "),a("p",[t._v("定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。")]),t._v(" "),a("p",[a("strong",[t._v("8. 策略（Strategy）")])]),t._v(" "),a("p",[t._v("定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。")]),t._v(" "),a("p",[a("strong",[t._v("9.模板方法（Template Method）")])]),t._v(" "),a("p",[t._v("定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。")]),t._v(" "),a("p",[t._v("Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。Spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。")]),t._v(" "),a("h3",{attrs:{id:"_7-jdbc建立连接流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-jdbc建立连接流程"}},[t._v("#")]),t._v(" "),a("strong",[t._v("7. JDBC建立连接流程")])]),t._v(" "),a("p",[t._v("SPI（服务提供接口），定义标准，厂商实现接口，提供Jar包，ClassLoader记载对应的jar包，执行对应的方法。")]),t._v(" "),a("h3",{attrs:{id:"_8-布隆过滤器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-布隆过滤器"}},[t._v("#")]),t._v(" "),a("strong",[t._v("8.布隆过滤器")])]),t._v(" "),a("p",[t._v("布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。"),a("strong",[t._v("它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难")]),t._v("。(布隆过滤器使用了K个hash函数计算，所有可能在多个位置hash索引为1，这样可能会出现一个从未索引的值，在布隆过滤器中可以被查询到的情况，误判（可预测比例）)"),a("strong",[t._v("当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中")]),t._v("。")]),t._v(" "),a("p",[t._v("利用布隆过滤器我们可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当根据 ID 进行数据查询的时候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是缓存穿透不能完全解决，我们只能将其控制在一个可以容忍的范围内。")]),t._v(" "),a("h3",{attrs:{id:"_9-threadlocal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-threadlocal"}},[t._v("#")]),t._v(" "),a("strong",[t._v("9.ThreadLocal")])]),t._v(" "),a("p",[t._v("https://pdai.tech/md/java/thread/java-thread-x-threadlocal.html")]),t._v(" "),a("h3",{attrs:{id:"_10-session是什么-它与cookie有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-session是什么-它与cookie有什么区别"}},[t._v("#")]),t._v(" "),a("strong",[t._v("10."),a("a",{attrs:{href:"https://segmentfault.com/a/1190000041429984",target:"_blank",rel:"noopener noreferrer"}},[t._v("Session是什么？它与Cookie有什么区别？"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("https://www.51cto.com/article/679219.html")]),t._v(" "),a("h3",{attrs:{id:"_11-tomcat如何以及为什么要打破双亲委派模型-顺带介绍一下双亲委派模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-tomcat如何以及为什么要打破双亲委派模型-顺带介绍一下双亲委派模型"}},[t._v("#")]),t._v(" "),a("strong",[t._v("11.tomcat如何以及为什么要打破双亲委派模型（顺带介绍一下双亲委派模型）")])]),t._v(" "),a("p",[t._v("双亲委派模型（Parent Delegation Model）是Java类加载器的一种工作机制，它是Java安全模型的核心之一。在Java中，类加载器（ClassLoader）负责将类的字节码加载到内存中，并生成对应的Class对象供程序使用。双亲委派模型规定了类加载器的工作流程和层次结构，保证了类的加载的安全性和一致性。")]),t._v(" "),a("p",[t._v("如果一个类加载器收到了加载某个类的请求，则该类加载器并不会去加载该类，而是把这个请求委派给父类加载器，每一个层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶端的启动类加载器；只有当父类加载器在其搜索范围内无法找到所需的类，并将该结果反馈给子类加载器，子类加载器会尝试去自己加载。")]),t._v(" "),a("p",[t._v("双亲委派模型的基本原则是：当一个类加载器需要加载一个类时，它首先会将这个任务委托给父类加载器。如果父类加载器无法加载这个类，子类加载器才会尝试加载。这种委派机制一直向上追溯，直到顶层的启动类加载器（BootStrap ClassLoader）。")]),t._v(" "),a("p",[t._v("双亲委派模型的优势在于保证了类的加载的唯一性和一致性。当一个类被加载后，它会被缓存在加载器的缓存中，下次再次加载这个类时，直接从缓存中取出，不再重新加载。这样可以避免重复加载同一个类，节省了内存空间，提高了系统的性能。")]),t._v(" "),a("p",[t._v("双亲委派模型还增强了Java的安全性。通过委派机制，保证了核心类库的安全性，防止用户自定义的类替换核心类库中的类，避免了恶意代码的注入，提高了系统的稳定性和安全性。例如，当我们编写一个Java应用程序时，如果需要使用String类，那么首先会尝试从父类加载器中加载。只有当父类加载器无法加载时，才会尝试从当前类加载器中加载。这样就保证了我们使用的是JDK中的标准String类，而不是自己定义的String类。")]),t._v(" "),a("p",[t._v("双亲委派模型还可以实现类的隔离和防止类的冲突。例如，如果两个不同的类加载器加载了同一个类，由于类加载器是独立的，它们会生成两个不同的Class对象，因此这两个类是不相等的，可以实现类的隔离和防止类的冲突。")]),t._v(" "),a("p",[t._v("总结来说，双亲委派模型是Java类加载器的一种工作机制，通过委派机制和层次结构，保证了类的加载的安全性和一致性，增强了Java的安全性，实现了类的隔离和防止类的冲突。它是Java安全模型的重要组成部分，也是Java语言的一个重要特性。")]),t._v(" "),a("p",[t._v("打破双亲委派模型（JDBC和Tomcat）")]),t._v(" "),a("p",[a("strong",[t._v("因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。")])]),t._v(" "),a("p",[t._v("JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于 $JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，**根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。**也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。")]),t._v(" "),a("p",[a("strong",[t._v("Tomcat为什么要破坏双亲委派模型"),a("a",{attrs:{href:"https://www.cnblogs.com/yueshutong/p/11430885.html#134638671",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1)])]),t._v(" "),a("p",[a("strong",[t._v("每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。")])]),t._v(" "),a("p",[t._v("事实上，tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的：")]),t._v(" "),a("ul",[a("li",[t._v("对于各个 "),a("code",[t._v("webapp")]),t._v("中的 "),a("code",[t._v("class")]),t._v("和 "),a("code",[t._v("lib")]),t._v("，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。")]),t._v(" "),a("li",[t._v("与 "),a("code",[t._v("jvm")]),t._v("一样的安全性问题。使用单独的 "),a("code",[t._v("classloader")]),t._v("去装载 "),a("code",[t._v("tomcat")]),t._v("自身的类库，以免其他恶意或无意的破坏；")]),t._v(" "),a("li",[t._v("热部署。相信大家一定为 "),a("code",[t._v("tomcat")]),t._v("修改文件不用重启就自动重新装载类库而惊叹吧。")])]),t._v(" "),a("h3",{attrs:{id:"_12-四种引用的应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-四种引用的应用场景"}},[t._v("#")]),t._v(" "),a("strong",[t._v("12.四种引用的应用场景")])]),t._v(" "),a("p",[t._v("Java中共有四种引用类型，包括强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference），它们各自有着不同的应用场景。")]),t._v(" "),a("ol",[a("li",[t._v("强引用（Strong Reference）： 强引用是指在程序中普遍存在的引用方式，如果一个对象具有强引用，那么垃圾收集器就不会回收它。当一个对象被多个强引用所引用时，垃圾收集器也不会回收它，直到所有强引用都被释放掉。")])]),t._v(" "),a("p",[t._v("应用场景： 强引用通常用于对象的普通应用场景，例如在方法中创建对象并将其赋值给局部变量，或者在类中将对象作为成员变量存储。这些对象在程序运行期间一般都需要保持存在，因此使用强引用可以确保它们不会被垃圾收集器回收。")]),t._v(" "),a("ol",[a("li",[t._v("软引用（Soft Reference）： 软引用是一种比较弱的引用类型，如果一个对象只有软引用，则在系统内存不足时，垃圾收集器会将其回收。软引用通常用于缓存，如果内存充足，则可以从缓存中获取对象，否则需要重新创建。")])]),t._v(" "),a("p",[t._v("应用场景： 软引用通常用于缓存和高速缓存的实现。在缓存中，一些经常使用的对象可以被存储在内存中，以便快速访问。如果系统内存不足，垃圾收集器会回收这些对象，从而释放内存。")]),t._v(" "),a("ol",[a("li",[t._v("弱引用（Weak Reference）： 弱引用是比软引用更弱的引用类型，如果一个对象只有弱引用，则在下一次垃圾收集时，无论内存是否充足，都会被回收。弱引用通常用于实现缓存或对象注册表，这些对象的生命周期通常比较短。")])]),t._v(" "),a("p",[t._v("应用场景： 弱引用通常用于缓存或对象注册表中，这些对象的生命周期通常很短，但在某些情况下需要进行访问。通过使用弱引用，可以确保这些对象在不需要时可以被回收，从而避免内存泄漏。")]),t._v(" "),a("ol",[a("li",[t._v("虚引用（Phantom Reference）： 虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。虚引用是最弱的引用类型，它无法通过引用访问到对象，也无法通过引用获取到对象的状态。虚引用主要用于跟踪对象被垃圾回收的状态，可以通过虚引用观察到一个对象是否已经被垃圾收集器回收。")])]),t._v(" "),a("p",[t._v("五，引用队列（ReferenceQueue）")]),t._v(" "),a("p",[t._v("引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。")]),t._v(" "),a("p",[t._v("与软引用、弱引用不同，虚引用必须和引用队列一起使用。")]),t._v(" "),a("p",[a("strong",[t._v("四种引用比较")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("引用类型")]),t._v(" "),a("th",[t._v("被垃圾回收时间")]),t._v(" "),a("th",[t._v("用途")]),t._v(" "),a("th",[t._v("生存时间")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("强引用")]),t._v(" "),a("td",[t._v("从来不会")]),t._v(" "),a("td",[t._v("对象的一般状态")]),t._v(" "),a("td",[t._v("JVM停止运行时终止")])]),t._v(" "),a("tr",[a("td",[t._v("软引用")]),t._v(" "),a("td",[t._v("当内存不足时")]),t._v(" "),a("td",[t._v("对象缓存")]),t._v(" "),a("td",[t._v("内存不足时终止")])]),t._v(" "),a("tr",[a("td",[t._v("弱引用")]),t._v(" "),a("td",[t._v("正常垃圾回收时")]),t._v(" "),a("td",[t._v("对象缓存")]),t._v(" "),a("td",[t._v("垃圾回收后终止")])]),t._v(" "),a("tr",[a("td",[t._v("虚引用")]),t._v(" "),a("td",[t._v("正常垃圾回收时")]),t._v(" "),a("td",[t._v("跟踪对象的垃圾回收")]),t._v(" "),a("td",[t._v("垃圾回收后终止")])])])]),t._v(" "),a("h3",{attrs:{id:"_13-redis哨兵如何实现通信-结点宕机如何处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-redis哨兵如何实现通信-结点宕机如何处理"}},[t._v("#")]),t._v(" "),a("strong",[t._v("13.Redis哨兵如何实现通信，结点宕机如何处理")])]),t._v(" "),a("p",[t._v("心跳机制-通信（master或者slave宕机）")]),t._v(" "),a("h3",{attrs:{id:"_14-spring如何解决ioc时的循环依赖问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-spring如何解决ioc时的循环依赖问题"}},[t._v("#")]),t._v(" "),a("strong",[t._v("14.Spring如何解决IOC时的循环依赖问题")])]),t._v(" "),a("p",[t._v("如果不考虑Spring，循环依赖并不是问题，因为对象之间相互依赖是很正常的事情。比如")]),t._v(" "),a("div",{staticClass:"language-ini extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ini"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("A a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("new A();")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("B b")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("new B();")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("a.b")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("b;")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("b.a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("a;")]),t._v("\n")])])]),a("p",[t._v("这样，A,B就依赖上了。")]),t._v(" "),a("p",[a("strong",[t._v("Bean的生命周期")])]),t._v(" "),a("p",[t._v("这里不会对Bean的生命周期进行详细的描述，只描述一下大概的过程。")]),t._v(" "),a("p",[t._v("Bean的生命周期指的就是：在Spring中，Bean是如何生成的？")]),t._v(" "),a("p",[t._v("被Spring管理的对象叫做Bean。Bean的生成步骤如下：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("Spring扫描class得到BeanDefinition")])]),t._v(" "),a("li",[a("p",[t._v("根据得到的BeanDefinition去生成bean")])]),t._v(" "),a("li",[a("p",[t._v("首先根据class推断构造方法")])]),t._v(" "),a("li",[a("p",[t._v("根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）")])]),t._v(" "),a("li",[a("p",[t._v("填充原始对象中的属性（依赖注入）")])]),t._v(" "),a("li",[a("p",[t._v("如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象（这个是AOP切面类的对象）")])]),t._v(" "),a("li",[a("p",[t._v("把最终生成的代理对象放入单例池（源码中叫做singletonObjects）中，下次getBean时就直接从单例池拿即可")])])]),t._v(" "),a("p",[t._v("可以看到，对于Spring中的Bean的生成过程，步骤还是很多的，并且不仅仅只有上面的7步，还有很多很多，比如Aware回调、初始化等等，这里不详细讨论。")]),t._v(" "),a("p",[t._v("可以发现，在Spring中，构造一个Bean，包括了new这个步骤（第4步构造方法反射）。")]),t._v(" "),a("p",[t._v("得到一个原始对象后，Spring需要给对象中的属性进行依赖注入，那么这个注入过程是怎样的？")]),t._v(" "),a("p",[t._v("比如上文说的A类，A类中存在一个B类的b属性，所以，当A类生成了一个原始对象之后，就会去给b属性去赋值，此时就会根据b属性的类型和属性名去BeanFactory中去获取B类所对应的单例bean。如果此时BeanFactory中存在B对应的Bean，那么直接拿来赋值给b属性；如果此时BeanFactory中不存在B对应的Bean，则需要生成一个B对应的Bean，然后赋值给b属性。")]),t._v(" "),a("p",[t._v("问题就出现在第二种情况，如果此时B类在BeanFactory中还没有生成对应的Bean，那么就需要去生成，就会经过B的Bean的生命周期。")]),t._v(" "),a("p",[t._v("那么在创建B类的Bean的过程中，如果B类中存在一个A类的a属性，那么在创建B的Bean的过程中就需要A类对应的Bean，但是，触发B类Bean的创建的条件是A类Bean在创建过程中的依赖注入，所以这里就出现了循环依赖：")]),t._v(" "),a("p",[t._v("ABean创建--\x3e依赖了B属性--\x3e触发BBean创建---\x3eB依赖了A属性---\x3e需要ABean（但ABean还在创建过程中）")]),t._v(" "),a("p",[t._v("从而导致ABean创建不出来，BBean也创建不出来。")]),t._v(" "),a("p",[t._v("这是循环依赖的场景，但是上文说了，在Spring中，通过某些机制帮开发者解决了部分循环依赖的问题，这个机制就是"),a("strong",[t._v("三级缓存")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("三级缓存")])]),t._v(" "),a("p",[t._v("三级缓存是通用的叫法。")]),t._v(" "),a("p",[t._v("一级缓存为：singletonObjects")]),t._v(" "),a("p",[t._v("二级缓存为：earlySingletonObjects")]),t._v(" "),a("p",[t._v("三级缓存为：singletonFactories")]),t._v(" "),a("p",[a("strong",[t._v("先稍微解释一下这三个缓存的作用，后面详细分析：")])]),t._v(" "),a("p",[t._v("singletonObjects中缓存的是已经经历了完整生命周期的bean对象。")]),t._v(" "),a("p",[t._v("earlySingletonObjects比singletonObjects多了一个early，表示缓存的是早期的bean对象。早期是什么意思？表示Bean的生命周期还没走完就把这个Bean放入earlySingletonObjects。")]),t._v(" "),a("p",[t._v("singletonFactories中缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31926946e894c078a6857aa7729edeb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp",alt:"jj"}})]),t._v(" "),a("p",[t._v("A的Bean在创建过程中，在进行依赖注入之前，先把A的原始Bean放入缓存（提早暴露，只要放到缓存了，其他Bean需要时就可以从缓存中拿了），放入缓存后，再进行依赖注入，此时A的Bean依赖了B的Bean，如果B的Bean不存在，则需要创建B的Bean，而创建B的Bean的过程和A一样，也是先创建一个B的原始对象，然后把B的原始对象提早暴露出来放入缓存中，然后在对B的原始对象进行依赖注入A，此时能从缓存中拿到A的原始对象（"),a("strong",[t._v("虽然是A的原始对象，还不是最终的Bean")]),t._v("），B的原始对象依赖注入完了之后，B的生命周期结束，那么A的生命周期也能结束。")]),t._v(" "),a("p",[t._v("因为整个过程中，都只有一个A原始对象，所以对于B而言，就算在属性注入时，注入的是A原始对象，也没有关系，因为A原始对象在后续的生命周期中在堆中没有发生变化。")]),t._v(" "),a("p",[t._v("上面是在A和B都没有AOP面向切面方法的切面类的情况下，由于AOP的切面类也需要生成Bean，所以只有一集缓存是不够的。")]),t._v(" "),a("p",[t._v("从上面这个分析过程中可以得出，只需要一个缓存就能解决循环依赖了，那么为什么Spring中还需要singletonFactories呢？")]),t._v(" "),a("p",[t._v("这是难点，基于上面的场景想一个问题："),a("strong",[t._v("如果A的原始对象注入给B的属性之后，A的原始对象进行了AOP产生了一个代理对象，此时就会出现，对于A而言，它的Bean对象其实应该是AOP之后的代理对象，而B的a属性对应的并不是AOP之后的代理对象，这就产生了冲突。B依赖的A和最终的A不是同一个对象。")])]),t._v(" "),a("p",[t._v("AOP就是通过一个BeanPostProcessor来实现的，这个BeanPostProcessor就是AnnotationAwareAspectJAutoProxyCreator，它的父类是AbstractAutoProxyCreator，而在Spring中AOP利用的要么是JDK动态代理，要么CGLib的动态代理，所以如果给一个类中的某个方法设置了切面，那么这个类最终就需要生成一个代理对象。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b4b3f947444579b57c1a7e79049293~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp",alt:"s"}})]),t._v(" "),a("p",[t._v("左边文字：")]),t._v(" "),a("p",[t._v("这个ObjectFactory就是上文说的labmda表达式，中间有getEarlyBeanReference方法，注意存入singletonFactories时并不会执行lambda表达式，也就是不会执行getEarlyBeanReference方法")]),t._v(" "),a("p",[t._v("右边文字：")]),t._v(" "),a("p",[t._v("从singletonFactories根据beanName得到一个ObjectFactory，然后执行ObjectFactory，也就是执行getEarlyBeanReference方法，此时会得到一个A原始对象经过AOP之后的代理对象，然后把该代理对象放入earlySingletonObjects中，注意此时并没有把代理对象放入singletonObjects中，那什么时候放入到singletonObjects中呢？")]),t._v(" "),a("p",[t._v("这个时候得来理解一下earlySingletonObjects的作用，此时，我们只得到了A原始对象的代理对象，这个对象还不完整，因为A原始对象还没有进行属性填充，所以此时不能直接把A的代理对象放入singletonObjects中，所以只能把代理对象放入earlySingletonObjects，假设现在有其他对象依赖了A，那么则可以从earlySingletonObjects中得到A原始对象的代理对象了，并且是A的同一个代理对象。")]),t._v(" "),a("p",[t._v("当B创建完了之后，A继续进行生命周期，而A在完成属性注入后，会按照它本身的逻辑去进行AOP，而此时我们知道A原始对象已经经历过了AOP，所以对于A本身而言，不会再去进行AOP了，那么怎么判断一个对象是否经历过了AOP呢？会利用上文提到的earlyProxyReferences，在AbstractAutoProxyCreator的postProcessAfterInitialization方法中，会去判断当前beanName是否在earlyProxyReferences，如果在则表示已经提前进行过AOP了，无需再次进行AOP。")]),t._v(" "),a("p",[t._v("对于A而言，进行了AOP的判断后，以及BeanPostProcessor的执行之后，就需要把A对应的对象放入singletonObjects中了，但是我们知道，应该是要A的代理对象放入singletonObjects中，所以此时需要从earlySingletonObjects中得到代理对象，然后入singletonObjects中。")]),t._v(" "),a("p",[t._v("整个循环依赖解决完毕。")]),t._v(" "),a("p",[t._v("总结一下三级缓存：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("singletonObjects：缓存某个beanName对应的经过了完整生命周期的bean")])]),t._v(" "),a("li",[a("p",[t._v("earlySingletonObjects：缓存提前拿原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期")])]),t._v(" "),a("li",[a("p",[t._v("singletonFactories：缓存的是一个ObjectFactory，主要用来去生成原始对象进行了AOP之后得到的代理对象，在每个Bean的生成过程中，都会提前暴露一个工厂，这个工厂可能用到，也可能用不到，如果没有出现循环依赖依赖本bean，那么这个工厂无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可，如果出现了循环依赖依赖了本bean，则另外那个bean执行ObjectFactory提交得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)。")])]),t._v(" "),a("li",[a("p",[t._v("其实还要一个缓存，就是earlyProxyReferences，它用来记录某个原始对象是否进行过AOP了。")])])]),t._v(" "),a("h3",{attrs:{id:"_15-一般是怎么创建线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-一般是怎么创建线程"}},[t._v("#")]),t._v(" 15.一般是怎么创建线程?")]),t._v(" "),a("p",[t._v("1、继承 Thread 类")]),t._v(" "),a("p",[t._v("通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。")]),t._v(" "),a("ul",[a("li",[t._v("首先定义一个类来继承 Thread 类，重写 run 方法。")]),t._v(" "),a("li",[t._v("然后创建这个子类对象，并调用 start 方法启动线程。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://ask.qcloudimg.com/http-save/yehe-2219188/uaa1zy9cb5.png?imageView2/2/w/1200",alt:"img"}})]),t._v(" "),a("p",[a("strong",[t._v("2、实现 Runnable 接口")])]),t._v(" "),a("p",[t._v("通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。")]),t._v(" "),a("ul",[a("li",[t._v("首先定义一个类实现 Runnable 接口，并实现 run 方法。")]),t._v(" "),a("li",[t._v("然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中")]),t._v(" "),a("li",[t._v("最后调用 start 方法启动线程。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://ask.qcloudimg.com/http-save/yehe-2219188/qucp8pstk7.png?imageView2/2/w/1200",alt:"img"}})]),t._v(" "),a("p",[a("strong",[t._v("3、实现 Callable 接口，并结合 Future 实现")])]),t._v(" "),a("ul",[a("li",[t._v("首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。")]),t._v(" "),a("li",[t._v("然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。")]),t._v(" "),a("li",[t._v("把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。")]),t._v(" "),a("li",[t._v("通过 FutureTask 的 get 方法获取线程的执行结果。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://ask.qcloudimg.com/http-save/yehe-2219188/zglut4qdvh.png?imageView2/2/w/1200",alt:"img"}})]),t._v(" "),a("p",[a("strong",[t._v("4、通过线程池创建线程")])]),t._v(" "),a("p",[t._v("此处用 JDK 自带的 Executors 来创建线程池对象。")]),t._v(" "),a("ul",[a("li",[t._v("首先，定一个 Runnable 的实现类，重写 run 方法。")]),t._v(" "),a("li",[t._v("然后创建一个拥有固定线程数的线程池。")]),t._v(" "),a("li",[t._v("最后通过 ExecutorService 对象的 execute 方法传入线程对象。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://ask.qcloudimg.com/http-save/yehe-2219188/grx8pgz81h.png?imageView2/2/w/1200",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"_16-线程池类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-线程池类型"}},[t._v("#")]),t._v(" 16.线程池类型")]),t._v(" "),a("p",[a("strong",[t._v("1、newCachedThreadPool")])]),t._v(" "),a("p",[t._v("创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。")]),t._v(" "),a("p",[t._v("这种类型的线程池特点是：")]),t._v(" "),a("p",[t._v("工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。")]),t._v(" "),a("p",[t._v("如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。")]),t._v(" "),a("p",[t._v("在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统OOM。")]),t._v(" "),a("p",[a("strong",[t._v("2、newFixedThreadPool")])]),t._v(" "),a("p",[t._v("创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。")]),t._v(" "),a("p",[t._v("FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。")]),t._v(" "),a("p",[a("strong",[t._v("3、newSingleThreadExecutor")])]),t._v(" "),a("p",[t._v("创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。")]),t._v(" "),a("p",[a("strong",[t._v("4、newScheduleThreadPool")])]),t._v(" "),a("p",[t._v("创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。")]),t._v(" "),a("p",[a("strong",[t._v("5、newSingleThreadScheduledExecutor")])]),t._v(" "),a("p",[t._v("创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行并且可定时或者延迟执行线程活动。")]),t._v(" "),a("h3",{attrs:{id:"_17-对象的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-对象的生命周期"}},[t._v("#")]),t._v(" 17.对象的生命周期")]),t._v(" "),a("p",[t._v("在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段："),a("strong",[t._v("创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"_18-线程池中后备队列满了的任务拒绝策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-线程池中后备队列满了的任务拒绝策略"}},[t._v("#")]),t._v(" 18.线程池中后备队列满了的任务拒绝策略")]),t._v(" "),a("p",[t._v("关于线程池的任务拒绝策略，我们要理解并记住，有如下的四种：")]),t._v(" "),a("p",[t._v("1、直接丢弃（DiscardPolicy）")]),t._v(" "),a("p",[t._v("2、丢弃队列中最老的任务(DiscardOldestPolicy)。")]),t._v(" "),a("p",[t._v("3、抛异常")]),t._v(" "),a("p",[t._v("4、将任务分给调用线程来执行。")]),t._v(" "),a("h3",{attrs:{id:"_19-redis如何实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-redis如何实现分布式锁"}},[t._v("#")]),t._v(" 19.redis如何实现分布式锁")]),t._v(" "),a("p",[t._v("我们在系统中修改已有数据时，需要先读取，然后进行修改保存，此时很容易遇到并发问题。由于修改和保存不是原子操作，在并发场景下，部分对数据的操作可能会丢失。在单服务器系统我们常用本地锁来避免并发带来的问题，然而，当服务采用集群方式部署时，本地锁无法在多个服务器之间生效，这时候保证数据的一致性就需要分布式锁来实现。")]),t._v(" "),a("p",[t._v("Redis 锁主要利用 Redis 的 setnx 命令。")]),t._v(" "),a("ul",[a("li",[t._v("加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。")]),t._v(" "),a("li",[t._v("解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。")]),t._v(" "),a("li",[t._v("锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。")])]),t._v(" "),a("h3",{attrs:{id:"_20-autowired和-resource区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-autowired和-resource区别"}},[t._v("#")]),t._v(" 20.@Autowired和@Resource区别")]),t._v(" "),a("p",[t._v("https://juejin.cn/post/7022507865701089317")]),t._v(" "),a("p",[t._v("共同点：@Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。")]),t._v(" "),a("p",[t._v("不同点：")]),t._v(" "),a("p",[t._v("1、@Resource是JDK原生的注解，@Autowired是Spring2.5 引入的注解")]),t._v(" "),a("p",[t._v("2、@Resource有两个属性name和type。Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。")]),t._v(" "),a("p",[t._v("@Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。")]),t._v(" "),a("p",[t._v("总结")]),t._v(" "),a("p",[t._v("@Autowired功能虽说非常强大，但是也有些不足之处。比如它跟Spring强耦合了，如果换成了其他框架，功能就会失效。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持。")]),t._v(" "),a("p",[t._v("除此之外，有些场景使用@Autowired无法满足的要求，改成@Resource却能解决问题。")]),t._v(" "),a("p",[t._v("1、@Autowired默认按byType自动装配，而@Resource默认byName自动装配。")]),t._v(" "),a("p",[t._v("2、@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。")]),t._v(" "),a("p",[t._v("3、@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。")]),t._v(" "),a("p",[t._v("4、@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。")]),t._v(" "),a("p",[t._v("5、@Autowired是Spring定义的注解，而@Resource是JSR-250定义的注解。")]),t._v(" "),a("p",[t._v("6、二者装配顺序不同")]),t._v(" "),a("p",[a("strong",[t._v("@Autowired")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8fabb988e2d4fcb87e592cd8846be68~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp",alt:"img"}})]),t._v(" "),a("p",[a("strong",[t._v("@Resource")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e987c1684435481bbaf3b270dfdbaf59~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"_21-spring-注解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-spring-注解"}},[t._v("#")]),t._v(" 21.Spring 注解")]),t._v(" "),a("p",[t._v("@Repository和@Controller、@Service、@"),a("a",{attrs:{href:"https://so.csdn.net/so/search?q=Component&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("Component"),a("OutboundLink")],1),t._v("的作用差不多，都是把对象交给spring管理。@Repository用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理。")]),t._v(" "),a("p",[t._v("为什么有时候我们不用@Repository来注解接口,我们照样可以注入到这个接口的实现类呢?\n1、spring配置文件中配置了MapperScannerConfigurer这个bean，它会扫描持久层接口创建实现类并交给spring管理。")]),t._v(" "),a("p",[t._v("2、接口上使用了@Mapper注解或者springboot中主类上使用了@MapperScan注解，和MapperScannerConfigurer作用一样。")]),t._v(" "),a("p",[t._v("注：不使用@Repository注解，idea会报警告，提示找不到这个bean，直接忽略即可。")]),t._v(" "),a("p",[t._v("@Repository的作用：\n这是因为该注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型。 Spring本身提供了一个丰富的并且是与具体的数据访问技术无关的数据访问异常结构，用于封装不同的持久层框架抛出的异常，使得异常独立于底层的框架。")]),t._v(" "),a("h3",{attrs:{id:"_22-spring注解分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-spring注解分类"}},[t._v("#")]),t._v(" 22.Spring注解分类")]),t._v(" "),a("p",[t._v("1、Spring注解分类\n从广义上Spring注解可以分为两类：")]),t._v(" "),a("p",[t._v("一类注解是用于注册Bean")]),t._v(" "),a("p",[t._v("假如IOC容器就是一间空屋子，首先这间空屋子啥都没有，我们要吃大餐，我们就要从外部搬运食材和餐具进来。这里把某一样食材或者某一样餐具搬进空屋子的操作就相当于每个注册Bean的注解作用类似。注册Bean的注解作用就是往IOC容器中放（注册）东西！\n用于注册Bean的注解： 比如@Component , @Repository , @ Controller , @Service , @Configration这些注解就是用于注册Bean，放进IOC容器中，一来交给spring管理方便解耦，二来还可以进行二次使用，啥是二次使用呢？这里的二次使用可以理解为：在你开始从外部搬运食材和餐具进空屋子的时候，一次性搬运了猪肉、羊肉、铁勺、筷子四样东西，这个时候你要开始吃大餐，首先你吃东西的时候肯定要用筷子或者铁勺，别说你手抓，只要你需要，你就会去找，这个时候发现你已经把筷子或者铁勺放进了屋子，你就不用再去外部拿筷子进屋子了，意思就是IOC容器中已经存在，就可以只要拿去用，而不必再去注册！而拿屋子里已有的东西的操作就是下面要讲的用于使用Bean的注解！")]),t._v(" "),a("p",[t._v("一类注解是用于使用Bean")]),t._v(" "),a("p",[t._v("用于使用Bean的注解：比如@Autowired , @Resource注解，这些注解就是把屋子里的东西自己拿来用，如果你要拿，前提一定是屋子（IOC）里有的，不然就会报错，比如你要做一道牛肉拼盘需要五头牛做原材料才行，你现在锅里只有四头牛，这个时候你知道，自己往屋子里搬过五头牛，这个时候就直接把屋子里的那头牛直接放进锅里，完成牛肉拼盘的组装。是的这些注解就是需要啥想要啥，只要容器中有就往容器中拿！而这些注解又有各自的区别，比如@Autowired用在筷子上，这筷子你可能只想用木质的，或许只想用铁质的，@Autowired作用在什么属性的筷子就那什么筷子，而@Resource如果用在安格斯牛肉上面，就指定要名字就是安格斯牛肉的牛肉。\nSpring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。 产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。@Bean明确地指示了一种方法，什么方法呢？产生一个bean的方法，并且交给Spring容器管理；从这我们就明白了为啥@Bean是放在方法的注释上了，因为它很明确地告诉被注释的方法，你给我产生一个Bean，然后交给Spring容器，剩下的你就别管了。记住，@Bean就放在方法上，就是让方法去产生一个Bean，然后交给Spring容器。")]),t._v(" "),a("p",[t._v("如下就能让accountDao方法产生一个AccountDao 对象，然后这个AccountDao 对象交给Spring管理")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Bean")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountDao")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("accountDao")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountDao")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("实际上，@Bean注解和xml配置中的bean标签的作用是一样的。")]),t._v(" "),a("p",[t._v("为什么要有@Bean注解？\n不知道大家有没有想过，用于注册Bean的注解的有那么多个，为何还要出现@Bean注解？")]),t._v(" "),a("p",[a("strong",[t._v("原因很简单：类似@Component , @Repository , @ Controller , @Service 这些注册Bean的注解存在局限性，只能局限作用于自己编写的类，如果是一个jar包第三方库要加入IOC容器的话，这些注解就手无缚鸡之力了，是的，@Bean注解就可以做到这一点！当然除了@Bean注解能做到还有@Import也能把第三方库中的类实例交给spring管理，而且@Import更加方便快捷，只是@Import注解并不在本篇范围内，这里就不再概述。")])]),t._v(" "),a("p",[t._v("使用@Bean注解的另一个好处就是能够动态获取一个Bean对象，能够根据环境不同得到不同的Bean对象。")]),t._v(" "),a("h3",{attrs:{id:"_23-repository和-controller、-service、-component"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-repository和-controller、-service、-component"}},[t._v("#")]),t._v(" 23.@Repository和@Controller、@Service、@Component")]),t._v(" "),a("p",[t._v("@Component")]),t._v(" "),a("p",[t._v("@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。")]),t._v(" "),a("p",[t._v("@Component有几个衍生注解，按照三处架构分层")]),t._v(" "),a("ul",[a("li",[t._v("dao[ @Repository ]")]),t._v(" "),a("li",[t._v("service[ @service ]")]),t._v(" "),a("li",[t._v("controller[ @Controller]")])]),t._v(" "),a("p",[t._v("因此，当你的一个类被"),a("code",[t._v("@Component")]),t._v("所注解，那么就意味着同样可以用"),a("code",[t._v("@Repository")]),t._v(", "),a("code",[t._v("@Service")]),t._v(", "),a("code",[t._v("@Controller")]),t._v("来替代它，同时这些注解会具备有更多的功能，而且功能各异。")]),t._v(" "),a("p",[t._v("@Controller控制层")]),t._v(" "),a("p",[t._v("用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象，分发处理器会扫描使用该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。@Controller只是定义了一个控制器类，而使用@RequestMapping注解的方法才是处理请求的处理器。")]),t._v(" "),a("p",[t._v("@RequestMapping")]),t._v(" "),a("p",[t._v("它可以注解类也可以注解方法，注解类时标注请求的路径，标注方法时表示将特定的URL映射到指定的方法。")]),t._v(" "),a("p",[t._v("@Service业务逻辑层")]),t._v(" "),a("p",[t._v("应用于业务层，用于标注业务层组件,表示定义一个bean，自动根据bean的类名实例化一个首写字母为小写的bean。")]),t._v(" "),a("p",[t._v("@Repository持久层")]),t._v(" "),a("p",[t._v("用于标注数据访问组件，即DAO组件，表示将Dao类声明为bean")]),t._v(" "),a("p",[t._v("@Repository 只能标注在 DAO 类，因为该注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型。")]),t._v(" "),a("p",[a("strong",[t._v("总结")])]),t._v(" "),a("p",[a("code",[t._v("@Component")]),t._v(", "),a("code",[t._v("@Service")]),t._v(", "),a("code",[t._v("@Controller")]),t._v(", "),a("code",[t._v("@Repository")]),t._v("是spring注解，注解后可以被spring框架所扫描并注入到spring容器来进行管理。虽然你可以全部使用"),a("code",[t._v("@Component")]),t._v("注解，但使用其他注解，则你的类更适合于通过工具进行处理或与其他方面相关联。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("@Component")]),t._v("是通用注解，其他三个注解是这个注解的衍生注解，并且具有了特定的功能。")]),t._v(" "),a("li",[a("code",[t._v("@Controller")]),t._v("层是spring-mvc的注解，用于标注控制层组件，并查看是否处理请求转发，重定向。")]),t._v(" "),a("li",[a("code",[t._v("@Service")]),t._v("层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。")]),t._v(" "),a("li",[a("code",[t._v("@Repository")]),t._v("注解在持久层中，标注 DAO 类，具有将数据库操作抛出的数据访问异常自动转换(封装)为spring的持久层异常的功能。")])]),t._v(" "),a("p",[t._v("用这些注解对应用进行分层之后，就能将请求处理，义务逻辑处理，数据库操作处理分离出来，为代码解耦，也方便了以后项目的维护和开发。")]),t._v(" "),a("h3",{attrs:{id:"_24-spring中-component和-bean的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-spring中-component和-bean的区别"}},[t._v("#")]),t._v(" 24.Spring中@Component和@Bean的区别")]),t._v(" "),a("p",[t._v("1、@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。")]),t._v(" "),a("p",[t._v("2、@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。")]),t._v(" "),a("p",[t._v("两者的目的是一样的，都是注册bean到Spring容器中。")]),t._v(" "),a("p",[t._v("区别：")]),t._v(" "),a("p",[t._v("@Component（@Controller、@Service、@Repository）通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。")]),t._v(" "),a("p",[t._v("而@Bean注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。")]),t._v(" "),a("p",[a("strong",[t._v("@Component 作用于类，@Bean作用于方法。")])]),t._v(" "),a("p",[t._v("总结：")]),t._v(" "),a("p",[a("strong",[t._v("@Component和@Bean都是用来注册Bean并装配到Spring容器中，但是Bean比Component的自定义性更强。可以实现一些Component实现不了的自定义加载类。")])]),t._v(" "),a("p",[t._v("@Bean示例：")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Configuration")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AppConfig")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Bean")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TransferService")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("transferService")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TransferServiceImpl")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"_25-spring-factories-springboot如何自动注入-装配-maven引入的第三方库jar"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-spring-factories-springboot如何自动注入-装配-maven引入的第三方库jar"}},[t._v("#")]),t._v(" 25.Spring.factories(SpringBoot如何自动注入(装配)Maven引入的第三方库jar)")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("理解自动装配的核心原理")])]),t._v(" "),a("li",[a("p",[t._v("能手写一个EnableAutoConfiguration注解")])]),t._v(" "),a("li",[a("p",[t._v("理解SPI机制的原理")]),t._v(" "),a("p",[a("strong",[t._v("第1章 集成Redis")]),t._v("\n1.引入依赖包")])])]),t._v(" "),a("div",{staticClass:"language-markup extra-class"},[a("pre",{pre:!0,attrs:{class:"language-markup"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("dependency")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("groupId")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("org.springframework.boot"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("groupId")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("artifactId")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("spring-boot-starter-data-redis"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("artifactId")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("dependency")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("p",[t._v("2.配置参数")]),t._v(" "),a("div",{staticClass:"language-markup extra-class"},[a("pre",{pre:!0,attrs:{class:"language-markup"}},[a("code",[t._v("spring.redis.host=192.168.8.74\nspring.redis.password=123456\nspring.redis.database=0\n")])])]),a("p",[t._v("3.controller")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("com"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("example"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("springbootvipjtdemo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("redisdemo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token import"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("springframework"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("beans"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("factory"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("annotation"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Autowired")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token import"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("springframework"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("redis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("core"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RedisTemplate")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token import"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("springframework"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("web"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bind"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("annotation"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GetMapping")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token import"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("springframework"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("web"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bind"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("annotation"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RequestMapping")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token import"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("springframework"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("web"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bind"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("annotation"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RequestParam")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token import"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("springframework"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("web"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bind"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("annotation"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RestController")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@RestController")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@RequestMapping")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/redis"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RedisController")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Autowired")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RedisTemplate")]),t._v(" redisTemplate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@GetMapping")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/save"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("save")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@RequestParam")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@RequestParam")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        redisTemplate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("opsForValue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"添加成功"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@GetMapping")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/get"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@RequestParam")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("redisTemplate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("opsForValue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("通过上面的案例，我们就能看出来，RedisTemplate这个类的bean对象，我们并没有通过XML的方式也没有通过注解的方式注入到IoC容器中去，但是我们就是可以通过@Autowired注解自动从容器里面拿到相应的Bean对象，再去进行属性注入。")]),t._v(" "),a("p",[t._v("最关键的要属@Import(AutoConfigurationImportSelector.class)，借助AutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件("),a("strong",[t._v("spring.factories")]),t._v(")的bean定义（如Java Config@Configuration配置）都加载到当前SpringBoot创建并使用的IoC容器。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/Users/kkxu/NodeProjects/ifan/ifan/images/image-20230717152629496.png",alt:"image-20230717152629496"}})]),t._v(" "),a("p",[a("strong",[t._v("SpringFactoriesLoader")]),t._v("\n其实SpringFactoriesLoader的底层原理就是借鉴于JDK的SPI机制，所以，在将SpringFactoriesLoader之前，我们现在发散一下SPI机制。")]),t._v(" "),a("p",[a("strong",[t._v("SPI")]),t._v("\nSPI ，全称为 Service Provider Interface，是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。这一机制为很多框架扩展提供了可能，比如在Dubbo、JDBC中都使用到了SPI机制。我们先通过一个很简单的例子来看下它是怎么用的。")]),t._v(" "),a("h3",{attrs:{id:"_26-springboot的自动装配原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-springboot的自动装配原理"}},[t._v("#")]),t._v(" "),a("strong",[t._v("26.SpringBoot的自动装配原理")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("SpringBootApplication注解是入口")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("@SpringBootConfiguration：继承了Configuration，表示当前是注解类")])]),t._v(" "),a("li",[a("p",[t._v("@EnableAutoConfiguration： 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助")])]),t._v(" "),a("li",[a("p",[t._v("@ComponentScan(excludeFilters = { // 扫描路径设置（具体使用待确认）\nComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义；并将这些bean定义加载到IoC容器中.")])]),t._v(" "),a("li",[a("p",[t._v("我们可以通过"),a("strong",[t._v("basePackages")]),t._v("等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。")]),t._v(" "),a("p",[t._v("注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages")])])])])]),t._v(" "),a("p",[a("strong",[t._v("SpringFactoriesLoader")])]),t._v(" "),a("p",[t._v("借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成！")]),t._v(" "),a("p",[t._v("SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件META-INF/spring.factories加载配置,加载工厂类。")]),t._v(" "),a("p",[t._v("SpringFactoriesLoader为Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader即需要传入工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件；")]),t._v(" "),a("p",[t._v("传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类。")]),t._v(" "),a("div",{staticClass:"language-markup extra-class"},[a("pre",{pre:!0,attrs:{class:"language-markup"}},[a("code",[t._v("public abstract class SpringFactoriesLoader {\n//...\n　　public static "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" List"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" loadFactories(Class"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" factoryClass, ClassLoader classLoader) {\n　　　　...\n　　}\n　　public static List"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" loadFactoryNames(Class"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" factoryClass, ClassLoader classLoader) {\n　　　　....\n　　}\n}1.2.3.4.5.6.7.8.9.\n")])])]),a("p",[t._v("复制")]),t._v(" "),a("p",[t._v("配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名\norg.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key,获取对应的一组@Configuration类!(https://dl-harmonyos.51cto.com/images/202207/036d3b788cb7864aaf5532dc0458db47c4c517.jpg)上图就是从SpringBoot的autoconfigure依赖包中的META-INF/spring.factories配置文件中摘录的一段内容，可以很好地说明问题。")]),t._v(" "),a("p",[t._v("（重点）所以，@EnableAutoConfiguration自动配置的魔法其实就变成了：")]),t._v(" "),a("p",[t._v("从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中\norg.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/Users/kkxu/NodeProjects/ifan/ifan/images/image-20230717153236810.png",alt:"image-20230717153236810"}})]),t._v(" "),a("h3",{attrs:{id:"_27-单点登录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_27-单点登录"}},[t._v("#")]),t._v(" 27.单点登录")]),t._v(" "),a("p",[t._v("单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一")]),t._v(" "),a("p",[t._v("SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统")]),t._v(" "),a("p",[t._v("SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过"),a("code",[t._v("passport")]),t._v("，子系统本身将不参与登录操作")]),t._v(" "),a("p",[t._v("当一个系统成功登录以后，"),a("code",[t._v("passport")]),t._v("将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被"),a("code",[t._v("passport")]),t._v("授权以后，会建立一个局部会话，在一定时间内可以无需再次向"),a("code",[t._v("passport")]),t._v("发起认证")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://camo.githubusercontent.com/e8a925d41d93b9bc35b77a9ce5a09740e42da226c3ca283e48fa127bf432fd80/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32623962306537302d386334622d313165622d383566362d3666616337376330633962332e706e67",alt:""}})]),t._v(" "),a("p",[t._v("上图有四个系统，分别是"),a("code",[t._v("Application1")]),t._v("、"),a("code",[t._v("Application2")]),t._v("、"),a("code",[t._v("Application3")]),t._v("、和"),a("code",[t._v("SSO")]),t._v("，当"),a("code",[t._v("Application1")]),t._v("、"),a("code",[t._v("Application2")]),t._v("、"),a("code",[t._v("Application3")]),t._v("需要登录时，将跳到"),a("code",[t._v("SSO")]),t._v("系统，"),a("code",[t._v("SSO")]),t._v("系统完成登录，其他的应用系统也就随之登录了")]),t._v(" "),a("p",[a("strong",[t._v("如何实现单点登录：")])]),t._v(" "),a("p",[t._v("方式1:")]),t._v(" "),a("p",[t._v("我们可以部署一个认证中心，用于专门处理登录请求的独立的 "),a("code",[t._v("Web")]),t._v("服务")]),t._v(" "),a("p",[t._v("用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 "),a("code",[t._v("token")]),t._v(" 写入 "),a("code",[t._v("Cookie")]),t._v("（注意这个 "),a("code",[t._v("Cookie")]),t._v("是认证中心的，应用系统是访问不到的）")]),t._v(" "),a("p",[t._v("应用系统检查当前请求有没有 "),a("code",[t._v("Token")]),t._v("，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心")]),t._v(" "),a("p",[t._v("由于这个操作会将认证中心的 "),a("code",[t._v("Cookie")]),t._v(" 自动带过去，因此，认证中心能够根据 "),a("code",[t._v("Cookie")]),t._v(" 知道用户是否已经登录过了")]),t._v(" "),a("p",[t._v("如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录")]),t._v(" "),a("p",[t._v("如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 "),a("code",[t._v("URL")]),t._v("，并在跳转前生成一个 "),a("code",[t._v("Token")]),t._v("，拼接在目标"),a("code",[t._v("URL")]),t._v(" 的后面，回传给目标应用系统")]),t._v(" "),a("p",[t._v("应用系统拿到 "),a("code",[t._v("Token")]),t._v("之后，还需要向认证中心确认下 "),a("code",[t._v("Token")]),t._v(" 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 "),a("code",[t._v("Token")]),t._v("写入"),a("code",[t._v("Cookie")]),t._v("，然后给本次访问放行。（注意这个 "),a("code",[t._v("Cookie")]),t._v(" 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 "),a("code",[t._v("Token")]),t._v("，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了")]),t._v(" "),a("p",[t._v("此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法")]),t._v(" "),a("p",[t._v("方式2:")]),t._v(" "),a("p",[t._v("可以选择将 "),a("code",[t._v("Session ID")]),t._v(" （或 "),a("code",[t._v("Token")]),t._v(" ）保存到浏览器的 "),a("code",[t._v("LocalStorage")]),t._v(" 中，让前端在每次向后端发送请求时，主动将"),a("code",[t._v("LocalStorage")]),t._v("的数据传递给服务端")]),t._v(" "),a("p",[t._v("这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 "),a("code",[t._v("Session ID")]),t._v("（或 "),a("code",[t._v("Token")]),t._v("）放在响应体中传递给前端")]),t._v(" "),a("p",[t._v("单点登录完全可以在前端实现。前端拿到 "),a("code",[t._v("Session ID")]),t._v("（或 "),a("code",[t._v("Token")]),t._v(" ）后，除了将它写入自己的 "),a("code",[t._v("LocalStorage")]),t._v(" 中之外，还可以通过特殊手段将它写入多个其他域下的 "),a("code",[t._v("LocalStorage")]),t._v(" 中")]),t._v(" "),a("h3",{attrs:{id:"_28-零拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_28-零拷贝"}},[t._v("#")]),t._v(" 28.零拷贝")]),t._v(" "),a("p",[t._v("https://juejin.cn/post/6995519558475841550")]),t._v(" "),a("p",[t._v("零拷贝（Zero-Copy）是一种 "),a("code",[t._v("I/O")]),t._v(" 操作优化技术，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间。其在 "),a("code",[t._v("FTP")]),t._v(" 或者 "),a("code",[t._v("HTTP")]),t._v(" 等协议中可以显著地提升性能。但是需要注意的是，并不是所有的操作系统都支持这一特性，目前只有在使用 "),a("code",[t._v("NIO")]),t._v(" 和 "),a("code",[t._v("Epoll")]),t._v(" 传输时才可使用该特性。")]),t._v(" "),a("p",[t._v("需要注意，它不能用于实现了数据加密或者压缩的文件系统上，只有传输文件的原始内容。这类原始内容也包括加密了的文件内容。")]),t._v(" "),a("p",[t._v("首先，期间共"),a("strong",[t._v("发生了 4 次用户态与内核态的上下文切换")]),t._v("，因为发生了两次系统调用，一次是 "),a("code",[t._v("read()")]),t._v(" ，一次是 "),a("code",[t._v("write()")]),t._v("，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。")]),t._v(" "),a("p",[t._v("上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。")]),t._v(" "),a("p",[t._v("其次，还"),a("strong",[t._v("发生了 4 次数据拷贝")]),t._v("，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("第一次拷贝")]),t._v("，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。")]),t._v(" "),a("li",[a("code",[t._v("第二次拷贝")]),t._v("，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。")]),t._v(" "),a("li",[a("code",[t._v("第三次拷贝")]),t._v("，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。")]),t._v(" "),a("li",[a("code",[t._v("第四次拷贝")]),t._v("，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。")])]),t._v(" "),a("p",[t._v("这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。")]),t._v(" "),a("p",[t._v("无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 "),a("code",[t._v("DMA copy")]),t._v("是都少不了的。因为两次 DMA 都是依赖硬件完成的。所以，所谓的零拷贝，都是为了减少 CPU copy 及减少了上下文的切换。")]),t._v(" "),a("p",[t._v("三个层次的文件拷贝优化：")]),t._v(" "),a("p",[t._v("零拷贝技术原理")]),t._v(" "),a("p",[t._v("零拷贝主要是用来解决操作系统在处理 I/O 操作时，频繁复制数据的问题。关于零拷贝主要技术有 "),a("code",[t._v("mmap+write")]),t._v("、"),a("code",[t._v("sendfile")]),t._v("和"),a("code",[t._v("splice")]),t._v("等几种方式。")]),t._v(" "),a("p",[t._v("虚拟内存")]),t._v(" "),a("p",[t._v("在了解零拷贝技术之前，先了解虚拟内存的概念。")]),t._v(" "),a("p",[t._v("所有现代操作系统都使用虚拟内存，使用虚拟地址取代物理地址，主要有以下几点好处：")]),t._v(" "),a("ul",[a("li",[t._v("多个虚拟内存可以指向同一个物理地址。")]),t._v(" "),a("li",[t._v("虚拟内存空间可以远远大于物理内存空间。")])]),t._v(" "),a("p",[t._v("利用上述的第一条特性可以优化，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样在 I/O 操作时就不需要来回复制了。")]),t._v(" "),a("p",[t._v("如下图展示了虚拟内存的原理。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93635b183ef49828843c0f50518449a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp",alt:"image-20210812181924274"}})]),t._v(" "),a("p",[t._v("mmap/write 方式")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("mmap/write")]),t._v("方式替换原来的传统I/O方式，就是利用了虚拟内存的特性。下图展示了"),a("code",[t._v("mmap/write")]),t._v("原理：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3747aca11884a1a85708c0163c79a99~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp",alt:"image-20210812201839908"}})]),t._v(" "),a("p",[t._v("整个流程的核心区别就是，把数据读取到内核缓冲区后，应用程序进行写入操作时，直接把内核的"),a("code",[t._v("Read Buffer")]),t._v("的数据复制到"),a("code",[t._v("Socket Buffer")]),t._v("以便写入，这次内核之间的复制也是需要CPU的参与的。")]),t._v(" "),a("p",[t._v("上述流程就是少了一个 CPU COPY，提升了 I/O 的速度。不过发现上下文的切换还是4次并没有减少，这是因为还是要应用程序发起"),a("code",[t._v("write")]),t._v("操作。")]),t._v(" "),a("blockquote",[a("p",[t._v("那能不能减少上下文切换呢?这就需要"),a("code",[t._v("sendfile")]),t._v("方式来进一步优化了。")])]),t._v(" "),a("p",[t._v("sendfile 方式")]),t._v(" "),a("p",[t._v("从 Linux 2.1 版本开始，Linux 引入了 "),a("code",[t._v("sendfile")]),t._v("来简化操作。"),a("code",[t._v("sendfile")]),t._v("方式可以替换上面的"),a("code",[t._v("mmap/write")]),t._v("方式来进一步优化。")]),t._v(" "),a("p",[a("code",[t._v("sendfile")]),t._v("将以下操作：")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("java\n复制代码  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mmap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n替换为：\njava\n复制代码 "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sendfile")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这样就减少了上下文切换，因为少了一个应用程序发起"),a("code",[t._v("write")]),t._v("操作，直接发起"),a("code",[t._v("sendfile")]),t._v("操作。")]),t._v(" "),a("p",[t._v("下图展示了"),a("code",[t._v("sendfile")]),t._v("原理：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d221a3a90a754ca9842f6324455638ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp",alt:"image-20210812201905046"}})]),t._v(" "),a("p",[a("code",[t._v("sendfile")]),t._v("方式只有三次数据复制（其中只有一次 CPU COPY）以及2次上下文切换。")]),t._v(" "),a("blockquote",[a("p",[t._v("那能不能把 CPU COPY 减少到没有呢？这样需要带有 "),a("code",[t._v("scatter/gather")]),t._v("的"),a("code",[t._v("sendfile")]),t._v("方式了。")])]),t._v(" "),a("p",[t._v("带有 scatter/gather 的 sendfile方式")]),t._v(" "),a("p",[t._v("Linux 2.4 内核进行了优化，提供了带有 "),a("code",[t._v("scatter/gather")]),t._v(" 的 sendfile 操作，这个操作可以把最后一次 "),a("code",[t._v("CPU COPY")]),t._v(" 去除。其原理就是在内核空间 Read BUffer 和 Socket Buffer 不做数据复制，而是将 Read Buffer 的内存地址、偏移量记录到相应的 Socket Buffer 中，这样就不需要复制。其本质和虚拟内存的解决方法思路一致，就是内存地址的记录。")]),t._v(" "),a("p",[t._v("下图展示了scatter/gather 的 sendfile 的原理：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/133430c1aedc4e22a6e340efc29e4239~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp",alt:"image-20210812201922193"}})]),t._v(" "),a("p",[t._v("scatter/gather 的 sendfile 只有两次数据复制（都是 DMA COPY）及 2 次上下文切换。CUP COPY 已经完全没有。不过这一种收集复制功能是需要硬件及驱动程序支持的。")]),t._v(" "),a("p",[t._v("splice 方式")]),t._v(" "),a("p",[a("code",[t._v("splice")]),t._v(" 调用和"),a("code",[t._v("sendfile")]),t._v(" 非常相似，用户应用程序必须拥有两个已经打开的文件描述符，一个表示输入设备，一个表示输出设备。与"),a("code",[t._v("sendfile")]),t._v("不同的是，"),a("code",[t._v("splice")]),t._v("允许任意两个文件互相连接，而并不只是文件与"),a("code",[t._v("socket")]),t._v("进行数据传输。对于从一个文件描述符发送数据到"),a("code",[t._v("socket")]),t._v("这种特例来说，一直都是使用"),a("code",[t._v("sendfile")]),t._v("系统调用，而"),a("code",[t._v("splice")]),t._v("一直以来就只是一种机制，它并不仅限于"),a("code",[t._v("sendfile")]),t._v("的功能。也就是说 sendfile 是 splice 的一个子集。")]),t._v(" "),a("p",[t._v("在 Linux 2.6.17 版本引入了 splice，而在 Linux 2.6.23 版本中， sendfile 机制的实现已经没有了，但是其 API 及相应的功能还在，只不过 API 及相应的功能是利用了 splice 机制来实现的。")]),t._v(" "),a("p",[t._v("和 sendfile 不同的是，splice 不需要硬件支持。")]),t._v(" "),a("p",[t._v("总结")]),t._v(" "),a("p",[t._v("无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 "),a("code",[t._v("DMA copy")]),t._v("是都少不了的。因为两次 DMA 都是依赖硬件完成的。所以，所谓的零拷贝，都是为了减少 CPU copy 及减少了上下文的切换。")]),t._v(" "),a("h3",{attrs:{id:"_29-tcp建立连接为什么是三次握手-而不是两次或四次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_29-tcp建立连接为什么是三次握手-而不是两次或四次"}},[t._v("#")]),t._v(" 29.TCP建立连接为什么是三次握手，而不是两次或四次？")]),t._v(" "),a("ul",[a("li",[t._v("三次握手才可以阻止重复历史连接的初始化（主要原因）")]),t._v(" "),a("li",[t._v("三次握手才可以同步双方的初始序列号")]),t._v(" "),a("li",[t._v("三次握手才可以避免资源浪费")])]),t._v(" "),a("h3",{attrs:{id:"_30-tcp四次挥手为什么有时会是三次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_30-tcp四次挥手为什么有时会是三次挥手"}},[t._v("#")]),t._v(" 30.TCP四次挥手为什么有时会是三次挥手？")]),t._v(" "),a("p",[t._v("当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。")]),t._v(" "),a("p",[a("strong",[t._v("所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。")]),t._v("（ACK不携带数据，浪费网络资源，TCP往往会延迟一段时间放松ACK，如果再延迟这短时间内，发送ACK这侧的服务器或者客户端有数据要发送，就可以一起发送了，节约了网络资源。）")]),t._v(" "),a("h3",{attrs:{id:"_31-如何对app做安全测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_31-如何对app做安全测试"}},[t._v("#")]),t._v(" 31.如何对app做安全测试")]),t._v(" "),a("p",[t._v("任意用户登录")]),t._v(" "),a("p",[t._v("日志安全")]),t._v(" "),a("p",[t._v("值符绕过")]),t._v(" "),a("p",[t._v("信息泄漏")]),t._v(" "),a("p",[t._v("权限问题")])])}),[],!1,null,null,null);a.default=n.exports}}]);