(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{371:function(_,v,t){"use strict";t.r(v);var a=t(14),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"链路层与局域网"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链路层与局域网"}},[_._v("#")]),_._v(" 链路层与局域网")]),_._v(" "),v("p",[_._v("运行链路层协议的任何设备均称为节点(node) 。节点包括主机、路由器、交换机和WiFi接入点 (在第7章中讨论)。我们也把沿着通信路径连接相邻节点的通信信道称为链路(link) 。")]),_._v(" "),v("h2",{attrs:{id:"链路层提供的服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链路层提供的服务"}},[_._v("#")]),_._v(" 链路层提供的服务")]),_._v(" "),v("p",[_._v("尽管任一链路层的基本服务都是将数据报通过单一通信链路从一个节点移动到相邻节点，但所提供的服务细节能够随着链路层协议的不同而变化。链路层协议能够提供的可能服务包括:")]),_._v(" "),v("p",[v("strong",[_._v("成帧")]),_._v("。在每个网络层数据报经链路传送之前，几乎所有的链路层协议都要将其用链路层帧封装起来。一个帧由一个数据字段和若干首部字段组成，其中 网络层数据报就插在数据字段中。帧的结构由链路层协议规定。")]),_._v(" "),v("p",[v("strong",[_._v("链路接入")]),_._v("。介质访问控制(Medium Access Control, MAC)协议规定了帧在链路上传输的规则。对于在链路的一端仅有一个发送方、链路的另一端仅有一个接收方的点对点链路，MAC协议比较简单(或者不存在)，即无论何吋链路空闲，发送方都能够发送帧。更有趣的情况是当多个节点共享单个广播链路时，即所谓多路访问MULPILE问题。这里，MAC协议用于协调多个节点的帧传输。")]),_._v(" "),v("p",[v("strong",[_._v("可靠交付")]),_._v("。当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据报。前面讲过，某些运输层协议(例如TCP)也提供可靠交付服务。与 运输层可靠交付服务类似，链路层的可靠交付服务通常是通过确认和重传取得的。链路层可靠交付服务通常用于易于产生高差错率的链路，例如无线 链路，其目的是本地(也就是在差错发生的链路上)纠正一个差错，而不是通过运 输层或应用层协议迫使进行端到端的数据重传。然而，对于低比特差错的链路，包括光纤、同轴电缆和许多双绞铜线链路, 链路层可靠交付可能会被认为是一种不必要的开销。由于这个原因，许多有线的链路层协议不提供可靠交付服务。")]),_._v(" "),v("p",[v("strong",[_._v("差错检测和纠正")]),_._v("。当帧中的一个比特作为1传输时，接收方节点中的链路层硬件可能不正确地将其判断为0,反之亦然。这种比特差错是由信号衰减和电磁噪声导 致的。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机 制来检测这样的比特差错。通过让发送节点在帧中包括差错检测比特，让接收节 点进行差错检查，以此来完成这项工作。第3章和第4章讲过，因特网的运输层和网络层也提供了有限形式的差错检测，即因特网检验和。链路层的差错检测通 常更复杂，并且用硬件实现。差错纠正类似于差错检测，区别在于接收方不仅能 检测帧中出现的比特差错，而且能够准确地确定帧中的差错出现的位置(并因此 纠正这些差错)。")]),_._v(" "),v("p",[_._v("链路层的主体部分是在网络适配器(network adapter) 中实现的，网络适配器有时也称为网络接口卡(Network Interface Card, NIC) o 位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务(成帧、链路接入、差错检测等)的专用芯片。")]),_._v(" "),v("p",[v("strong",[_._v("差错检测和纠正技术")])]),_._v(" "),v("p",[_._v("奇偶校验：也许差错检测最简单的方式就是用单个奇偶校验位 (parity bit) 。")]),_._v(" "),v("p",[_._v("采用单个奇偶校验位方式，接收方的操作也很简单。接收方只需要数一数接收的d + 1比特中1的数目即可。如果在采用偶校验方案中发现了奇数个值为1的比特，接收方知道 至少出现了一个比特差错。更精确的说法是，出现了奇数个比特差错。")]),_._v(" "),v("p",[v("strong",[_._v("多路访问联路和协议")])]),_._v(" "),v("p",[_._v("点对点链路(point-to-point link)由链路一端的单个发送方和链路另一端的单个接收方组成")]),_._v(" "),v("p",[_._v("点对点联路包括：点对点协议PPP协议和高级链路控制协议HDLC")]),_._v(" "),v("p",[_._v("广播链路(broadcastlink),它能够让多个发送 和接收节点都连接到相同的、单一的、共享的广播信道上。")]),_._v(" "),v("p",[_._v("广播协议中需要多路访问协议（multiple access protocol）")]),_._v(" "),v("h2",{attrs:{id:"多路访问控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多路访问控制"}},[_._v("#")]),_._v(" 多路访问控制")]),_._v(" "),v("p",[_._v("主要设计的协议有三种，分别为：")]),_._v(" "),v("ol",[v("li",[_._v("信道划分协议")]),_._v(" "),v("li",[_._v("随机访问协议")]),_._v(" "),v("li",[_._v("轮询协议")])]),_._v(" "),v("h3",{attrs:{id:"信道划分协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信道划分协议"}},[_._v("#")]),_._v(" "),v("strong",[_._v("信道划分协议")])]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[_._v("时分多路复用TDM")]),_._v("：TDM将时间划分为时间帧(time frame), 并进一步划分每个时间帧为N 个时隙slot。")]),_._v(" "),v("p",[_._v("TDM是有吸引力的，因为它消除了碰撞而且非常公平:每个节点在每个帧时间内得到了专用的传输速率砂Nbps。然而它有两个主要缺陷。首先，节点被限制于R/N bps的 平均速率，即使当它是唯一有分组要发送的节点时。其次，节点必须总是等待它在传输序 列中的轮次，即我们再次看到，即使它是唯一一个有帧要发送的节点。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("频分多路复用FDM")]),_._v("：FDM将R bps信道划分为不同的频段(每个频段具有R/N带宽)。FDM也有TDM同样的优点和缺点。它避 免了碰撞，在N个节点之间公平地划分了带宽。然而，FDM也有TDM所具有的主要缺 点，也就是限制一个节点只能使用R/7V的带宽，即使当它是唯一一个有分组要发送的节点时。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("码分多路复用CDMA")]),_._v("：TDM和FDM分別为节点分配时隙和频率，而 CDMA对每个节点分配一种不同的编码。然后每个 节点用它唯一的编码来对它发送的数据进行编码°如果精心选择这些编码，CDMA网络具有一种奇妙的特性，即不同的节点能够同时传输，并且它们各自相应的接收方仍能正确接 收发送方编码的数据比特(假设接收方知道发送方的编码)，而不在乎其他节点的干扰传 输。")])])]),_._v(" "),v("h3",{attrs:{id:"随机访问协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#随机访问协议"}},[_._v("#")]),_._v(" "),v("strong",[_._v("随机访问协议")])]),_._v(" "),v("p",[_._v("在随机接入协议中，一个传输节点总是以信道的全部速率(即Kbps)进行发送。当有碰撞时，涉及碰撞的每个节点反复地重发它 的 帧 (也就是分组)，到该帧无碰撞地通过为止。但是当一个节点经历一次碰撞时，它不必立刻重发该帧。相反，它在重发该帧之前等待一个随机时延。涉及碰撞的每个节点 独立地选择随机时延。")]),_._v(" "),v("h4",{attrs:{id:"纯aloha协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#纯aloha协议"}},[_._v("#")]),_._v(" 纯"),v("strong",[_._v("ALOHA协议")]),_._v(":")]),_._v(" "),v("p",[_._v("时隙ALOHA协议要求所有的节点同步它们的传输，以在每个时隙开始时开始传输。")]),_._v(" "),v("p",[_._v("在纯 ALOHA中，当一帧首次到达(即一个网络层数据报在发送节点从网络层传递下来)，节点立刻将该帧完整地传输进广播信道。如果一个传输的帧与一个或多个传输经历了碰撞，这 个节点将立即(在完全传输完它的碰撞帧之后)以概率卩重传该帧。否则，该节点等待一 个帧传输时间。在等待之后，它则以概率卩传输该帧，或者以概率1 -卩在另一个帧时间等待(保持空闲)。")]),_._v(" "),v("h4",{attrs:{id:"时隙aloha-最简单的随机接入协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#时隙aloha-最简单的随机接入协议"}},[_._v("#")]),_._v(" 时隙ALOHA（最简单的随机接入协议")]),_._v(" "),v("p",[_._v("在对时隙ALOHA的描述中，我们做下列假设:")]),_._v(" "),v("p",[_._v("• 所有帧由L 比特组成。")]),_._v(" "),v("p",[_._v("•时间被划分成长度为厶/R秒的时隙(这就是说，一个时隙等于传输一帧的时间)。")]),_._v(" "),v("p",[_._v("• 节点只在时隙起点开始传输帧。\n• 节点是同步的，每个节点都知道时隙何时开始。\n• 如果在一个时隙中有两个或者更多个帧碰撞，则所有节点在该时隙结束之前检测到该碰撞事件。")]),_._v(" "),v("p",[v("strong",[_._v("令P是一个概率，即一个在0和1之间的数。在每个节点中，时隙ALOHA的操作是简单的:")])]),_._v(" "),v("p",[_._v("• 当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧。\n• 如果没有碰撞，该节点成功地传输它的帧，从而不需要考虑重传该帧。")]),_._v(" "),v("p",[_._v("如果有碰撞，该节点在时隙结束之前检测到这次碰撞。该节点以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。")]),_._v(" "),v("p",[_._v("时隙ALOHA看起来有很多优点。与信道划分不同，当某节点是唯一活跃的节点时 (一个节点如果有帧要发送就认为它是活跃的)，时隙ALOHA允许该节点以全速R 连续传输。时隙ALOHA也是高度分散的，因为每个节点检测碰撞并独立地决定什么时候重传。")]),_._v(" "),v("h4",{attrs:{id:"载波侦听多路访问协议csma"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#载波侦听多路访问协议csma"}},[_._v("#")]),_._v(" "),v("strong",[_._v("载波侦听多路访问协议CSMA")])]),_._v(" "),v("p",[_._v("​\t\t\t1.载波侦听：即一个节点在传输前先听信道。如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后 开始传输。")]),_._v(" "),v("p",[_._v("​\t\t\t2.冲突检测：即当一个传输节点在传输时一直在侦听此信道。如果它检测到另 一个节点正在传输F扰帧，它就停止传输，在 重 复 “侦听-当空闲时传输”循环之前等待一段随机时间。")]),_._v(" "),v("p",[_._v("两种CSMA，一种是在"),v("strong",[_._v("载波侦听多路访问控制-冲突检测CSMA-CD和载波侦听多路访问控制-冲突避免CSMA-CA")])]),_._v(" "),v("p",[_._v("具有碰撞检测的载波侦听多路访问(CSMA/CD)：")]),_._v(" "),v("p",[_._v("图1 节点没有进行碰撞检测;即使已经出现了碰撞，B和D都将继续完整 地传输它们的帧。当某节点执行碰撞检测时，一旦它检测到碰撞将立即停止传输")]),_._v(" "),v("p",[_._v("重传："),v("strong",[_._v("二进制指数后退(binary exponential backoff)算法")]),_._v("，简练地解决了这个问题。特别是，当传输一个给定 帧时，在该帧经历了一连串的几次碰撞后，节点随机地从{0, 1, 2,...，2\" -1}中选择 一个K值。因此，一个帧经历的碰撞越多，K选择的间隔越大。对于以太网，一个节点等待的实际时间量是K・512比特时间(即发送512比特进入以太网所需时间量的K倍), 能够取的最大值在10以内'")]),_._v(" "),v("h3",{attrs:{id:"轮流协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#轮流协议"}},[_._v("#")]),_._v(" "),v("strong",[_._v("轮流协议")])]),_._v(" "),v("h4",{attrs:{id:"_1-轮询协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-轮询协议"}},[_._v("#")]),_._v(" 1."),v("strong",[_._v("轮询协议")])]),_._v(" "),v("p",[_._v("当只有一个节点活跃吋，该活跃节点具 有R bps的吞吐量;2当有M个节点活跃时，每个活跃节点的吞吐量接近R/M bps。ALO- HA和CSMA协议具备第一个特性，但不具备第二个特性。")]),_._v(" "),v("p",[_._v("第一种是轮询协 议(polling protocol)o轮询协议要求这些节点之一要被指定为主节点。主节点以循环的方 式轮询(poll)每个节点。特别是，主节点首先向节点1发送一个报文，告诉它(节点1) 能够传输的帧的最多数量。在节点1传输了某些帧后，主节点告诉节点2它(节点2)能 够传输的帧的最多数量。(主节点能够通过观察在信道上是否缺乏信号，来决定一个节点 何时完成了帧的发送。)上述过程以这种方式继续进行，主节点以循环的方式轮询了每个 节点。")]),_._v(" "),v("h4",{attrs:{id:"_2-令牌传递协议-token-passing-protocol"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-令牌传递协议-token-passing-protocol"}},[_._v("#")]),_._v(" 2.令牌传递协议(token-passing protocol)")]),_._v(" "),v("p",[_._v("在这种协议中没有主节点。一个称为令牌(token) 的小的特殊帧在节点之间以某种固定的次序进行交换。例如，节点1可能总是把令牌发送给节点2 ,节点2可能总是把令牌发送给节点3 ,而节点N可能总是把令牌发送给节点1。当一个节点收到令牌时，仅当它有一些帧要发送时，它才持有这个令牌;否则，它立即向下一个节点转发该令牌。当一个节点收到令牌时，如果它确实有帧要传输，它发送最大数目的帧数，然后把令牌转发给下一个节点。令牌传递是分散的，并有很高的效率。但是它也有自己的一些问题。例如，一个节点的故障可能会使整个信道崩溃。或者如果一个节点偶然忘记了释放令牌，则必须调用某些恢复步骤使令牌返回到循环中来。")]),_._v(" "),v("p",[v("strong",[_._v("轮流协议存在单点失效问题")])]),_._v(" "),v("h2",{attrs:{id:"链路层寻址与arp地址解析协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链路层寻址与arp地址解析协议"}},[_._v("#")]),_._v(" 链路层寻址与ARP地址解析协议")]),_._v(" "),v("p",[_._v("主机和路由器具有链路层地址，即MAC地址（介质访问控制）")]),_._v(" "),v("h3",{attrs:{id:"_1-mac地址"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-mac地址"}},[_._v("#")]),_._v(" 1.MAC地址")]),_._v(" "),v("p",[_._v("事实上，并不是主机或路由器具有链路层地址，而是它们的适配器(即网络接口)具有链路层地址。因此，具有多个网络接口的主机或路由器将具有与之相关联的多个链路层地址，就像它也具有与之相关联的多个IP地址一样。")]),_._v(" "),v("p",[_._v("MAC地址长度为6字节，共有2的48次方个可能的MAC地址")]),_._v(" "),v("p",[_._v("当某适配器要向某些目的适配器发送一个帧时，发送适配器将目的适配器的MAC地 址插入到该帧中，并将该帧发送到局域网上。如我们马上要看到的那样，一台交换机偶尔将一个入帧广播到它的所有接口。我们将在第7章中看到802. 11也广播帧。"),v("strong",[_._v("因此一块适 配器可以接收一个并非向它寻址的帧。"),v("strong",[_._v("这样，当适配器接收到一个帧时，将")]),_._v("检查该帧中的 目的MAC地址是否与它自己的MAC地址匹配")]),_._v("。如果匹配，该适配器提取出封装的数据 报，并将该数据报沿协议栈向上传递。如果不匹配，该适配器丢弃该帧，而不会向上传递该网络层数据报。所以，仅当收到该帧时，才会中断目的地。")]),_._v(" "),v("p",[_._v("MAC广播地址：FF_FF_FF_FF_FF_FF")]),_._v(" "),v("h3",{attrs:{id:"_2-地址解析协议arp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-地址解析协议arp"}},[_._v("#")]),_._v(" 2.地址解析协议ARP")]),_._v(" "),v("p",[_._v("网络层地址(例如，因特网的IP地址)和链路层地址(即 MAC地址)，所 以需要在它们之间进行转换")]),_._v(" "),v("p",[v("img",{attrs:{src:"/Users/kkxu/NodeProjects/ifan/ifan/images/image-20230602201803698.png",alt:"image-20230602201803698"}})]),_._v(" "),v("p",[_._v("ARP"),v("strong",[_._v("协议适用于一个子网中")])]),_._v(" "),v("p",[_._v("每台主机或路由器在 其内存中具有一个"),v("strong",[_._v("ARP表(ARP table),这张表包含IP地址到MAC地址的映射关系。")])]),_._v(" "),v("p",[_._v("假设222. 222. 222. 220要向222.222.222.222 发送数据报。在这种情况下，发送方用ARP协议来解析这个地址。首先，发送方构造一 个"),v("strong",[_._v("称为ARP分组(ARP packet)的特殊分组")]),_._v("。一个ARP分组有几个字段，包括"),v("strong",[_._v("发送和接收IP地址及MAC地址")]),_._v("。ARP查询分组和响应分组都具有相同的格式。ARP查询分组的目的是询问"),v("strong",[_._v("子网")]),_._v("上所有其他主机和路由器，以确定对应于要解析的IP地址的那个MAC 地址。")]),_._v(" "),v("p",[_._v("回到我们的例子上来，222. 222. 222. 220向它的适配器传递一个ARP查询分组，并且 指示适配器应该用"),v("strong",[_._v("MAC播地址(即FF-FF-FF-FF-FF-FF)"),v("strong",[_._v("来发送这个分组。这")]),_._v("些ARP模块中的每个都检查它的IP地址是否与ARP分组中的目的IP地址 相匹配")]),_._v("。与之匹配的一个给査询主机发送回一个带有所希望映射的"),v("strong",[_._v("响应ARP分组")]),_._v("。然后 查询主机222. 222. 222. 220能够更新它的ARP表，并发送它的1P数据报，该数据报封装 在一个链路层帧中，并且该帧的目的MAC就是对先前ARP请求进行响应的主机或路由器的 MAC地址。")]),_._v(" "),v("p",[v("strong",[_._v("查询ARP是广播帧，响应ARP是标准帧。")])]),_._v(" "),v("p",[_._v("数据报传播过程中IP地址不会改变，但是MAC地址会随着数据帧的解封装和组帧成帧发生变化，每一段链路均不相同。")]),_._v(" "),v("h3",{attrs:{id:"_3-交换机与路由器的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-交换机与路由器的比较"}},[_._v("#")]),_._v(" 3."),v("strong",[_._v("交换机与路由器的比较")])]),_._v(" "),v("p",[_._v("路由器是使用网络层地址转发分组的存储转发分组交换 机")]),_._v(" "),v("p",[_._v("交换机是使用MAC地址转发帧的存储转发帧交换 机")]),_._v(" "),v("h3",{attrs:{id:"_4-web页面请求过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-web页面请求过程"}},[_._v("#")]),_._v(" 4.web页面请求过程")]),_._v(" "),v("h4",{attrs:{id:"准备-dhcp-udp、ip和以太网"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#准备-dhcp-udp、ip和以太网"}},[_._v("#")]),_._v(" 准备:DHCP. UDP、IP和以太网")]),_._v(" "),v("ol",[v("li",[_._v("Bob的便携机所采取的一个网络相关的动作是运行"),v("strong",[_._v("DHCP")]),_._v("协议, 以从本地DHCP服务器获得一个IP地址以及其他信息。")]),_._v(" "),v("li",[_._v("Bob便携机上的操作系统生成一个DHCP请求报，并将这个报文放 入具有目的端口 67 (DHCP服务器)和源端口 68 (DHCP客户)的"),v("strong",[_._v("UDP报文段")]),_._v("该UDP报文段则被放置在一个具有"),v("strong",[_._v("广播IP")]),_._v("目的地址(255.255.255.255)和源IP地址 0. 0. 0. 0的IP数据报，因为Bob的便携机还没有一个IP地址。")]),_._v(" "),v("li",[_._v("包含DHCP请求报文的IP数据报则被放置在以太网帧中(6.4.2节)。该以太网 帧具有目的"),v("strong",[_._v("MAC地址")]),_._v("FF:FF:FF:FF:FF:FF,使该帧将广播（"),v("strong",[_._v("ARP地址解析协议")]),_._v("）到与交换机连接的所有设备(如果顺利的话也包括DHCP服务器);该帧的源MAC地址是Boh便携机的MAC地址 00: 16: D3:23:68:8A。")]),_._v(" "),v("li",[_._v("包含DHCP请求的广播以太网帧是第一个由Bob便携机发送到以太网交换机的帧。 该交换机在所有的出端口广播入帧，包括连接到路由器的端口。")]),_._v(" "),v("li",[_._v("路由器在它的具有MAC地址OO:22:6B:45:1F的接口接收到该广播以太网帧，该帧中包含DHCP请求，并且从该以太网帧中抽取出IP数据报。该数据报的广播IP目的地址指示了这个IP数据报应当由在该节点的高层协议处理，因此该数据报的载荷(一个 UDP报文段)被分解(3.2节)向上到达UDP, DHCP请求报文从此UDP报文段中抽取出来。此时DHCP服务器有了 DHCP请求报文。")]),_._v(" "),v("li",[_._v("我们假设运行在路由器中的DHCP服务器能够以CIDR (4.3.3节)块68. 85. 2. 0/24分配IP地址。所以本例中，在学校内使用的所有IP地址都在Comcast的地址块中。我 们假设DHCP服务器分配地址68. 85. 2. 101给Bob的便携机。DHCP服务器生成包含这个 IP地址以及DNS服务器的1P地址(68.87.71.226)、默认网关路由器的IP地址(6& 85. 2. 1)和子网块(68.85.2.0/24)(等价为“网络掩码”)的一个DHCP ACK报文 (4.3.3节)。该DHCP报文被放入一个UDP报文段中，UDP报文段被放入一个IP数据报 中，IP数据报再被放入一个以太网帧中。这个以太网帧的源MAC地址是路由器连到归属, 目的MAC地址是Bob便携机的MAC地址 (00:16:D3:23:68:8A)。")]),_._v(" "),v("li",[_._v("包含DHCP ACK的以太网帧由路由器发送给交换机。因为交换机是自学习的，并且先前从Bob便携机收到(包含DHCP请求的)以太网帧，所以该交换机 知道寻址到00: 16:D3:23:68:8A的帧仅从通向Bob便携机的输岀端口转发。")]),_._v(" "),v("li",[_._v("Bob便携机接收到包含DHCP ACK的以太网帧，从该以太网帧中抽取IP数据报, 从IP数据报中抽取UDP报文段，从UDP报文段抽取DHCP ACK报文。Bob的DHCP客户 则记录下它的IP地址和它的DNS服务器的IP地址。")])]),_._v(" "),v("h4",{attrs:{id:"仍在准备-dns和arp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#仍在准备-dns和arp"}},[_._v("#")]),_._v(" 仍在准备:DNS和ARP")]),_._v(" "),v("p",[_._v("1.当Bob将www. google, com的URL键入其Web浏览器时，他开启了一长串事件，这将 导致谷歌主页最终显示在其Web浏览器上。Bob的Web浏览器通过生成一个"),v("strong",[_._v("TCP套接字")]),_._v(" 开始了该过程，套接字用于向www. google, com发送HTTP请求。为了生成该套接字，Bob便携机将需要知道www. google, com的IP地址。使用DNS协议提供这种名字到IP地址的转换服务。")]),_._v(" "),v("h4",{attrs:{id:"web客户-服务器交互-tcp和http"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#web客户-服务器交互-tcp和http"}},[_._v("#")]),_._v(" Web客户-服务器交互:TCP和HTTP")]),_._v(" "),v("p",[_._v("TCP三次握手 TCP SYN  HTTP 请求：HTTP响应")])])}),[],!1,null,null,null);v.default=s.exports}}]);