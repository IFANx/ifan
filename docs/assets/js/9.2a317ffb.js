(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{280:function(v,a,_){"use strict";_.r(a);var t=_(14),s=Object(t.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"jvm相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm相关"}},[v._v("#")]),v._v(" JVM相关")]),v._v(" "),a("p",[a("strong",[v._v("1、Java 为什么能一次编写，处处运行？")])]),v._v(" "),a("p",[v._v("各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石。实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。")]),v._v(" "),a("p",[v._v("使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言。")]),v._v(" "),a("p",[a("img",{attrs:{src:"http://8.130.25.175:8080/img/20210610235143166.png",alt:""}})]),v._v(" "),a("p",[v._v("Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。因此，有一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础。")]),v._v(" "),a("p",[v._v("总结：")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("虚拟机不绑定java语言")])]),v._v(" "),a("li",[a("p",[v._v("虚拟机并不关心Class的来源是何种语言")])]),v._v(" "),a("li",[a("p",[v._v("字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大")])])]),v._v(" "),a("p",[a("strong",[v._v("2、JVM 是什么？")])]),v._v(" "),a("p",[v._v("JVM是Java Virtual Machine（Java虚拟机）的缩写，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。由"),a("strong",[v._v("一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域等")]),v._v("组成。JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“"),a("strong",[v._v("一次编译，到处运行的")]),v._v("”原因。")]),v._v(" "),a("h2",{attrs:{id:"二、jre、jdk和jvm的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、jre、jdk和jvm的关系"}},[v._v("#")]),v._v(" 二、JRE、JDK和JVM的关系")]),v._v(" "),a("p",[v._v("**JRE（Java Runtime Environment， Java运行环境）**是Java平台，所有的程序都要在JRE下才能够运行。包括JVM和Java核心类库和支持文件。")]),v._v(" "),a("p",[v._v("**JDK（Java Development Kit，Java开发工具包）**是用来编译、调试Java程序的开发工具包。包括Java工具（javac/java/jdb等）和Java基础的类库 java API。")]),v._v(" "),a("p",[v._v("**JVM（Java Virtual Machine， Java虚拟机）**是JRE的一部分。JVM主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。Java语言是跨平台运行的，"),a("strong",[v._v("不同的操作系统会有不同的JVM映射规则，使之与操作系统无关，完成跨平台性")]),v._v("。")]),v._v(" "),a("p",[v._v("JRE，JDK，JVM关系")]),v._v(" "),a("p",[a("img",{attrs:{src:"http://8.130.25.175:8080/img/image-20230523212953512.png",alt:"image-20230523212953512"}})]),v._v(" "),a("p",[v._v("总结：使用JDK（调用JAVA API）开发JAVA程序后，通过JDK中的编译程序（javac）将Java程序编译为Java字节码，在JRE上运行这些字节码，JVM会解析并映射到真实操作系统的CPU指令集和OS的系统调用。")]),v._v(" "),a("p",[a("strong",[v._v("3、HotSpot 是什么？")])]),v._v(" "),a("p",[v._v("提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。")]),v._v(" "),a("p",[v._v("SUN的JDK版本从1.3.1开始运用HotSpot虚拟机， 2006年底开源，主要使用C++实现，JNI接口部分用C实现。")]),v._v(" "),a("p",[v._v("Java原先是把源代码编译为字节码在虚拟机执行，这样执行速度较慢。而HotSpot将常用的部分代码编译为本地(原生，native)代码，这样显着提高了性能。")]),v._v(" "),a("p",[v._v("HotSpot基础知识")]),v._v(" "),a("p",[v._v("HotSpot包括一个解释器和两个编译器（client 和 server，二选一的），解释与编译混合执行模式，默认启动解释执行。")]),v._v(" "),a("p",[v._v("编译器：java源代码被编译器编译成class文件（字节码），java字节码在运行时可以被动态编译（JIT）成本地代码(前提是解释与编译混合执行模式且虚拟机不是刚启动时)。")]),v._v(" "),a("p",[v._v("解释器： 解释器用来解释class文件（字节码），java是解释语言（书上这么说的）。")]),v._v(" "),a("p",[a("strong",[v._v("4、JVM 内存区域分类哪些？")])]),v._v(" "),a("p",[a("strong",[v._v("5、堆和栈区别是什么？")])]),v._v(" "),a("p",[a("strong",[v._v("6、JVM 哪块内存区别不会发生内存溢出？")])]),v._v(" "),a("p",[a("strong",[v._v("7、什么情况下会发生栈内存溢出？")])]),v._v(" "),a("p",[a("strong",[v._v("8、对象都是在堆上分配的吗？")])]),v._v(" "),a("p",[a("strong",[v._v("9、你怎么理解强、软、弱、虚引用？")])]),v._v(" "),a("p",[a("strong",[v._v("10、常用的 JVM 参数有哪些？")])]),v._v(" "),a("p",[a("strong",[v._v("11、Java 8 中的内存结构有什么变化？")])]),v._v(" "),a("p",[a("strong",[v._v("12、Java 8 中的永久代为什么被移除了？")])]),v._v(" "),a("p",[a("strong",[v._v("13、什么是类加载器？")])]),v._v(" "),a("p",[a("strong",[v._v("14、类加载器的分类及作用？")])]),v._v(" "),a("p",[a("strong",[v._v("15、什么是双亲委派模型？")])]),v._v(" "),a("p",[a("strong",[v._v("16、为什么要打破双亲委派模型？")])]),v._v(" "),a("p",[a("strong",[v._v("17、可以自定义一个 java.lang.String 吗？")])]),v._v(" "),a("p",[a("strong",[v._v("18、什么是 JVM 内存模型？")])]),v._v(" "),a("p",[a("strong",[v._v("19、JVM 内存模型和 JVM 内存结构的区别？")])]),v._v(" "),a("p",[a("strong",[v._v("20、什么是指令重排序？")])]),v._v(" "),a("p",[a("strong",[v._v("21、内存屏障是什么？")])]),v._v(" "),a("p",[a("strong",[v._v("22、什么是 Happens-Before 原则？")])]),v._v(" "),a("p",[a("strong",[v._v("23、GC 是什么？为什么需要 GC？")])]),v._v(" "),a("p",[a("strong",[v._v("24、什么是 MinorGC 和 FullGC？")])]),v._v(" "),a("p",[a("strong",[v._v("25、一次完整的 GC 流程是怎样的？")])]),v._v(" "),a("p",[a("strong",[v._v("26、JVM 如何判断一个对象可被回收？")])]),v._v(" "),a("p",[a("strong",[v._v("27、常用的垃圾收集器有哪些？")])]),v._v(" "),a("p",[a("strong",[v._v("28、常用的垃圾回收算法有哪些？")])]),v._v(" "),a("p",[a("strong",[v._v("29、什么是内存泄漏？")])]),v._v(" "),a("p",[a("strong",[v._v("30、为什么会发生内存泄漏？")])]),v._v(" "),a("p",[a("strong",[v._v("31、如何防止内存泄漏？")])]),v._v(" "),a("p",[a("strong",[v._v("32、什么是直接内存？")])]),v._v(" "),a("p",[a("strong",[v._v("33、直接内存有什么用？")])]),v._v(" "),a("p",[a("strong",[v._v("34、怎样访问直接内存？")])]),v._v(" "),a("p",[a("strong",[v._v("35、常用的 JVM 调优命令有哪些？")])]),v._v(" "),a("p",[a("strong",[v._v("36、常用的 JVM 问题定位工具有哪些？")])]),v._v(" "),a("p",[a("strong",[v._v("37、常用的主流 JVM 虚拟机都有哪些？")])])])}),[],!1,null,null,null);a.default=s.exports}}]);