(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{351:function(_,v,t){"use strict";t.r(v);var r=t(14),e=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"什么是缓存雪崩、击穿、穿透"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存雪崩、击穿、穿透"}},[_._v("#")]),_._v(" 什么是缓存雪崩、击穿、穿透？")]),_._v(" "),v("p",[_._v("用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。")]),_._v(" "),v("p",[_._v("当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。")]),_._v(" "),v("p",[_._v("因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/37e4378d2edcb5e217b00e5f12973efd-20230309232858764.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("引入了缓存层，就会有缓存异常的三个问题，分别是"),v("strong",[_._v("缓存雪崩、缓存击穿、缓存穿透")]),_._v("。")]),_._v(" "),v("p",[_._v("这三个问题也是面试中很常考察的问题，我们不光要清楚地知道它们是怎么发生，还需要知道如何解决它们。")]),_._v(" "),v("p",[_._v("话不多说，"),v("strong",[_._v("发车！")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/61781cd6d82e4a0cc5f7521333049f0d.png",alt:"图片"}})]),_._v(" "),v("hr"),_._v(" "),v("h3",{attrs:{id:"缓存雪崩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/cluster/cache_problem.html#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("缓存雪崩")]),_._v(" "),v("p",[_._v("通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/e2b8d2eb5536aa71664772457792ec40-20230309232851699.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("那么，当"),v("strong",[_._v("大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机")]),_._v("时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是"),v("strong",[_._v("缓存雪崩")]),_._v("的问题。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/717343a0da7a1b05edab1d1cdf8f28e5.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("可以看到，发生缓存雪崩有两个原因：")]),_._v(" "),v("ul",[v("li",[_._v("大量数据同时过期；")]),_._v(" "),v("li",[_._v("Redis 故障宕机；")])]),_._v(" "),v("p",[_._v("不同的诱因，应对的策略也会不同。")]),_._v(" "),v("h4",{attrs:{id:"大量数据同时过期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#大量数据同时过期"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/cluster/cache_problem.html#%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%8C%E6%97%B6%E8%BF%87%E6%9C%9F",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("大量数据同时过期")]),_._v(" "),v("p",[_._v("针对大量数据同时过期而引发的缓存雪崩问题，常见的应对方法有下面这几种：")]),_._v(" "),v("ul",[v("li",[_._v("均匀设置过期时间；")]),_._v(" "),v("li",[_._v("互斥锁；")]),_._v(" "),v("li",[_._v("双 key 策略；")]),_._v(" "),v("li",[_._v("后台更新缓存；")])]),_._v(" "),v("p",[v("em",[_._v("1. 均匀设置过期时间")])]),_._v(" "),v("p",[_._v("如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，"),v("strong",[_._v("给这些数据的过期时间加上一个随机数")]),_._v("，这样就保证数据不会在同一时间过期。")]),_._v(" "),v("p",[v("em",[_._v("2. 互斥锁")])]),_._v(" "),v("p",[_._v("当业务线程在处理用户请求时，"),v("strong",[_._v("如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存")]),_._v("（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。")]),_._v(" "),v("p",[_._v("实现互斥锁的时候，最好设置"),v("strong",[_._v("超时时间")]),_._v("，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。")]),_._v(" "),v("p",[v("em",[_._v("3. 后台更新缓存")])]),_._v(" "),v("p",[_._v("业务线程不再负责更新缓存，缓存也不设置有效期，而是"),v("strong",[_._v("让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新")]),_._v("。")]),_._v(" "),v("p",[_._v("事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为"),v("strong",[_._v("当系统内存紧张的时候，有些缓存数据会被“淘汰”")]),_._v("，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。")]),_._v(" "),v("p",[_._v("解决上面的问题的方式有两种。")]),_._v(" "),v("p",[_._v("第一种方式，后台线程不仅负责定时更新缓存，而且也负责"),v("strong",[_._v("频繁地检测缓存是否有效")]),_._v("，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。")]),_._v(" "),v("p",[_._v("这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。")]),_._v(" "),v("p",[_._v("第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），"),v("strong",[_._v("通过消息队列发送一条消息通知后台线程更新缓存")]),_._v("，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。")]),_._v(" "),v("p",[_._v("在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的"),v("strong",[_._v("缓存预热")]),_._v("，后台更新缓存的机制刚好也适合干这个事情。")]),_._v(" "),v("h4",{attrs:{id:"redis-故障宕机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-故障宕机"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/cluster/cache_problem.html#redis-%E6%95%85%E9%9A%9C%E5%AE%95%E6%9C%BA",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("Redis 故障宕机")]),_._v(" "),v("p",[_._v("针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：")]),_._v(" "),v("ul",[v("li",[_._v("服务熔断或请求限流机制；")]),_._v(" "),v("li",[_._v("构建 Redis 缓存高可靠集群；")])]),_._v(" "),v("p",[v("em",[_._v("1. 服务熔断或请求限流机制")])]),_._v(" "),v("p",[_._v("因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动"),v("strong",[_._v("服务熔断")]),_._v("机制，"),v("strong",[_._v("暂停业务应用对缓存服务的访问，直接返回错误")]),_._v("，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。")]),_._v(" "),v("p",[_._v("服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作")]),_._v(" "),v("p",[_._v("为了减少对业务的影响，我们可以启用"),v("strong",[_._v("请求限流")]),_._v("机制，"),v("strong",[_._v("只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务")]),_._v("，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。")]),_._v(" "),v("p",[v("em",[_._v("2. 构建 Redis 缓存高可靠集群")])]),_._v(" "),v("p",[_._v("服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过"),v("strong",[_._v("主从节点的方式构建 Redis 缓存高可靠集群")]),_._v("。")]),_._v(" "),v("p",[_._v("如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。")]),_._v(" "),v("hr"),_._v(" "),v("h3",{attrs:{id:"缓存击穿"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/cluster/cache_problem.html#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("缓存击穿")]),_._v(" "),v("p",[_._v("我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。")]),_._v(" "),v("p",[_._v("如果缓存中的"),v("strong",[_._v("某个热点数据过期")]),_._v("了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是"),v("strong",[_._v("缓存击穿")]),_._v("的问题。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/acb5f4e7ef24a524a53c39eb016f63d4-20230309232840753.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。")]),_._v(" "),v("p",[_._v("应对缓存击穿可以采取前面说到两种方案：")]),_._v(" "),v("ul",[v("li",[_._v("互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。")]),_._v(" "),v("li",[_._v("不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；")])]),_._v(" "),v("hr"),_._v(" "),v("h3",{attrs:{id:"缓存穿透"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/cluster/cache_problem.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("缓存穿透")]),_._v(" "),v("p",[_._v("当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。")]),_._v(" "),v("p",[_._v("当用户访问的数据，"),v("strong",[_._v("既不在缓存中，也不在数据库中")]),_._v("，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是"),v("strong",[_._v("缓存穿透")]),_._v("的问题。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/b7031182f770a7a5b3c82eaf749f53b0-20230309232834574.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("缓存穿透的发生一般有这两种情况：")]),_._v(" "),v("ul",[v("li",[_._v("业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；")]),_._v(" "),v("li",[_._v("黑客恶意攻击，故意大量访问某些读取不存在数据的业务；")])]),_._v(" "),v("p",[_._v("应对缓存穿透的方案，常见的方案有三种。")]),_._v(" "),v("ul",[v("li",[_._v("第一种方案，非法请求的限制；")]),_._v(" "),v("li",[_._v("第二种方案，缓存空值或者默认值；")]),_._v(" "),v("li",[_._v("第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；")])]),_._v(" "),v("p",[_._v("第一种方案，非法请求的限制")]),_._v(" "),v("p",[_._v("当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。")]),_._v(" "),v("p",[_._v("第二种方案，缓存空值或者默认值")]),_._v(" "),v("p",[_._v("当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。")]),_._v(" "),v("p",[v("em",[_._v("第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。")])]),_._v(" "),v("p",[_._v("我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。")]),_._v(" "),v("p",[_._v("即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。")]),_._v(" "),v("p",[_._v("那问题来了，布隆过滤器是如何工作的呢？接下来，我介绍下。")]),_._v(" "),v("p",[_._v("布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。")]),_._v(" "),v("p",[_._v("布隆过滤器会通过 3 个操作完成标记：")]),_._v(" "),v("ul",[v("li",[_._v("第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；")]),_._v(" "),v("li",[_._v("第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。")]),_._v(" "),v("li",[_._v("第三步，将每个哈希值在位图数组的对应位置的值设置为 1；")])]),_._v(" "),v("p",[_._v("举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/86b0046c2622b2c4bda697f9bc0f5b28.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。"),v("strong",[_._v("当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中")]),_._v("。")]),_._v(" "),v("p",[_._v("布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时"),v("strong",[_._v("存在哈希冲突的可能性")]),_._v("，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。")]),_._v(" "),v("p",[_._v("所以，"),v("strong",[_._v("查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据")]),_._v("。")]),_._v(" "),v("hr"),_._v(" "),v("h3",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/cluster/cache_problem.html#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("总结")]),_._v(" "),v("p",[_._v("缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。")]),_._v(" "),v("p",[_._v("其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。")]),_._v(" "),v("p",[_._v("而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。")]),_._v(" "),v("p",[_._v("我这里整理了表格，你可以从下面这张表格很好的知道缓存雪崩、击穿和穿透的区别以及应对方案。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/061e2c04e0ebca3425dd75dd035b6b7b.png",alt:"图片"}})]),_._v(" "),v("h2",{attrs:{id:"数据库和缓存如何保证一致性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库和缓存如何保证一致性"}},[_._v("#")]),_._v(" 数据库和缓存如何保证一致性？")]),_._v(" "),v("p",[_._v("一天，老板说「最近公司的用户越来越多了，但是服务器的访问速度越来越差的，阿旺帮我优化下，"),v("strong",[_._v("做好了给你画个饼！")]),_._v("」。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/14952b672cc7573bdc9edaefbf204b3a.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("程序员阿旺听到老板口中的「画饼」后就非常期待，没有任何犹豫就接下了老板给的这个任务。")]),_._v(" "),v("p",[_._v("阿旺登陆到了服务器，经过一番排查后，确认服务器的"),v("strong",[_._v("性能瓶颈是在数据库")]),_._v("。")]),_._v(" "),v("p",[_._v("这好办，给服务器加上 Redis，让其作为数据库的缓存。")]),_._v(" "),v("p",[_._v("这样，在客户端请求数据时，如果能在缓存中命中数据，那就查询缓存，不用在去查询数据库，从而减轻数据库的压力，提高服务器的性能。")]),_._v(" "),v("h3",{attrs:{id:"先更新数据库-还是先更新缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#先更新数据库-还是先更新缓存"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("先更新数据库，还是先更新缓存？")]),_._v(" "),v("p",[_._v("阿旺有了这个想法后，就准备开始着手优化服务器，但是挡在在他前面的是这样的一个问题。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/b3bc9c4851ed731a36c9fee0f64264fe.png",alt:"图片"}})]),_._v(" "),v("p",[v("strong",[_._v("由于引入了缓存，那么在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在前后的问题")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("先更新数据库，再更新缓存；")]),_._v(" "),v("li",[_._v("先更新缓存，再更新数据库；")])]),_._v(" "),v("p",[_._v("阿旺没想到太多，他觉得最新的数据肯定要先更新数据库，这样才可以确保数据库里的数据是最新的，于是他就采用了「"),v("strong",[_._v("先更新数据库，再更新缓存")]),_._v("」的方案。")]),_._v(" "),v("p",[_._v("阿旺经过几个夜晚的折腾，终于「优化好了服务器」，然后就直接上线了，自信心满满跑去跟老板汇报。")]),_._v(" "),v("p",[_._v("老板不懂技术，自然也没多虑，就让后续阿旺观察下服务器的情况，如果效果不错，就跟阿旺谈画饼的事情。")]),_._v(" "),v("p",[_._v("阿旺观察了好几天，发现数据库的压力大大减少了，访问速度也提高了不少，心想这事肯定成的了。")]),_._v(" "),v("p",[_._v("好景不长，突然老板收到一个客户的投诉，客户说他刚发起了"),v("strong",[_._v("两次更新年龄的操作")]),_._v("，但是显示的年龄确还是第一次更新时的年龄，而第二次更新年龄并没有生效。")]),_._v(" "),v("p",[_._v("老板立马就找了阿旺，训斥着阿旺说：「"),v("em",[_._v("这么简单的更新操作，都有 bug？我脸往哪儿放？你的饼还要不要了？")]),_._v("」")]),_._v(" "),v("p",[_._v("听到自己准备到手的饼要没了的阿旺瞬间就慌了，立马登陆服务器排查问题，阿旺查询缓存和数据库的数据后发现了问题。")]),_._v(" "),v("p",[_._v("数据库的数据是客户第二次更新操作的数据，而缓存确还是第一次更新操作的数据，也就是"),v("strong",[_._v("出现了数据库和缓存的数据不一致的问题")]),_._v("。")]),_._v(" "),v("p",[_._v("这个问题可大了，阿旺经过一轮的分析，造成缓存和数据库的数据不一致的现象，是因为"),v("strong",[_._v("并发问题")]),_._v("！")]),_._v(" "),v("h4",{attrs:{id:"先更新数据库-再更新缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#先更新数据库-再更新缓存"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("先更新数据库，再更新缓存")]),_._v(" "),v("p",[_._v("举个例子，比如「请求 A 」和「请求 B 」两个请求，同时更新「同一条」数据，则可能出现这样的顺序：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/8febac10b14bed16cb96d1d944cd08da.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("A 请求先将数据库的数据更新为 1，然后在更新缓存前，请求 B 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 A 请求更新缓存为 1。")]),_._v(" "),v("p",[_._v("此时，数据库中的数据是 2，而缓存中的数据却是 1，"),v("strong",[_._v("出现了缓存和数据库中的数据不一致的现象")]),_._v("。")]),_._v(" "),v("h4",{attrs:{id:"先更新缓存-再更新数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#先更新缓存-再更新数据库"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98-%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("先更新缓存，再更新数据库")]),_._v(" "),v("p",[_._v("那换成「"),v("strong",[_._v("先更新缓存，再更新数据库")]),_._v("」这个方案，还会有问题吗？")]),_._v(" "),v("p",[_._v("依然还是存在并发的问题，分析思路也是一样。")]),_._v(" "),v("p",[_._v("假设「请求 A 」和「请求 B 」两个请求，同时更新「同一条」数据，则可能出现这样的顺序：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/454a8228a6549176ad7e0484fba3c92b.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("A 请求先将缓存的数据更新为 1，然后在更新数据库前，B 请求来了， 将缓存的数据更新为 2，紧接着把数据库更新为 2，然后 A 请求将数据库的数据更新为 1。")]),_._v(" "),v("p",[_._v("此时，数据库中的数据是 1，而缓存中的数据却是 2，"),v("strong",[_._v("出现了缓存和数据库中的数据不一致的现象")]),_._v("。")]),_._v(" "),v("p",[_._v("所以，"),v("strong",[_._v("无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象")]),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"先更新数据库-还是先删除缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#先更新数据库-还是先删除缓存"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BF%98%E6%98%AF%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("先更新数据库，还是先删除缓存？")]),_._v(" "),v("p",[_._v("阿旺定位出问题后，思考了一番后，决定在更新数据时，"),v("strong",[_._v("不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。")])]),_._v(" "),v("p",[_._v("阿旺想的这个策略是有名字的，是叫 "),v("strong",[_._v("Cache Aside 策略")]),_._v("，中文是叫旁路缓存策略。")]),_._v(" "),v("p",[_._v("该策略又可以细分为「读策略」和「写策略」。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/6e3db3ba2f829ddc14237f5c7c00e7ce.png",alt:"图片"}})]),_._v(" "),v("p",[v("strong",[_._v("写策略的步骤：")])]),_._v(" "),v("ul",[v("li",[_._v("更新数据库中的数据；")]),_._v(" "),v("li",[_._v("删除缓存中的数据。")])]),_._v(" "),v("p",[v("strong",[_._v("读策略的步骤：")])]),_._v(" "),v("ul",[v("li",[_._v("如果读取的数据命中了缓存，则直接返回数据；")]),_._v(" "),v("li",[_._v("如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。")])]),_._v(" "),v("p",[_._v("阿旺在想到「写策略」的时候，又陷入更深层次的思考，到底该选择哪种顺序呢？")]),_._v(" "),v("ul",[v("li",[_._v("先删除缓存，再更新数据库；")]),_._v(" "),v("li",[_._v("先更新数据库，再删除缓存。")])]),_._v(" "),v("p",[_._v("阿旺这次经过上次教训，不再「想当然」的乱选方案，因为老板这次给的饼很大啊，必须把握住。")]),_._v(" "),v("p",[_._v("于是阿旺用并发的角度来分析，看看这两种方案哪个可以保证数据库与缓存的数据一致性。")]),_._v(" "),v("h4",{attrs:{id:"先删除缓存-再更新数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#先删除缓存-再更新数据库"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98-%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("先删除缓存，再更新数据库")]),_._v(" "),v("p",[_._v("阿旺还是以用户表的场景来分析。")]),_._v(" "),v("p",[_._v("假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/cc208c2931b4e889d1a58cb655537767.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。")]),_._v(" "),v("p",[_._v("可以看到，"),v("strong",[_._v("先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题")]),_._v("。")]),_._v(" "),v("h4",{attrs:{id:"先更新数据库-再删除缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#先更新数据库-再删除缓存"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("先更新数据库，再删除缓存")]),_._v(" "),v("p",[_._v("继续用「读 + 写」请求的并发的场景来分析。")]),_._v(" "),v("p",[_._v("假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/1cc7401143e79383ead96582ac11b615.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。")]),_._v(" "),v("p",[_._v("从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，"),v("strong",[_._v("但是在实际中，这个问题出现的概率并不高")]),_._v("。")]),_._v(" "),v("p",[v("strong",[_._v("因为缓存的写入通常要远远快于数据库的写入")]),_._v("，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。")]),_._v(" "),v("p",[_._v("而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。")]),_._v(" "),v("p",[_._v("所以，"),v("strong",[_._v("「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的")]),_._v("。")]),_._v(" "),v("p",[_._v("而且阿旺为了确保万无一失，还给缓存数据加上了「"),v("strong",[_._v("过期时间")]),_._v("」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。")]),_._v(" "),v("p",[_._v("阿旺思考到这一步后，觉得自己真的是个小天才，因为他竟然想到了个「天衣无缝」的方案，他二话不说就采用了这个方案，又经过几天的折腾，终于完成了。")]),_._v(" "),v("p",[_._v("他自信满满的向老板汇报，已经解决了上次客户的投诉的问题了。老板觉得阿旺这小伙子不错，这么快就解决问题了，然后让阿旺在观察几天。")]),_._v(" "),v("p",[_._v("事情哪有这么顺利呢？结果又没过多久，老板又收到客户的投诉了，"),v("strong",[_._v("说自己明明更新了数据，但是数据要过一段时间才生效")]),_._v("，客户接受不了。")]),_._v(" "),v("p",[_._v("老板面无表情的找上阿旺，让阿旺尽快查出问题。")]),_._v(" "),v("p",[_._v("阿旺得知又有 Bug 就更慌了，立马就登录服务器去排查问题，查看日志后得知了原因。")]),_._v(" "),v("p",[_._v("「先更新数据库， 再删除缓存」其实是两个操作，前面的所有分析都是建立在这两个操作都能同时执行成功，而这次客户投诉的问题就在于，"),v("strong",[_._v("在删除缓存（第二个操作）的时候失败了，导致缓存中的数据是旧值")]),_._v("。")]),_._v(" "),v("p",[_._v("好在之前给缓存加上了过期时间，所以才会出现客户说的过一段时间才更新生效的现象，假设如果没有这个过期时间的兜底，那后续的请求读到的就会一直是缓存中的旧数据，这样问题就更大了。")]),_._v(" "),v("p",[_._v("所以新的问题来了，"),v("strong",[_._v("如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功？")])]),_._v(" "),v("p",[_._v("阿旺分析出问题后，慌慌张张的向老板汇报了问题。")]),_._v(" "),v("p",[_._v("老板知道事情后，又给了阿旺几天来解决这个问题，画饼的事情这次没有再提了。")]),_._v(" "),v("p",[v("strong",[_._v("阿旺会用什么方式来解决这个问题呢？")])]),_._v(" "),v("p",[v("strong",[_._v("老板画的饼事情，能否兑现给阿旺呢？")])]),_._v(" "),v("p",[_._v("预知后事，且听下回阿旺的故事。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/e51903be6ada20f87bb1c8015ba30631.png",alt:"图片"}})]),_._v(" "),v("h3",{attrs:{id:"小结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%B0%8F%E7%BB%93",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("小结")]),_._v(" "),v("p",[_._v("阿旺的事情就聊到这，我们继续说点其他。")]),_._v(" "),v("p",[_._v("「先更新数据库，再删除缓存」的方案虽然保证了数据库与缓存的数据一致性，但是每次更新数据的时候，缓存的数据都会被删除，这样会对缓存的命中率带来影响。")]),_._v(" "),v("p",[_._v("所以，"),v("strong",[_._v("如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况")]),_._v("。")]),_._v(" "),v("p",[_._v("但是这个方案前面我们也分析过，在两个更新请求并发执行的时候，会出现数据不一致的问题，因为更新数据库和更新缓存这两个操作是独立的，而我们又没有对操作做任何并发控制，那么当两个线程并发更新它们的话，就会因为写入顺序的不同造成数据的不一致。")]),_._v(" "),v("p",[_._v("所以我们得增加一些手段来解决这个问题，这里提供两种做法：")]),_._v(" "),v("ul",[v("li",[_._v("在更新缓存前先加个"),v("strong",[_._v("分布式锁")]),_._v("，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。")]),_._v(" "),v("li",[_._v("在更新完缓存时，给缓存加上较短的"),v("strong",[_._v("过期时间")]),_._v("，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。")])]),_._v(" "),v("p",[_._v("对了，针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「"),v("strong",[_._v("延迟双删")]),_._v("」。")]),_._v(" "),v("p",[_._v("延迟双删实现的伪代码如下：")]),_._v(" "),v("div",{staticClass:"language-text extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("#删除缓存\nredis.delKey(X)\n#更新数据库\ndb.update(X)\n#睡眠\nThread.sleep(N)\n#再删除缓存\nredis.delKey(X)\n")])])]),v("p",[_._v("加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。")]),_._v(" "),v("p",[_._v("所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。")]),_._v(" "),v("p",[_._v("但是具体睡眠多久其实是个"),v("strong",[_._v("玄学")]),_._v("，很难评估出来，所以这个方案也只是"),v("strong",[_._v("尽可能")]),_._v("保证一致性而已，极端情况下，依然也会出现缓存不一致的现象。")]),_._v(" "),v("p",[_._v("因此，还是比较建议用「先更新数据库，再删除缓存」的方案。")]),_._v(" "),v("hr"),_._v(" "),v("h3",{attrs:{id:"前情回顾"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前情回顾"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%89%8D%E6%83%85%E5%9B%9E%E9%A1%BE",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("前情回顾")]),_._v(" "),v("p",[_._v("上回程序员阿旺为了提升数据访问的性能，引入 Redis 作为 MySQL 缓存层，但是这件事情并不是那么简单，因为还要考虑 Redis 和 MySQL 双写一致性的问题。")]),_._v(" "),v("p",[_._v("阿旺经过一番周折，最终选用了「"),v("strong",[_._v("先更新数据库，再删缓存")]),_._v("」的策略，原因是这个策略即使在并发读写时，也能最大程度保证数据一致性。")]),_._v(" "),v("p",[_._v("聪明的阿旺还搞了个兜底的方案，就是给缓存加上了过期时间。")]),_._v(" "),v("p",[_._v("本以为就这样不会在出现数据一致性的问题，结果将功能上线后，老板还是收到用户的投诉「说自己明明更新了数据，但是数据要过一段时间才生效」，客户接受不了。")]),_._v(" "),v("p",[_._v("老板转告给了阿旺，阿旺得知又有 Bug 就更慌了，立马就登录服务器去排查问题，查看日志后得知了原因。")]),_._v(" "),v("p",[_._v("「先更新数据库， 再删除缓存」其实是两个操作，这次客户投诉的问题就在于，"),v("strong",[_._v("在删除缓存（第二个操作）的时候失败了，导致缓存中的数据是旧值，而数据库是最新值")]),_._v("。")]),_._v(" "),v("p",[_._v("好在之前给缓存加上了过期时间，所以才会出现客户说的过一段时间才更新生效的现象，假设如果没有这个过期时间的兜底，那后续的请求读到的就会一直是缓存中的旧数据，这样问题就更大了。")]),_._v(" "),v("p",[_._v("所以新的问题来了，"),v("strong",[_._v("如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功？")])]),_._v(" "),v("p",[_._v("阿旺分析出问题后，慌慌张张的向老板汇报了问题。")]),_._v(" "),v("p",[_._v("老板知道事情后，又给了阿旺几天来解决这个问题，画饼的事情这次没有再提了。")]),_._v(" "),v("ul",[v("li",[_._v("阿旺会用什么方式来解决这个问题呢？")]),_._v(" "),v("li",[_._v("老板画的饼事情，能否兑现给阿旺呢？")])]),_._v(" "),v("h3",{attrs:{id:"如何保证两个操作都能执行成功"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何保证两个操作都能执行成功"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E9%83%BD%E8%83%BD%E6%89%A7%E8%A1%8C%E6%88%90%E5%8A%9F",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("如何保证两个操作都能执行成功？")]),_._v(" "),v("p",[_._v("这次用户的投诉是因为在删除缓存（第二个操作）的时候失败了，导致缓存还是旧值，而数据库是最新值，造成数据库和缓存数据不一致的问题，会对敏感业务造成影响。")]),_._v(" "),v("p",[_._v("举个例子，来说明下。")]),_._v(" "),v("p",[_._v("应用要把数据 X 的值从 1 更新为 2，先成功更新了数据库，然后在 Redis 缓存中删除 X 的缓存，但是这个操作却失败了，这个时候数据库中 X 的新值为 2，Redis 中的 X 的缓存值为 1，出现了数据库和缓存数据不一致的问题。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/2a2ea2854bbc3ae8ae86d7da45fa32ee.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("那么，后续有访问数据 X 的请求，会先在 Redis 中查询，因为缓存并没有 诶删除，所以会缓存命中，但是读到的却是旧值 1。")]),_._v(" "),v("p",[_._v("其实不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据一致的问题。")]),_._v(" "),v("p",[_._v("问题原因知道了，该怎么解决呢？有两种方法：")]),_._v(" "),v("ul",[v("li",[_._v("重试机制。")]),_._v(" "),v("li",[_._v("订阅 MySQL binlog，再操作缓存。")])]),_._v(" "),v("p",[_._v("先来说第一种。")]),_._v(" "),v("h5",{attrs:{id:"重试机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重试机制"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("重试机制")]),_._v(" "),v("p",[_._v("我们可以引入"),v("strong",[_._v("消息队列")]),_._v("，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。")]),_._v(" "),v("ul",[v("li",[_._v("如果应用"),v("strong",[_._v("删除缓存失败")]),_._v("，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是"),v("strong",[_._v("重试机制")]),_._v("。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。")]),_._v(" "),v("li",[_._v("如果"),v("strong",[_._v("删除缓存成功")]),_._v("，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。")])]),_._v(" "),v("p",[_._v("举个例子，来说明重试机制的过程。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/a4440f0d572612e0832b903e4a62bd2b.png",alt:"图片"}})]),_._v(" "),v("h5",{attrs:{id:"订阅-mysql-binlog-再操作缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#订阅-mysql-binlog-再操作缓存"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E8%AE%A2%E9%98%85-mysql-binlog-%E5%86%8D%E6%93%8D%E4%BD%9C%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("订阅 MySQL binlog，再操作缓存")]),_._v(" "),v("p",[_._v("「"),v("strong",[_._v("先更新数据库，再删缓存")]),_._v("」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。")]),_._v(" "),v("p",[_._v("于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。")]),_._v(" "),v("p",[_._v("Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。")]),_._v(" "),v("p",[_._v("下图是 Canal 的工作原理：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/2ee2280e9f59b6b4879ebdec6eb0cf52.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("所以，"),v("strong",[_._v("如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。")])]),_._v(" "),v("h3",{attrs:{id:"老板发饼啦"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#老板发饼啦"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E8%80%81%E6%9D%BF%E5%8F%91%E9%A5%BC%E5%95%A6",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("老板发饼啦")]),_._v(" "),v("p",[_._v("阿旺由于对消息队列比较熟悉，所以他决定采用「消息队列来重试缓存的删除」的方案，来解决这次的用户问题。")]),_._v(" "),v("p",[_._v("经过几天几夜的操作，服务器搞定啦，立马向老板汇报工作。")]),_._v(" "),v("p",[_._v("老板让阿旺再观察些时间，如果没问题，到中秋节就商量“饼”的事情。")]),_._v(" "),v("p",[_._v("时间过的很快，中秋佳节到了，这期间一直都没有用户反馈数据不一致的问题。")]),_._v(" "),v("p",[_._v("老板见这次阿旺表现很好，没有再出现任何差错，服务器的访问性能也上来了，"),v("strong",[_._v("于是给阿旺发了这个超级大的月饼，你看这个饼又大又圆，就像你的代码又长又多。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/9e20ea7a0a6477c717cdfdc6a6642b28.png",alt:"图片"}})]),_._v(" "),v("p",[_._v("阿旺看到这个月饼，哭笑不得，没想到这就是老板画的饼，是真的很大饼。。。。")]),_._v(" "),v("p",[v("em",[_._v("以上故事纯属虚拟，如有巧合，以你为准")]),_._v("。")]),_._v(" "),v("h2",{attrs:{id:"读者提问"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#读者提问"}},[_._v("#")]),_._v(" "),v("a",{attrs:{href:"https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E8%AF%BB%E8%80%85%E6%8F%90%E9%97%AE",target:"_blank",rel:"noopener noreferrer"}},[_._v("#"),v("OutboundLink")],1),_._v("读者提问")]),_._v(" "),v("blockquote",[v("p",[_._v("为什么是删除缓存，而不是更新缓存呢？")])]),_._v(" "),v("p",[_._v("删除一个数据，相比更新一个数据更加轻量级，出问题的概率更小。在实际业务中，缓存的数据可能不是直接来自数据库表，也许来自多张底层数据表的聚合。")]),_._v(" "),v("p",[_._v("比如商品详情信息，在底层可能会关联商品表、价格表、库存表等，如果更新了一个价格字段，那么就要更新整个数据库，还要关联的去查询和汇总各个周边业务系统的数据，这个操作会非常耗时。 从另外一个角度，不是所有的缓存数据都是频繁访问的，更新后的缓存可能会长时间不被访问，所以说，从计算资源和整体性能的考虑，更新的时候删除缓存，等到下次查询命中再填充缓存，是一个更好的方案。")]),_._v(" "),v("p",[_._v("系统设计中有一个思想叫 Lazy Loading，适用于那些加载代价大的操作，删除缓存而不是更新缓存，就是懒加载思想的一个应用。")])])}),[],!1,null,null,null);v.default=e.exports}}]);