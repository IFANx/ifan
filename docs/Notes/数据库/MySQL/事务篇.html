<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事务隔离级别是怎么实现的？ | Notes</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="办法总比问题多">
    
    <link rel="preload" href="/ifan/assets/css/0.styles.d46f727e.css" as="style"><link rel="preload" href="/ifan/assets/js/app.1d8f04c4.js" as="script"><link rel="preload" href="/ifan/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/ifan/assets/js/66.e97c1fb7.js" as="script"><link rel="prefetch" href="/ifan/assets/js/10.9d2debbc.js"><link rel="prefetch" href="/ifan/assets/js/100.ce0650f4.js"><link rel="prefetch" href="/ifan/assets/js/11.b481b7e3.js"><link rel="prefetch" href="/ifan/assets/js/12.a1c93484.js"><link rel="prefetch" href="/ifan/assets/js/13.d78e499d.js"><link rel="prefetch" href="/ifan/assets/js/14.0d2150b9.js"><link rel="prefetch" href="/ifan/assets/js/15.01c694bf.js"><link rel="prefetch" href="/ifan/assets/js/16.d9b12807.js"><link rel="prefetch" href="/ifan/assets/js/17.43c1b0bd.js"><link rel="prefetch" href="/ifan/assets/js/18.903829cf.js"><link rel="prefetch" href="/ifan/assets/js/19.b1444637.js"><link rel="prefetch" href="/ifan/assets/js/20.efcc37f6.js"><link rel="prefetch" href="/ifan/assets/js/21.81da4056.js"><link rel="prefetch" href="/ifan/assets/js/22.2fa41b40.js"><link rel="prefetch" href="/ifan/assets/js/23.f343dea3.js"><link rel="prefetch" href="/ifan/assets/js/24.25c61120.js"><link rel="prefetch" href="/ifan/assets/js/25.9cb69cdb.js"><link rel="prefetch" href="/ifan/assets/js/26.1c1a1096.js"><link rel="prefetch" href="/ifan/assets/js/27.3e698f68.js"><link rel="prefetch" href="/ifan/assets/js/28.63f7f11e.js"><link rel="prefetch" href="/ifan/assets/js/29.8a400aa1.js"><link rel="prefetch" href="/ifan/assets/js/3.06be9fda.js"><link rel="prefetch" href="/ifan/assets/js/30.dd445b3e.js"><link rel="prefetch" href="/ifan/assets/js/31.21730518.js"><link rel="prefetch" href="/ifan/assets/js/32.698329c5.js"><link rel="prefetch" href="/ifan/assets/js/33.7fcf3386.js"><link rel="prefetch" href="/ifan/assets/js/34.3e9cf496.js"><link rel="prefetch" href="/ifan/assets/js/35.a5f742a8.js"><link rel="prefetch" href="/ifan/assets/js/36.5cdf7c9c.js"><link rel="prefetch" href="/ifan/assets/js/37.92b7c857.js"><link rel="prefetch" href="/ifan/assets/js/38.de0727c0.js"><link rel="prefetch" href="/ifan/assets/js/39.cd1d4ee5.js"><link rel="prefetch" href="/ifan/assets/js/4.0dd8aefa.js"><link rel="prefetch" href="/ifan/assets/js/40.e2d55b45.js"><link rel="prefetch" href="/ifan/assets/js/41.6fc8c625.js"><link rel="prefetch" href="/ifan/assets/js/42.f5669db3.js"><link rel="prefetch" href="/ifan/assets/js/43.0d002814.js"><link rel="prefetch" href="/ifan/assets/js/44.59193229.js"><link rel="prefetch" href="/ifan/assets/js/45.3933ef6d.js"><link rel="prefetch" href="/ifan/assets/js/46.1d702023.js"><link rel="prefetch" href="/ifan/assets/js/47.61263332.js"><link rel="prefetch" href="/ifan/assets/js/48.d1910cf7.js"><link rel="prefetch" href="/ifan/assets/js/49.ba295b07.js"><link rel="prefetch" href="/ifan/assets/js/5.14db227c.js"><link rel="prefetch" href="/ifan/assets/js/50.48945079.js"><link rel="prefetch" href="/ifan/assets/js/51.922c4a4a.js"><link rel="prefetch" href="/ifan/assets/js/52.90c41fbb.js"><link rel="prefetch" href="/ifan/assets/js/53.5b1ba980.js"><link rel="prefetch" href="/ifan/assets/js/54.8e84c44d.js"><link rel="prefetch" href="/ifan/assets/js/55.c277b13f.js"><link rel="prefetch" href="/ifan/assets/js/56.6d8a04a9.js"><link rel="prefetch" href="/ifan/assets/js/57.021c1663.js"><link rel="prefetch" href="/ifan/assets/js/58.099f7ab4.js"><link rel="prefetch" href="/ifan/assets/js/59.e19ec6bd.js"><link rel="prefetch" href="/ifan/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/ifan/assets/js/60.4ece97ff.js"><link rel="prefetch" href="/ifan/assets/js/61.72dd49dc.js"><link rel="prefetch" href="/ifan/assets/js/62.2212d8af.js"><link rel="prefetch" href="/ifan/assets/js/63.cd2240fd.js"><link rel="prefetch" href="/ifan/assets/js/64.266f0c5f.js"><link rel="prefetch" href="/ifan/assets/js/65.e5dd692b.js"><link rel="prefetch" href="/ifan/assets/js/67.c99c58ad.js"><link rel="prefetch" href="/ifan/assets/js/68.1c7b8840.js"><link rel="prefetch" href="/ifan/assets/js/69.b1ce3ceb.js"><link rel="prefetch" href="/ifan/assets/js/7.54611d34.js"><link rel="prefetch" href="/ifan/assets/js/70.742be5c0.js"><link rel="prefetch" href="/ifan/assets/js/71.50dee511.js"><link rel="prefetch" href="/ifan/assets/js/72.0653d81c.js"><link rel="prefetch" href="/ifan/assets/js/73.7a6b4080.js"><link rel="prefetch" href="/ifan/assets/js/74.200096d7.js"><link rel="prefetch" href="/ifan/assets/js/75.7ad0d457.js"><link rel="prefetch" href="/ifan/assets/js/76.4dae384f.js"><link rel="prefetch" href="/ifan/assets/js/77.d23e58be.js"><link rel="prefetch" href="/ifan/assets/js/78.30da3aa8.js"><link rel="prefetch" href="/ifan/assets/js/79.77a53c0e.js"><link rel="prefetch" href="/ifan/assets/js/8.3c3e2ed8.js"><link rel="prefetch" href="/ifan/assets/js/80.3b3507b6.js"><link rel="prefetch" href="/ifan/assets/js/81.0633d028.js"><link rel="prefetch" href="/ifan/assets/js/82.3bb840ca.js"><link rel="prefetch" href="/ifan/assets/js/83.71d297d6.js"><link rel="prefetch" href="/ifan/assets/js/84.67ddf266.js"><link rel="prefetch" href="/ifan/assets/js/85.88236cdb.js"><link rel="prefetch" href="/ifan/assets/js/86.c46c3552.js"><link rel="prefetch" href="/ifan/assets/js/87.ed3b9cdf.js"><link rel="prefetch" href="/ifan/assets/js/88.9717ca00.js"><link rel="prefetch" href="/ifan/assets/js/89.7dd65246.js"><link rel="prefetch" href="/ifan/assets/js/9.46fdf317.js"><link rel="prefetch" href="/ifan/assets/js/90.48ce955c.js"><link rel="prefetch" href="/ifan/assets/js/91.e833ee44.js"><link rel="prefetch" href="/ifan/assets/js/92.b9973f76.js"><link rel="prefetch" href="/ifan/assets/js/93.d07c4aae.js"><link rel="prefetch" href="/ifan/assets/js/94.6980a27c.js"><link rel="prefetch" href="/ifan/assets/js/95.4cb983e3.js"><link rel="prefetch" href="/ifan/assets/js/96.54504fb8.js"><link rel="prefetch" href="/ifan/assets/js/97.ce4e7809.js"><link rel="prefetch" href="/ifan/assets/js/98.7b7b8e3c.js"><link rel="prefetch" href="/ifan/assets/js/99.023a5792.js">
    <link rel="stylesheet" href="/ifan/assets/css/0.styles.d46f727e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ifan/" class="home-link router-link-active"><!----> <span class="site-name">Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ifan/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="what?" class="dropdown-title"><span class="title">what?</span> <span class="arrow down"></span></button> <button type="button" aria-label="what?" class="mobile-dropdown-title"><span class="title">what?</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/ifan/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="what?" class="dropdown-title"><span class="title">what?</span> <span class="arrow down"></span></button> <button type="button" aria-label="what?" class="mobile-dropdown-title"><span class="title">what?</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Maven</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>软件测试相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringBoot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>MySQL</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ifan/Notes/数据库/MySQL/事务篇.html" class="active sidebar-link">事务篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#事务有哪些特性" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/mvcc.html#事务有哪些特性)事务有哪些特性？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#并行事务会引发什么问题" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/mvcc.html#并行事务会引发什么问题)并行事务会引发什么问题？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#脏读" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/mvcc.html#脏读)脏读</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#不可重复读" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/mvcc.html#不可重复读)不可重复读</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#幻读" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/mvcc.html#幻读)幻读</a></li></ul></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#事务的隔离级别有哪些" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/mvcc.html#事务的隔离级别有哪些)事务的隔离级别有哪些？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#read-view-在-mvcc-里如何工作的" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-在-mvcc-里如何工作的)Read View 在 MVCC 里如何工作的？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#可重复读是如何工作的" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/mvcc.html#可重复读是如何工作的)可重复读是如何工作的？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#读提交是如何工作的" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/mvcc.html#读提交是如何工作的)读提交是如何工作的？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#总结" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/mvcc.html#总结)总结</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#什么是幻读" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/phantom.html#什么是幻读)什么是幻读？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#快照读是如何避免幻读的" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/phantom.html#快照读是如何避免幻读的)快照读是如何避免幻读的？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#当前读是如何避免幻读的" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/phantom.html#当前读是如何避免幻读的)当前读是如何避免幻读的？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#幻读被完全解决了吗" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/phantom.html#幻读被完全解决了吗)幻读被完全解决了吗？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#第一个发生幻读现象的场景" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/phantom.html#第一个发生幻读现象的场景)第一个发生幻读现象的场景</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#第二个发生幻读现象的场景" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/phantom.html#第二个发生幻读现象的场景)第二个发生幻读现象的场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#总结-2" class="sidebar-link">[#](https://xiaolincoding.com/mysql/transaction/phantom.html#总结)总结</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#xa事务-分布式事务" class="sidebar-link">XA事务（分布式事务）</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#什么是分布式事务" class="sidebar-link">什么是分布式事务</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#分布式事务产生的原因" class="sidebar-link">分布式事务产生的原因</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#service多个节点" class="sidebar-link">service多个节点</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#resource多个节点" class="sidebar-link">resource多个节点</a></li></ul></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#分布式事务的基础" class="sidebar-link">分布式事务的基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#cap" class="sidebar-link">CAP</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#base" class="sidebar-link">BASE</a></li></ul></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#是否真的要分布式事务" class="sidebar-link">是否真的要分布式事务</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#_2pc" class="sidebar-link">2PC</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#tcc" class="sidebar-link">TCC</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#本地消息表" class="sidebar-link">本地消息表</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#mq事务" class="sidebar-link">MQ事务</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/MySQL/事务篇.html#saga事务" class="sidebar-link">Saga事务</a></li></ul></li><li><a href="/ifan/Notes/数据库/MySQL/锁篇.html" class="sidebar-link">锁篇</a></li><li><a href="/ifan/Notes/数据库/MySQL/索引篇.html" class="sidebar-link">索引篇</a></li><li><a href="/ifan/Notes/数据库/MySQL/基础篇.html" class="sidebar-link">基础篇</a></li><li><a href="/ifan/Notes/数据库/MySQL/分库分表.html" class="sidebar-link">分库分表</a></li><li><a href="/ifan/Notes/数据库/MySQL/内存篇.html" class="sidebar-link">内存篇</a></li><li><a href="/ifan/Notes/数据库/MySQL/日志篇.html" class="sidebar-link">日志篇</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Netty</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Summary</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java IO</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础和原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Notes</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="事务隔离级别是怎么实现的"><a href="#事务隔离级别是怎么实现的" class="header-anchor">#</a> 事务隔离级别是怎么实现的？</h1> <p>这是我的钱包，共有 100 万元。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/bc8fe6de0e9e466671cd7d335c116de3.png" alt="图片"></p> <p>今天我心情好，我决定给你的转账 100 万，最后的结果肯定是我的余额变为 0 元，你的余额多了 100 万元，是不是想到就很开心？</p> <p>转账这一动作在程序里会涉及到一系列的操作，假设我向你转账 100 万的过程是有下面这几个步骤组成的：</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/40b48e0a7c9a57ae6b78b62c3fad4048.png" alt="图片"></p> <p>可以看到这个转账的过程涉及到了两次修改数据库的操作。</p> <p>假设在执行第三步骤之后，服务器忽然掉电了，就会发生一个蛋疼的事情，我的账户扣了 100 万，但是钱并没有到你的账户上，也就是说<strong>这 100 万消失了！</strong></p> <p>要解决这个问题，就要保证转账业务里的所有数据库的操作是不可分割的，要么全部执行成功 ，要么全部失败，不允许出现中间状态的数据。</p> <p>数据库中的「<strong>事务（*Transaction*）</strong>」就能达到这样的效果。</p> <p>我们在转账操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态。</p> <p>没错，今天就来图解 MySQL 事务啦，开车！</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/eb15d4b6a9d543c1be4f7090479d969c.png" alt="img"></p> <hr> <h2 id="事务有哪些特性"><a href="#事务有哪些特性" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>事务有哪些特性？</h2> <p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p> <p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。</p> <p>事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：</p> <ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li> <li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li> <li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li> <li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul> <p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p> <ul><li>持久性是通过 redo log （重做日志）来保证的；</li> <li>原子性是通过 undo log（回滚日志） 来保证的；</li> <li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li> <li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul> <p>这次将<strong>重点介绍事务的隔离性</strong>，这也是面试时最常问的知识的点。</p> <p>为什么事务要有隔离性，我们就要知道并发事务时会引发什么问题。</p> <h2 id="并行事务会引发什么问题"><a href="#并行事务会引发什么问题" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E5%B9%B6%E8%A1%8C%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>并行事务会引发什么问题？</h2> <p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p> <p>那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p> <p>接下来，通过举例子给大家说明，这些问题是如何发生的。</p> <h3 id="脏读"><a href="#脏读" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E8%84%8F%E8%AF%BB" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>脏读</h3> <p><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></p> <p>举个栗子。</p> <p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/10b513008ea35ee880c592a88adcb12f.png" alt="图片"></p> <p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，<strong>如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</strong></p> <h3 id="不可重复读"><a href="#不可重复读" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>不可重复读</h3> <p><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></p> <p>举个栗子。</p> <p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，<strong>在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</strong></p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片"></p> <h3 id="幻读"><a href="#幻读" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E5%B9%BB%E8%AF%BB" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>幻读</h3> <p><strong>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</strong></p> <p>举个栗子。</p> <p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片"></p> <p>接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。</p> <p>然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，<strong>发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</strong></p> <h2 id="事务的隔离级别有哪些"><a href="#事务的隔离级别有哪些" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>事务的隔离级别有哪些？</h2> <p>前面我们提到，当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。</p> <ul><li>脏读：读到其他事务未提交的数据；</li> <li>不可重复读：前后读取的数据不一致；</li> <li>幻读：前后读取的记录数量不一致。</li></ul> <p>这三个现象的严重性排序如下：</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/d37bfa1678eb71ae7e33dc8f211d1ec1.png" alt="图片"></p> <p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p> <ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li> <li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li> <li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li> <li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul> <p>按隔离水平高低排序如下：</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/cce766a69dea725cd8f19b90db2d0430.png" alt="图片"></p> <p>针对不同的隔离级别，并发事务时可能发生的现象也会不同。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/4e98ea2e60923b969790898565b4d643.png" alt="图片"></p> <p>也就是说：</p> <ul><li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li> <li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</li> <li>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</li> <li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li></ul> <p>所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。</p> <p>不同的数据库厂商对 SQL 标准中规定的 4 种隔离级别的支持不一样，有的数据库只实现了其中几种隔离级别，<strong>我们讨论的 MySQL 虽然支持 4 种隔离级别，但是与SQL 标准中规定的各级隔离级别允许发生的现象却有些出入</strong>。</p> <p>MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</p> <p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇<a href="https://xiaolincoding.com/mysql/transaction/phantom.html" target="_blank" rel="noopener noreferrer">文章 (opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</strong>，解决的方案有两种：</p> <ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li> <li>针对<strong>当前读</strong>（select ... for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul> <p>接下来，举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/d5de450e901ed926d0b5278c8b65b9fe.png" alt="图片"></p> <p>在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：</p> <ul><li>在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；</li> <li>在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；</li> <li>在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；</li> <li>在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。</li></ul> <p>这四种隔离级别具体是如何实现的呢？</p> <ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li> <li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li> <li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View *<em>来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。*</em>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li></ul> <p>注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p> <ul><li>第一种：begin/start transaction 命令；</li> <li>第二种：start transaction with consistent snapshot 命令；</li></ul> <p>这两种开启事务的命令，事务的启动时机是不同的：</p> <ul><li>执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；</li> <li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li></ul> <p>接下来详细说下，Read View 在 MVCC 里如何工作的？</p> <h2 id="read-view-在-mvcc-里如何工作的"><a href="#read-view-在-mvcc-里如何工作的" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>Read View 在 MVCC 里如何工作的？</h2> <p>我们需要了解两个知识：</p> <ul><li>Read View 中四个字段作用；</li> <li>聚簇索引记录中两个跟事务有关的隐藏列；</li></ul> <p>那 Read View 到底是个什么东西？</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p> <p>Read View 有四个重要的字段：</p> <ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li> <li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li> <li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li> <li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul> <p>知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。</p> <p>假设在账户余额表插入一条小林余额为 100 万的记录，然后我把这两个隐藏列也画出来，该记录的整个示意图如下：</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" alt="图片"></p> <p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p> <ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li> <li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul> <p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png" alt="img"></p> <p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p> <ul><li><p>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</p></li> <li><p>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</p></li> <li><p>如果记录的 trx_id 值在 Read View 的</p> <div class="language- extra-class"><pre class="language-text"><code>min_trx_id
</code></pre></div><p>和</p> <div class="language- extra-class"><pre class="language-text"><code>max_trx_id
</code></pre></div><p>之间，需要判断 trx_id 是否在 m_ids 列表中：</p> <ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li> <li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul> <p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p> <h2 id="可重复读是如何工作的"><a href="#可重复读是如何工作的" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>可重复读是如何工作的？</h2> <p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p> <p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png" alt="img"></p> <p>事务 A 和 事务 B 的 Read View 具体内容如下：</p> <ul><li>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</li> <li>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<strong>活跃的事务 id 中最小的事务 id 是事务 A</strong>，下一个事务 id 应该是 53。</li></ul> <p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：</p> <ul><li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li> <li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li> <li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li> <li>事务 A 提交事务；</li> <li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li></ul> <p>接下来，跟大家具体分析下。</p> <p>事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p> <p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE2.png" alt="img"></p> <p>你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id = 51）。</p> <p>然后事务 B 第二次去读取该记录，<strong>发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</strong>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p> <p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录</strong>。</p> <p>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。</p> <h2 id="读提交是如何工作的"><a href="#读提交是如何工作的" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>读提交是如何工作的？</h2> <p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p> <p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p> <p>那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。</p> <p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，接着按顺序执行了以下操作：</p> <ul><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li> <li>事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；</li> <li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li> <li>事务 A 提交事务；</li> <li>事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；</li></ul> <p>那具体怎么做到的呢？我们重点看事务 B 每次读取数据时创建的 Read View。前两次 事务 B 读取数据时创建的 Read View 如下图：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.png" alt="img"></p> <p>我们来分析下为什么事务 B 第二次读数据时，读不到事务 A （还未提交事务）修改的数据？</p> <p>事务 B 在找到小林这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明<strong>这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录</strong>。而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p> <p>我们来分析下为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？</p> <p>在事务 A 提交后，<strong>由于隔离级别是「读提交」，所以事务 B 在每次读数据的时候，会重新创建 Read View</strong>，此时事务 B 第三次读取数据时创建的 Read View 如下：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A12.drawio.png" alt="img"></p> <p>事务 B 在找到小林这条记录时，<strong>会发现这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id 值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了，所以该版本的记录对事务 B 是可见的</strong>。</p> <p>正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>总结</h2> <p>事务是在 MySQL 引擎层实现的，我们常见的 InnoDB 引擎是支持事务的，事务的四大特性是原子性、一致性、隔离性、持久性，我们这次主要讲的是隔离性。</p> <p>当多个事务并发执行的时候，会引发脏读、不可重复读、幻读这些问题，那为了避免这些问题，SQL 提出了四种隔离级别，分别是读未提交、读已提交、可重复读、串行化，从左往右隔离级别顺序递增，隔离级别越高，意味着性能越差，InnoDB 引擎的默认隔离级别是可重复读。</p> <p>要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。</p> <p>而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇<a href="https://xiaolincoding.com/mysql/transaction/phantom.html" target="_blank" rel="noopener noreferrer">文章 (opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>），解决的方案有两种：</p> <ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li> <li>针对<strong>当前读</strong>（select ... for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul> <p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p> <ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li> <li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul> <p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p> <p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p> <h1 id="mysql-可重复读隔离级别-完全解决幻读了吗"><a href="#mysql-可重复读隔离级别-完全解决幻读了吗" class="header-anchor">#</a> MySQL 可重复读隔离级别，完全解决幻读了吗？</h1> <p>大家好，我是小林。</p> <p>我在<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html" target="_blank" rel="noopener noreferrer">上一篇文章 (opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>提到，MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p> <ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li> <li>针对<strong>当前读</strong>（select ... for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul> <p>这两个解决方案是很大程度上解决了幻读现象，但是还是有个别的情况造成的幻读现象是无法解决的。</p> <p>这次，就跟大家好好聊这个问题。</p> <h2 id="什么是幻读"><a href="#什么是幻读" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>什么是幻读？</h2> <p>首先来看看 MySQL 文档是怎么定义幻读（Phantom Read）的:</p> <p><em><strong>The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.</strong></em></p> <p>翻译：当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行，则该行是“幻像”行。</p> <p>举个例子，假设一个事务在 T1 时刻和 T2 时刻分别执行了下面查询语句，途中没有执行其他任何语句：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_test <span class="token keyword">WHERE</span> id <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">;</span>
</code></pre></div><p>只要 T1 和 T2 时刻执行产生的结果集是不相同的，那就发生了幻读的问题，比如：</p> <ul><li>T1 时间执行的结果是有 5 条行记录，而 T2 时间执行的结果是有 6 条行记录，那就发生了幻读的问题。</li> <li>T1 时间执行的结果是有 5 条行记录，而 T2 时间执行的结果是有 4 条行记录，也是发生了幻读的问题。</li></ul> <h2 id="快照读是如何避免幻读的"><a href="#快照读是如何避免幻读的" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB%E7%9A%84" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>快照读是如何避免幻读的？</h2> <p>可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p> <p>做个实验，数据库表 t_stu 如下，其中 id 为主键。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/7f9df142b3594daeaaca495abb7133f5.png" alt="img"></p> <p>然后在可重复读隔离级别下，有两个事务的执行顺序如下：</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/e576e047dccc47d5a59636ea342750b8.png" alt="在这里插入图片描述"></p> <p>从这个实验结果可以看到，即使事务 B 中途插入了一条记录，事务 A 前后两次查询的结果集都是一样的，并没有出现所谓的幻读现象。</p> <h2 id="当前读是如何避免幻读的"><a href="#当前读是如何避免幻读的" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E5%BD%93%E5%89%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB%E7%9A%84" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>当前读是如何避免幻读的？</h2> <p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p> <p>这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</p> <p>另外，<code>select ... for update</code> 这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p> <p>接下来，我们假设<code>select ... for update</code>当前读是不会加锁的（实际上是会加锁的），在做一遍实验。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/1f872ff92b644b5f81cee2dd9188b199.png" alt="img"></p> <p>这时候，事务 B 插入的记录，就会被事务 A 的第二条查询语句查询到（因为是当前读），这样就会出现前后两次查询的结果集合不一样，这就出现了幻读。</p> <p>所以，<strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了间隙锁</strong>。</p> <p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/gap%E9%94%81.drawio.png" alt="img"></p> <p>举个具体例子，场景如下：</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/3af285a8e70f4d4198318057eb955520.png" alt="img"></p> <p>事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。</p> <p>然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象。</p> <h2 id="幻读被完全解决了吗"><a href="#幻读被完全解决了吗" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>幻读被完全解决了吗？</h2> <p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p> <p>我举例一个可重复读隔离级别发生幻读现象的场景。</p> <h3 id="第一个发生幻读现象的场景"><a href="#第一个发生幻读现象的场景" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>第一个发生幻读现象的场景</h3> <p>还是以这张表作为例子：</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/7f9df142b3594daeaaca495abb7133f5-20230309222119359.png" alt="img"></p> <p>事务 A 执行查询 id = 5 的记录，此时表中是没有该记录的，所以查询不出来。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment"># 事务 A</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_stu <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre></div><p>然后事务 B 插入一条 id = 5 的记录，并且提交了事务。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment"># 事务 B</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> t_stu <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'小美'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">commit</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre></div><p>此时，<strong>事务 A 更新 id = 5 这条记录，对没错，事务 A 看不到 id = 5 这条记录，但是他去更新了这条记录，这场景确实很违和，然后再次查询 id = 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景</strong>。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment"># 事务 A</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> t_stu <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'小林coding'</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_stu <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+--------------+------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> name         <span class="token operator">|</span> age  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------+------+</span>
<span class="token operator">|</span>  <span class="token number">5</span> <span class="token operator">|</span> 小林coding   <span class="token operator">|</span>   <span class="token number">18</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------+------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre></div><p>整个发生幻读的时序图如下：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img"></p> <p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p> <p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p> <h3 id="第二个发生幻读现象的场景"><a href="#第二个发生幻读现象的场景" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>第二个发生幻读现象的场景</h3> <p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p> <ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li> <li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</li> <li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul> <p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p> <h2 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> <a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>总结</h2> <p>MySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：</p> <ul><li>针对<strong>快照读</strong>（普通 select 语句），是通过 MVCC 方式解决了幻读。</li> <li>针对<strong>当前读</strong>（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。</li></ul> <p>我举例了两个发生幻读场景的例子。</p> <p>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p> <p>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p> <p>所以，<strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p> <p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p> <h2 id="xa事务-分布式事务"><a href="#xa事务-分布式事务" class="header-anchor">#</a> XA事务（分布式事务）</h2> <p>https://juejin.cn/post/6844903647197806605</p> <h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="header-anchor">#</a> 什么是分布式事务</h2> <p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p> <h2 id="分布式事务产生的原因"><a href="#分布式事务产生的原因" class="header-anchor">#</a> 分布式事务产生的原因</h2> <p>从上面本地事务来看，我们可以看为两块，一个是service产生多个节点，另一个是resource产生多个节点。</p> <h3 id="service多个节点"><a href="#service多个节点" class="header-anchor">#</a> service多个节点</h3> <p>随着互联网快速发展，微服务，SOA等服务架构模式正在被大规模的使用，举个简单的例子，一个公司之内，用户的资产可能分为好多个部分，比如余额，积分，优惠券等等。在公司内部有可能积分功能由一个微服务团队维护，优惠券又是另外的团队维护</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/26/164d6783a9e3f959~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p> <p>这样的话就无法保证积分扣减了之后，优惠券能否扣减成功。</p> <h3 id="resource多个节点"><a href="#resource多个节点" class="header-anchor">#</a> resource多个节点</h3> <p>同样的，互联网发展得太快了，我们的Mysql一般来说装千万级的数据就得进行分库分表，对于一个支付宝的转账业务来说，你给的朋友转钱，有可能你的数据库是在北京，而你的朋友的钱是存在上海，所以我们依然无法保证他们能同时成功。</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/26/164d67e0c6026ac4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p> <h2 id="分布式事务的基础"><a href="#分布式事务的基础" class="header-anchor">#</a> 分布式事务的基础</h2> <p>从上面来看分布式事务是随着互联网高速发展应运而生的，这是一个必然的我们之前说过数据库的ACID四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论:</p> <h3 id="cap"><a href="#cap" class="header-anchor">#</a> CAP</h3> <p>CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。</p> <ul><li>C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。</li> <li>A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。</li> <li>P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。</li></ul> <p>熟悉CAP的人都知道，三者不能共有，如果感兴趣可以搜索CAP的证明，在分布式系统中，网络无法100%可靠，分区其实是一个必然现象，如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。</p> <p>对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。</p> <p>对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。</p> <p>顺便一提，CAP理论中是忽略网络延迟，也就是当事务提交时，从节点A复制到节点B，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。同时CAP中选择两个，比如你选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA。就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用。</p> <h3 id="base"><a href="#base" class="header-anchor">#</a> BASE</h3> <p>BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。是对CAP中AP的一个扩展</p> <ol><li>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。</li> <li>软状态:允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。</li> <li>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。</li></ol> <p>BASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。BASE和 ACID 是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p> <h1 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="header-anchor">#</a> 分布式事务解决方案</h1> <p>有了上面的理论基础后，这里介绍开始介绍几种常见的分布式事务的解决方案。</p> <h2 id="是否真的要分布式事务"><a href="#是否真的要分布式事务" class="header-anchor">#</a> 是否真的要分布式事务</h2> <p>在说方案之前，首先你一定要明确你是否真的需要分布式事务？</p> <p>上面说过出现分布式事务的两个原因，其中有个原因是因为微服务过多。我见过太多团队一个人维护几个微服务，太多团队过度设计，搞得所有人疲劳不堪，而微服务过多就会引出分布式事务，这个时候我不会建议你去采用下面任何一种方案，而是请把需要事务的微服务聚合成一个单机服务，使用数据库的本地事务。因为不论任何一种方案都会增加你系统的复杂度，这样的成本实在是太高了，千万不要因为追求某些设计，而引入不必要的成本和复杂度。</p> <p>如果你确定需要引入分布式事务可以看看下面几种常见的方案。</p> <h2 id="_2pc"><a href="#_2pc" class="header-anchor">#</a> 2PC</h2> <p>说到2PC就不得不聊数据库分布式事务中的 XA Transactions。</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/26/164d73624b63e17a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p> <p>在XA协议中分为两阶段:</p> <p>第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</p> <p>第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。</p> <p>优点： 尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。</p> <p>缺点:</p> <ul><li>单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li> <li>同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</li> <li>数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li></ul> <p>总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。</p> <h2 id="tcc"><a href="#tcc" class="header-anchor">#</a> TCC</h2> <p>关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC事务机制相比于上面介绍的XA，解决了其几个缺点: 1.解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。 2.同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。 3.数据一致性，有了补偿机制之后，由业务活动管理器控制一致性</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/26/164d74a2293772d5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p> <p>对于TCC的解释:</p> <ul><li>Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）</li> <li>Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。</li> <li>Cancel阶段：取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。</li></ul> <p>举个简单的例子如果你用100元买了一瓶水， Try阶段:你需要向你的钱包检查是否够100元并锁住这100元，水也是一样的。</p> <p>如果有一个失败，则进行cancel(释放这100元和这一瓶水)，如果cancel失败不论什么失败都进行重试cancel，所以需要保持幂等。</p> <p>如果都成功，则进行confirm,确认这100元扣，和这一瓶水被卖，如果confirm失败无论什么失败则重试(会依靠活动日志进行重试)</p> <p>对于TCC来说适合一些:</p> <ul><li>强隔离性，严格一致性要求的活动业务。</li> <li>执行时间较短的业务</li></ul> <p>实现参考:ByteTCC:<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fliuyangming%2FByteTCC%2F" target="_blank" rel="noopener noreferrer">github.com/liuyangming…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="本地消息表"><a href="#本地消息表" class="header-anchor">#</a> 本地消息表</h2> <p>本地消息表这个方案最初是ebay提出的 ebay的完整方案https://queue.acm.org/detail.cfm?id=1394128。</p> <p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/27/164d75fd59779f74~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p> <p>对于本地消息队列来说核心是把大事务转变为小事务。还是举上面用100元去买一瓶水的例子。</p> <p>1.当你扣钱的时候，你需要在你扣钱的服务器上新增加一个本地消息表，你需要把你扣钱和写入减去水的库存到本地消息表放入同一个事务(依靠数据库本地事务保证一致性。</p> <p>2.这个时候有个定时任务去轮询这个本地事务表，把没有发送的消息，扔给商品库存服务器，叫他减去水的库存，到达商品服务器之后这个时候得先写入这个服务器的事务表，然后进行扣减，扣减成功后，更新事务表中的状态。</p> <p>3.商品服务器通过定时任务扫描消息表或者直接通知扣钱服务器，扣钱服务器本地消息表进行状态更新。</p> <p>4.针对一些异常情况，定时扫描未成功处理的消息，进行重新发送，在商品服务器接到消息之后，首先判断是否是重复的，如果已经接收，在判断是否执行，如果执行在马上又进行通知事务，如果未执行，需要重新执行需要由业务保证幂等，也就是不会多扣一瓶水。</p> <p>本地消息队列是BASE理论，是最终一致模型，适用于对一致性要求不高的。实现这个模型时需要注意重试的幂等。</p> <h2 id="mq事务"><a href="#mq事务" class="header-anchor">#</a> MQ事务</h2> <p>在RocketMQ中实现了分布式事务，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，下面简单介绍一下MQ事务，如果想对其详细了解可以参考: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F453c6e7ff81c%E3%80%82" target="_blank" rel="noopener noreferrer">www.jianshu.com/p/453c6e7ff…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/27/164d773728eb2d4d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p> <p>基本流程如下: 第一阶段Prepared消息，会拿到消息的地址。</p> <p>第二阶段执行本地事务。</p> <p>第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。消息接受者就能使用这个消息。</p> <p>如果确认消息失败，在RocketMq Broker中提供了定时扫描没有更新状态的消息，如果有消息没有得到确认，会向消息发送者发送消息，来判断是否提交，在rocketmq中是以listener的形式给发送者，用来处理。</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/27/164d77389afdfd6b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p> <p>如果消费超时，则需要一直重试，消息接收端需要保证幂等。如果消息消费失败，这个就需要人工进行处理，因为这个概率较低，如果为了这种小概率时间而设计这个复杂的流程反而得不偿失</p> <h2 id="saga事务"><a href="#saga事务" class="header-anchor">#</a> Saga事务</h2> <p>Saga是30年前一篇数据库伦理提到的一个概念。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。 Saga的组成：</p> <p>每个Saga由一系列sub-transaction Ti 组成 每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果,这里的每个T，都是一个本地事务。 可以看到，和TCC相比，Saga没有“预留 try”动作，它的Ti就是直接提交到库。</p> <p>Saga的执行顺序有两种：</p> <p>T1, T2, T3, ..., Tn</p> <p>T1, T2, ..., Tj, Cj,..., C2, C1，其中0 &lt; j &lt; n Saga定义了两种恢复策略：</p> <p>向后恢复，即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。 向前恢复，适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, ..., Tj(失败), Tj(重试),..., Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。</p> <p>这里要注意的是，在saga模式中不能保证隔离性，因为没有锁住资源，其他事务依然可以覆盖或者影响当前事务。</p> <p>还是拿100元买一瓶水的例子来说，这里定义</p> <p>T1=扣100元 T2=给用户加一瓶水 T3=减库存一瓶水</p> <p>C1=加100元 C2=给用户减一瓶水 C3=给库存加一瓶水</p> <p>我们一次进行T1,T2，T3如果发生问题，就执行发生问题的C操作的反向。 上面说到的隔离性的问题会出现在，如果执行到T3这个时候需要执行回滚，但是这个用户已经把水喝了(另外一个事务)，回滚的时候就会发现，无法给用户减一瓶水了。这就是事务之间没有隔离性的问题</p> <p>可以看见saga模式没有隔离性的影响还是较大，可以参照华为的解决方案:从业务层面入手加入一 Session 以及锁的机制来保证能够串行化操作资源。也可以在业务层面通过预先冻结资金的方式隔离这部分资源， 最后在业务操作的过程中可以通过及时读取当前状态的方式获取到最新的更新。</p> <p>具体实例:可以参考华为的servicecomb</p> <h1 id="最后"><a href="#最后" class="header-anchor">#</a> 最后</h1> <p>还是那句话，能不用分布式事务就不用，如果非得使用的话，结合自己的业务分析，看看自己的业务比较适合哪一种，是在乎强一致，还是最终一致即可。上面对解决方案只是一些简单介绍，如果真正的想要落地，其实每种方案需要思考的地方都非常多，复杂度都比较大，所以最后再次提醒一定要判断好是否使用分布式事务。最后在总结一些问题,大家可以下来自己从文章找寻答案:</p> <ol><li>ACID和CAP的 CA是一样的吗？</li> <li>分布式事务常用的解决方案的优缺点是什么？适用于什么场景？</li> <li>分布式事务出现的原因？用来解决什么痛点？</li></ol> <p>03-MySQL-XA事务状态流转</p> <p>XA事务在MySQL内部共有五种状态，如下:</p> <ul><li>XA_NOTR   //未开始</li> <li>XA_ACTIVE 活跃状态</li> <li>XA_IDLE //空闲状态</li> <li>XA_PREPARED //准备提交状态</li> <li>XA_ROLLBACK_ONLY /只能回滚</li></ul> <p>状态流转图：</p> <p><img src="https://obs-emcsapp-public.obs.cn-north-4.myhwclouds.com/wechatSpider/modb_20191220_114907.png" alt="img"></p> <p><img src="https://obs-emcsapp-public.obs.cn-north-4.myhwclouds.com/wechatSpider/modb_20191220_114908.png" alt="img"></p> <p>事务状态流转受到InnoDB参数innodb_rollback_on_timeout的影响，这一点会在下一篇文章中解释，关于MySQL XA事务处理的内部细节，也会放在后续的文章中。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ifan/Notes/Docker/docker部署ftp文件服务器.html" class="prev">
        docker部署ftp文件服务器
      </a></span> <span class="next"><a href="/ifan/Notes/数据库/MySQL/锁篇.html">
        锁篇
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ifan/assets/js/app.1d8f04c4.js" defer></script><script src="/ifan/assets/js/2.733019b2.js" defer></script><script src="/ifan/assets/js/66.e97c1fb7.js" defer></script>
  </body>
</html>
