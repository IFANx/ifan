<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>主从复制是怎么实现的？ | Notes</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="办法总比问题多">
    
    <link rel="preload" href="/ifan/assets/css/0.styles.9066d5db.css" as="style"><link rel="preload" href="/ifan/assets/js/app.5e29002d.js" as="script"><link rel="preload" href="/ifan/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/ifan/assets/js/83.7bac340f.js" as="script"><link rel="prefetch" href="/ifan/assets/js/10.8b80ea1e.js"><link rel="prefetch" href="/ifan/assets/js/100.1ddacebb.js"><link rel="prefetch" href="/ifan/assets/js/101.82fc3a71.js"><link rel="prefetch" href="/ifan/assets/js/102.8f1c1a78.js"><link rel="prefetch" href="/ifan/assets/js/103.4908c7f6.js"><link rel="prefetch" href="/ifan/assets/js/11.efdcfdae.js"><link rel="prefetch" href="/ifan/assets/js/12.b25c7308.js"><link rel="prefetch" href="/ifan/assets/js/13.54ea76bd.js"><link rel="prefetch" href="/ifan/assets/js/14.a55dbf23.js"><link rel="prefetch" href="/ifan/assets/js/15.01c694bf.js"><link rel="prefetch" href="/ifan/assets/js/16.d9772b2c.js"><link rel="prefetch" href="/ifan/assets/js/17.e8ae0051.js"><link rel="prefetch" href="/ifan/assets/js/18.f45ea548.js"><link rel="prefetch" href="/ifan/assets/js/19.2ddcd05d.js"><link rel="prefetch" href="/ifan/assets/js/20.af485201.js"><link rel="prefetch" href="/ifan/assets/js/21.e585d9c7.js"><link rel="prefetch" href="/ifan/assets/js/22.2b276ecc.js"><link rel="prefetch" href="/ifan/assets/js/23.f343dea3.js"><link rel="prefetch" href="/ifan/assets/js/24.7bd49739.js"><link rel="prefetch" href="/ifan/assets/js/25.3a911f9f.js"><link rel="prefetch" href="/ifan/assets/js/26.fa9a686d.js"><link rel="prefetch" href="/ifan/assets/js/27.274f0bfc.js"><link rel="prefetch" href="/ifan/assets/js/28.989a3a4f.js"><link rel="prefetch" href="/ifan/assets/js/29.abbf3945.js"><link rel="prefetch" href="/ifan/assets/js/3.b5397dbc.js"><link rel="prefetch" href="/ifan/assets/js/30.6738d5ae.js"><link rel="prefetch" href="/ifan/assets/js/31.21730518.js"><link rel="prefetch" href="/ifan/assets/js/32.63a4b525.js"><link rel="prefetch" href="/ifan/assets/js/33.60a93df6.js"><link rel="prefetch" href="/ifan/assets/js/34.2a08eef0.js"><link rel="prefetch" href="/ifan/assets/js/35.49883a6b.js"><link rel="prefetch" href="/ifan/assets/js/36.49d3a152.js"><link rel="prefetch" href="/ifan/assets/js/37.0b8ae546.js"><link rel="prefetch" href="/ifan/assets/js/38.80e5a545.js"><link rel="prefetch" href="/ifan/assets/js/39.cd1d4ee5.js"><link rel="prefetch" href="/ifan/assets/js/4.d12742be.js"><link rel="prefetch" href="/ifan/assets/js/40.c5a201e2.js"><link rel="prefetch" href="/ifan/assets/js/41.6fc8c625.js"><link rel="prefetch" href="/ifan/assets/js/42.9b3ce7f9.js"><link rel="prefetch" href="/ifan/assets/js/43.0d002814.js"><link rel="prefetch" href="/ifan/assets/js/44.0a1a4c6f.js"><link rel="prefetch" href="/ifan/assets/js/45.3933ef6d.js"><link rel="prefetch" href="/ifan/assets/js/46.1d702023.js"><link rel="prefetch" href="/ifan/assets/js/47.61263332.js"><link rel="prefetch" href="/ifan/assets/js/48.72af0861.js"><link rel="prefetch" href="/ifan/assets/js/49.cecf707f.js"><link rel="prefetch" href="/ifan/assets/js/5.216cae74.js"><link rel="prefetch" href="/ifan/assets/js/50.5c732b05.js"><link rel="prefetch" href="/ifan/assets/js/51.922c4a4a.js"><link rel="prefetch" href="/ifan/assets/js/52.523e7102.js"><link rel="prefetch" href="/ifan/assets/js/53.f0c1485e.js"><link rel="prefetch" href="/ifan/assets/js/54.925cc9f8.js"><link rel="prefetch" href="/ifan/assets/js/55.4055e6c2.js"><link rel="prefetch" href="/ifan/assets/js/56.b303ce96.js"><link rel="prefetch" href="/ifan/assets/js/57.abc2d066.js"><link rel="prefetch" href="/ifan/assets/js/58.2f387033.js"><link rel="prefetch" href="/ifan/assets/js/59.3e5929a1.js"><link rel="prefetch" href="/ifan/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/ifan/assets/js/60.0072cfa1.js"><link rel="prefetch" href="/ifan/assets/js/61.36fe6db7.js"><link rel="prefetch" href="/ifan/assets/js/62.7e153e1d.js"><link rel="prefetch" href="/ifan/assets/js/63.cf107bce.js"><link rel="prefetch" href="/ifan/assets/js/64.c79ab33b.js"><link rel="prefetch" href="/ifan/assets/js/65.a77be777.js"><link rel="prefetch" href="/ifan/assets/js/66.2177acf6.js"><link rel="prefetch" href="/ifan/assets/js/67.7991ba80.js"><link rel="prefetch" href="/ifan/assets/js/68.661cba4c.js"><link rel="prefetch" href="/ifan/assets/js/69.7f61b0e3.js"><link rel="prefetch" href="/ifan/assets/js/7.40dfeb27.js"><link rel="prefetch" href="/ifan/assets/js/70.2e686987.js"><link rel="prefetch" href="/ifan/assets/js/71.83f60807.js"><link rel="prefetch" href="/ifan/assets/js/72.0de4b6d0.js"><link rel="prefetch" href="/ifan/assets/js/73.f5e95877.js"><link rel="prefetch" href="/ifan/assets/js/74.33166f67.js"><link rel="prefetch" href="/ifan/assets/js/75.9514b8d2.js"><link rel="prefetch" href="/ifan/assets/js/76.ca76724a.js"><link rel="prefetch" href="/ifan/assets/js/77.1e8f5846.js"><link rel="prefetch" href="/ifan/assets/js/78.d654fa1d.js"><link rel="prefetch" href="/ifan/assets/js/79.38e3f116.js"><link rel="prefetch" href="/ifan/assets/js/8.53bb2c64.js"><link rel="prefetch" href="/ifan/assets/js/80.bc63ee47.js"><link rel="prefetch" href="/ifan/assets/js/81.c9e1e301.js"><link rel="prefetch" href="/ifan/assets/js/82.f5ea0a9c.js"><link rel="prefetch" href="/ifan/assets/js/84.9ec379e2.js"><link rel="prefetch" href="/ifan/assets/js/85.88c24482.js"><link rel="prefetch" href="/ifan/assets/js/86.60b59a04.js"><link rel="prefetch" href="/ifan/assets/js/87.cb1c5e17.js"><link rel="prefetch" href="/ifan/assets/js/88.a15e7aee.js"><link rel="prefetch" href="/ifan/assets/js/89.afb0a74b.js"><link rel="prefetch" href="/ifan/assets/js/9.05495c9e.js"><link rel="prefetch" href="/ifan/assets/js/90.48dfb82e.js"><link rel="prefetch" href="/ifan/assets/js/91.679f330a.js"><link rel="prefetch" href="/ifan/assets/js/92.e5ea1aff.js"><link rel="prefetch" href="/ifan/assets/js/93.bd3e3f95.js"><link rel="prefetch" href="/ifan/assets/js/94.6850d1a0.js"><link rel="prefetch" href="/ifan/assets/js/95.1e2d6d91.js"><link rel="prefetch" href="/ifan/assets/js/96.b7d1254c.js"><link rel="prefetch" href="/ifan/assets/js/97.40a29e27.js"><link rel="prefetch" href="/ifan/assets/js/98.1d9f9bb8.js"><link rel="prefetch" href="/ifan/assets/js/99.69e350da.js">
    <link rel="stylesheet" href="/ifan/assets/css/0.styles.9066d5db.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ifan/" class="home-link router-link-active"><!----> <span class="site-name">Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ifan/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="what?" class="dropdown-title"><span class="title">what?</span> <span class="arrow down"></span></button> <button type="button" aria-label="what?" class="mobile-dropdown-title"><span class="title">what?</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/ifan/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="what?" class="dropdown-title"><span class="title">what?</span> <span class="arrow down"></span></button> <button type="button" aria-label="what?" class="mobile-dropdown-title"><span class="title">what?</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Maven</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>软件测试相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Redis</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ifan/Notes/数据库/Redis/持久化篇.html" class="sidebar-link">持久化篇</a></li><li><a href="/ifan/Notes/数据库/Redis/缓存一执行问题.html" class="sidebar-link">缓存一执行问题</a></li><li><a href="/ifan/Notes/数据库/Redis/集群-分片技术.html" class="sidebar-link">集群-分片技术</a></li><li><a href="/ifan/Notes/数据库/Redis/数据类型篇.html" class="sidebar-link">数据类型篇</a></li><li><a href="/ifan/Notes/数据库/Redis/Redis面试题.html" class="sidebar-link">Redis面试题</a></li><li><a href="/ifan/Notes/数据库/Redis/缓存篇.html" class="sidebar-link">缓存篇</a></li><li><a href="/ifan/Notes/数据库/Redis/高可用篇.html" class="active sidebar-link">高可用篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#第一次同步" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#第一次同步)第一次同步</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#命令传播" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#命令传播)命令传播</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#分摊主服务器的压力" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#分摊主服务器的压力)分摊主服务器的压力</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#增量复制" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#增量复制)增量复制</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#面试题" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#面试题)面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#redis主从节点时长连接还是短连接" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#redis主从节点时长连接还是短连接)Redis主从节点时长连接还是短连接？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#怎么判断-redis-某个节点是否正常工作" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#怎么判断-redis-某个节点是否正常工作)怎么判断 Redis 某个节点是否正常工作？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#主从复制架构中-过期key如何处理" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#主从复制架构中-过期key如何处理)主从复制架构中，过期key如何处理？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#redis-是同步复制还是异步复制" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#redis-是同步复制还是异步复制)Redis 是同步复制还是异步复制？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#主从复制中两个-buffer-replication-buffer-、repl-backlog-buffer-有什么区别" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#主从复制中两个-buffer-replication-buffer-、repl-backlog-buffer-有什么区别)主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#如何应对主从数据不一致" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#如何应对主从数据不一致)如何应对主从数据不一致？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#主从切换如何减少数据丢失" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#主从切换如何减少数据丢失)主从切换如何减少数据丢失？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#主从如何做到故障自动切换" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/masterslavereplication.html#主从如何做到故障自动切换)主从如何做到故障自动切换？</a></li></ul></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#为什么要有哨兵机制" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#为什么要有哨兵机制)为什么要有哨兵机制？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#哨兵机制是如何工作的" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#哨兵机制是如何工作的)哨兵机制是如何工作的？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#如何判断主节点真的故障了" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#如何判断主节点真的故障了)如何判断主节点真的故障了？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#由哪个哨兵进行主从故障转移" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#由哪个哨兵进行主从故障转移)由哪个哨兵进行主从故障转移？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#主从故障转移的过程是怎样的" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#主从故障转移的过程是怎样的)主从故障转移的过程是怎样的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#步骤一-选出新主节点" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#步骤一-选出新主节点)步骤一：选出新主节点</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#步骤二-将从节点指向新主节点" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#步骤二-将从节点指向新主节点)步骤二：将从节点指向新主节点</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#步骤三-通知客户的主节点已更换" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#步骤三-通知客户的主节点已更换)步骤三：通知客户的主节点已更换</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#步骤四-将旧主节点变为从节点" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#步骤四-将旧主节点变为从节点)步骤四：将旧主节点变为从节点</a></li></ul></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#哨兵集群是如何组成的" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#哨兵集群是如何组成的)哨兵集群是如何组成的？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/数据库/Redis/高可用篇.html#总结-2" class="sidebar-link">[#](https://www.xiaolincoding.com/redis/cluster/sentinel.html#总结)总结</a></li></ul></li><li><a href="/ifan/Notes/数据库/Redis/面试篇.html" class="sidebar-link">面试篇</a></li><li><a href="/ifan/Notes/数据库/Redis/功能篇.html" class="sidebar-link">功能篇</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringBoot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MySQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Netty</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Summary</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java IO</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础和原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Notes</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="主从复制是怎么实现的"><a href="#主从复制是怎么实现的" class="header-anchor">#</a> 主从复制是怎么实现的？</h1> <p>大家好，我是小林哥。</p> <p>我在前两篇已经给大家图解了 AOF 和 RDB，这两个持久化技术保证了即使在服务器重启的情况下也不会丢失数据（或少量损失）。</p> <p>不过，由于数据都是存储在一台服务器上，如果出事就完犊子了，比如：</p> <ul><li>如果服务器发生了宕机，由于数据恢复是需要点时间，那么这个期间是无法服务新的请求的；</li> <li>如果这台服务器的硬盘出现了故障，可能数据就都丢失了。</li></ul> <p>要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/22c7fe97ce5d3c382b08d83a4d8a5b96.png" alt="图片"></p> <p>多台服务器要保存同一份数据，这里问题就来了。</p> <p>这些服务器之间的数据如何保持一致性呢？数据的读写操作是否每台服务器都可以处理？</p> <p>Redis 提供了<strong>主从复制模式</strong>，来避免上述的问题。</p> <p>这个模式可以保证多台服务器的数据一致性，且主从服务器之间采用的是「读写分离」的方式。</p> <p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/2b7231b6aabb9a9a2e2390ab3a280b2d-20230309232920063.png" alt="图片"></p> <p>也就是说，所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。</p> <p>同步这两个字说的简单，但是这个同步过程并没有想象中那么简单，要考虑的事情不是一两个。</p> <p>我们先来看看，主从服务器间的第一次同步是如何工作的？</p> <h2 id="第一次同步"><a href="#第一次同步" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>第一次同步</h2> <p>多台服务器之间要通过什么方式来确定谁是主服务器，或者谁是从服务器呢？</p> <p>我们可以使用 <code>replicaof</code>（Redis 5.0 之前使用 slaveof）命令形成主服务器和从服务器的关系。</p> <p>比如，现在有服务器 A 和 服务器 B，我们在服务器 B 上执行下面这条命令：</p> <div class="language-text extra-class"><pre class="language-text"><code># 服务器 B 执行这条命令
replicaof &amp;lt;服务器 A 的 IP 地址&gt; &amp;lt;服务器 A 的 Redis 端口号&gt;
</code></pre></div><p>接着，服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步。</p> <p>主从服务器间的第一次同步的过程可分为三个阶段：</p> <ul><li>第一阶段是建立链接、协商同步；</li> <li>第二阶段是主服务器同步数据给从服务器；</li> <li>第三阶段是主服务器发送新写操作命令给从服务器。</li></ul> <p>为了让你更清楚了解这三个阶段，我画了一张图。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/ea4f7e86baf2435af3999e5cd38b6a26.png" alt="图片"></p> <p>接下来，我在具体介绍每一个阶段都做了什么。</p> <p><em>第一阶段：建立链接、协商同步</em></p> <p>执行了 replicaof 命令后，从服务器就会给主服务器发送 <code>psync</code> 命令，表示要进行数据同步。</p> <p>psync 命令包含两个参数，分别是<strong>主服务器的 runID</strong> 和<strong>复制进度 offset</strong>。</p> <ul><li>runID，每个 Redis 服务器在启动时都会自动生产一个随机的 ID 来唯一标识自己。当从服务器和主服务器第一次同步时，因为不知道主服务器的 run ID，所以将其设置为 &quot;?&quot;。</li> <li>offset，表示复制的进度，第一次同步时，其值为 -1。</li></ul> <p>主服务器收到 psync 命令后，会用 <code>FULLRESYNC</code> 作为响应命令返回给对方。</p> <p>并且这个响应命令会带上两个参数：主服务器的 runID 和主服务器目前的复制进度 offset。从服务器收到响应后，会记录这两个值。</p> <p>FULLRESYNC 响应命令的意图是采用<strong>全量复制</strong>的方式，也就是主服务器会把所有的数据都同步给从服务器。</p> <p>所以，第一阶段的工作时为了全量复制做准备。</p> <p>那具体怎么全量同步呀呢？我们可以往下看第二阶段。</p> <p><em>第二阶段：主服务器同步数据给从服务器</em></p> <p>接着，主服务器会执行 bgsave 命令来生成 RDB 文件，然后把文件发送给从服务器。</p> <p>从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件。</p> <p>这里有一点要注意，主服务器生成 RDB 这个过程是不会阻塞主线程的，因为 bgsave 命令是产生了一个子进程来做生成 RDB 文件的工作，是异步工作的，这样 Redis 依然可以正常处理命令。</p> <p>但是，这期间的写操作命令并没有记录到刚刚生成的 RDB 文件中，这时主从服务器间的数据就不一致了。</p> <p>那么为了保证主从服务器的数据一致性，<strong>主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里</strong>：</p> <ul><li>主服务器生成 RDB 文件期间；</li> <li>主服务器发送 RDB 文件给从服务器期间；</li> <li>「从服务器」加载 RDB 文件期间；</li></ul> <p><em>第三阶段：主服务器发送新写操作命令给从服务器</em></p> <p>在主服务器生成的 RDB 文件发送完，从服务器收到 RDB 文件后，丢弃所有旧数据，将 RDB 数据载入到内存。完成 RDB 的载入后，会回复一个确认消息给主服务器。</p> <p>接着，主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行来自主服务器 replication buffer 缓冲区里发来的命令，这时主从服务器的数据就一致了。</p> <p>至此，主从服务器的第一次同步的工作就完成了。</p> <h2 id="命令传播"><a href="#命令传播" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>命令传播</h2> <p>主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/03eacec67cc58ff8d5819d0872ddd41e.png" alt="图片"></p> <p>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。</p> <p>而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。</p> <p>上面的这个过程被称为<strong>基于长连接的命令传播</strong>，通过这种方式来保证第一次同步后的主从服务器的数据一致性。</p> <h2 id="分摊主服务器的压力"><a href="#分摊主服务器的压力" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E5%88%86%E6%91%8A%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%8E%8B%E5%8A%9B" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>分摊主服务器的压力</h2> <p>在前面的分析中，我们可以知道主从服务器在第一次数据同步的过程中，主服务器会做两件耗时的操作：生成 RDB 文件和传输 RDB 文件。</p> <p>主服务器是可以有多个从服务器的，如果从服务器数量非常多，而且都与主服务器进行全量同步的话，就会带来两个问题：</p> <ul><li>由于是通过 bgsave 命令来生成 RDB 文件的，那么主服务器就会忙于使用 fork() 创建子进程，如果主服务器的内存数据非大，在执行 fork() 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求；</li> <li>传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响。</li></ul> <p>这种情况就好像，刚创业的公司，由于人不多，所以员工都归老板一个人管，但是随着公司的发展，人员的扩充，老板慢慢就无法承担全部员工的管理工作了。</p> <p>要解决这个问题，老板就需要设立经理职位，由经理管理多名普通员工，然后老板只需要管理经理就好。</p> <p>Redis 也是一样的，从服务器可以有自己的从服务器，我们可以把拥有从服务器的从服务器当作经理角色，它不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器的形式将数据同步给从服务器，组织形式如下图：</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/4d850bfe8d712d3d67ff13e59b919452.png" alt="图片"></p> <p>通过这种方式，<strong>主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器</strong>。</p> <p>那具体怎么做到的呢？</p> <p>其实很简单，我们在「从服务器」上执行下面这条命令，使其作为目标服务器的从服务器：</p> <div class="language-text extra-class"><pre class="language-text"><code>replicaof &amp;lt;目标服务器的IP&gt; 6379
</code></pre></div><p>此时如果目标服务器本身也是「从服务器」，那么该目标服务器就会成为「经理」的角色，不仅可以接受主服务器同步的数据，也会把数据同步给自己旗下的从服务器，从而减轻主服务器的负担。</p> <h2 id="增量复制"><a href="#增量复制" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>增量复制</h2> <p>主从服务器在完成第一次同步后，就会基于长连接进行命令传播。</p> <p>可是，网络总是不按套路出牌的嘛，说延迟就延迟，说断开就断开。</p> <p>如果主从服务器间的网络连接断开了，那么就无法进行命令传播了，这时从服务器的数据就没办法和主服务器保持一致了，客户端就可能从「从服务器」读到旧的数据。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/4845008abadaa871613873f5ffdcb542.png" alt="图片"></p> <p>那么问题来了，如果此时断开的网络，又恢复正常了，要怎么继续保证主从服务器的数据一致性呢？</p> <p>在 Redis 2.8 之前，如果主从服务器在命令同步时出现了网络断开又恢复的情况，从服务器就会和主服务器重新进行一次全量复制，很明显这样的开销太大了，必须要改进一波。</p> <p>所以，从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用<strong>增量复制</strong>的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。</p> <p>网络恢复后的增量复制过程如下图：</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/e081b470870daeb763062bb873a4477e.png" alt="图片"></p> <p>主要有三个步骤：</p> <ul><li>从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1；</li> <li>主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li> <li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li></ul> <p>那么关键的问题来了，<strong>主服务器怎么知道要将哪些增量数据发送给从服务器呢？</strong></p> <p>答案藏在这两个东西里：</p> <ul><li><strong>repl_backlog_buffer</strong>，是一个「<strong>环形</strong>」缓冲区，用于主从服务器断连后，从中找到差异的数据；</li> <li><strong>replication offset</strong>，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「<em>写</em>」到的位置，从服务器使用 slave_repl_offset 来记录自己「<em>读</em>」到的位置。</li></ul> <p>那 repl_backlog_buffer 缓冲区是什么时候写入的呢？</p> <p>在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里，因此 这个缓冲区里会保存着最近传播的写命令。</p> <p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：</p> <ul><li>如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>增量同步</strong>的方式；</li> <li>相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>全量同步</strong>的方式。</li></ul> <p>当主服务器在 repl_backlog_buffer 中找到主从服务器差异（增量）的数据后，就会将增量的数据写入到 replication buffer 缓冲区，这个缓冲区我们前面也提到过，它是缓存将要传播给从服务器的命令。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/2db4831516b9a8b79f833cf0593c1f12.png" alt="图片"></p> <p>repl_backlog_buffer 缓行缓冲区的默认大小是 1M，并且由于它是一个环形缓冲区，所以当缓冲区写满后，主服务器继续写入的话，就会覆盖之前的数据。因此，当主服务器的写入速度远超于从服务器的读取速度，缓冲区的数据一下就会被覆盖。</p> <p>那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用全量同步，这个方式比增量同步的性能损耗要大很多。</p> <p>因此，<strong>为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些</strong>，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。</p> <p>那 repl_backlog_buffer 缓冲区具体要调整到多大呢？</p> <p>repl_backlog_buffer 最小的大小可以根据这面这个公式估算。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/5e9e65a4a59b3688fa37cadbd87bb5ac.png" alt="图片"></p> <p>我来解释下这个公式的意思：</p> <ul><li>second 为从服务器断线后重新连接上主服务器所需的平均 时间(以秒计算)。</li> <li>write_size_per_second 则是主服务器平均每秒产生的写命令数据量大小。</li></ul> <p>举个例子，如果主服务器平均每秒产生 1 MB 的写命令，而从服务器断线之后平均要 5 秒才能重新连接主服务器。</p> <p>那么 repl_backlog_buffer 大小就不能低于 5 MB，否则新写地命令就会覆盖旧数据了。</p> <p>当然，为了应对一些突发的情况，可以将 repl_backlog_buffer 的大小设置为此基础上的 2 倍，也就是 10 MB。</p> <p>关于 repl_backlog_buffer 大小修改的方法，只需要修改配置文件里下面这个参数项的值就可以。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>repl-backlog-size 1mb
</code></pre></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>主从复制共有三种模式：<strong>全量复制、基于长连接的命令传播、增量复制</strong>。</p> <p>主从服务器第一次同步的时候，就是采用全量复制，此时主服务器会两个耗时的地方，分别是生成 RDB 文件和传输 RDB 文件。为了避免过多的从服务器和主服务器进行全量复制，可以把一部分从服务器升级为「经理角色」，让它也有自己的从服务器，通过这样可以分摊主服务器的压力。</p> <p>第一次同步完成后，主从服务器都会维护着一个长连接，主服务器在接收到写操作命令后，就会通过这个连接将写命令传播给从服务器，来保证主从服务器的数据一致性。</p> <p>如果遇到网络断开，增量复制就可以上场了，不过这个还跟 repl_backlog_size 这个大小有关系。</p> <p>如果它配置的过小，主从服务器网络恢复时，可能发生「从服务器」想读的数据已经被覆盖了，那么这时就会导致主服务器采用全量复制的方式。所以为了避免这种情况的频繁发生，要调大这个参数的值，以降低主从服务器断开后全量同步的概率。</p> <h2 id="面试题"><a href="#面试题" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E9%9D%A2%E8%AF%95%E9%A2%98" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>面试题</h2> <h3 id="redis主从节点时长连接还是短连接"><a href="#redis主从节点时长连接还是短连接" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#redis%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E6%97%B6%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%BF%98%E6%98%AF%E7%9F%AD%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>Redis主从节点时长连接还是短连接？</h3> <p>长连接</p> <h3 id="怎么判断-redis-某个节点是否正常工作"><a href="#怎么判断-redis-某个节点是否正常工作" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD-redis-%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>怎么判断 Redis 某个节点是否正常工作？</h3> <p>Redis 判断节点是否正常工作，基本都是通过互相的 ping-pong 心态检测机制，如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接。</p> <p>Redis 主从节点发送的心态间隔是不一样的，而且作用也有一点区别：</p> <ul><li>Redis 主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态，可通过参数repl-ping-slave-period控制发送频率。</li> <li>Redis 从节点每隔 1 秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量，目的是为了：
<ul><li>实时监测主从节点网络状态；</li> <li>上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。</li></ul></li></ul> <h3 id="主从复制架构中-过期key如何处理"><a href="#主从复制架构中-过期key如何处理" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84%E4%B8%AD-%E8%BF%87%E6%9C%9Fkey%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>主从复制架构中，过期key如何处理？</h3> <p>主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作。</p> <h3 id="redis-是同步复制还是异步复制"><a href="#redis-是同步复制还是异步复制" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#redis-%E6%98%AF%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>Redis 是同步复制还是异步复制？</h3> <p>Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点。</p> <h3 id="主从复制中两个-buffer-replication-buffer-、repl-backlog-buffer-有什么区别"><a href="#主从复制中两个-buffer-replication-buffer-、repl-backlog-buffer-有什么区别" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%AD%E4%B8%A4%E4%B8%AA-buffer-replication-buffer-%E3%80%81repl-backlog-buffer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？</h3> <p>replication buffer 、repl backlog buffer 区别如下：</p> <ul><li>出现的阶段不一样：
<ul><li>repl backlog buffer 是在增量复制阶段出现，<strong>一个主节点只分配一个 repl backlog buffer</strong>；</li> <li>replication buffer 是在全量复制阶段和增量复制阶段都会出现，<strong>主节点会给每个新连接的从节点，分配一个 replication buffer</strong>；</li></ul></li> <li>这两个 Buffer 都有大小限制的，当缓冲区满了之后，发生的事情不一样：
<ul><li>当 repl backlog buffer 满了，因为是环形结构，会直接<strong>覆盖起始位置数据</strong>;</li> <li>当 replication buffer 满了，会导致连接断开，删除缓存，从节点重新连接，<strong>重新开始全量复制</strong>。</li></ul></li></ul> <h3 id="如何应对主从数据不一致"><a href="#如何应对主从数据不一致" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>如何应对主从数据不一致？</h3> <blockquote><p>为什么会出现主从数据不一致？</p></blockquote> <p>主从数据不一致，就是指客户端从从节点中读取到的值和主节点中的最新值并不一致。</p> <p>之所以会出现主从数据不一致的现象，是<strong>因为主从节点间的命令复制是异步进行的</strong>，所以无法实现强一致性保证（主从数据时时刻刻保持一致）。</p> <p>具体来说，在主从节点命令传播阶段，主节点收到新的写命令后，会发送给从节点。但是，主节点并不会等到从节点实际执行完命令后，再把结果返回给客户端，而是主节点自己在本地执行完命令后，就会向客户端返回结果了。如果从节点还没有执行主节点同步过来的命令，主从节点间的数据就不一致了。</p> <blockquote><p>如何如何应对主从数据不一致？</p></blockquote> <p>第一种方法，尽量保证主从节点间的网络连接状况良好，避免主从节点在不同的机房。</p> <p>第二种方法，可以开发一个外部程序来监控主从节点间的复制进度。具体做法：</p> <ul><li>Redis 的 INFO replication 命令可以查看主节点接收写命令的进度信息（master_repl_offset）和从节点复制写命令的进度信息（slave_repl_offset），所以，我们就可以开发一个监控程序，先用 INFO replication 命令查到主、从节点的进度，然后，我们用 master_repl_offset 减去 slave_repl_offset，这样就能得到从节点和主节点间的复制进度差值了。</li> <li>如果某个从节点的进度差值大于我们预设的阈值，我们可以让客户端不再和这个从节点连接进行数据读取，这样就可以减少读到不一致数据的情况。不过，为了避免出现客户端和所有从节点都不能连接的情况，我们需要把复制进度差值的阈值设置得大一些。</li></ul> <h3 id="主从切换如何减少数据丢失"><a href="#主从切换如何减少数据丢失" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>主从切换如何减少数据丢失？</h3> <p>主从切换过程中，产生数据丢失的情况有两种：</p> <ul><li>异步复制同步丢失</li> <li>集群产生脑裂数据丢失</li></ul> <p>我们不可能保证数据完全不丢失，只能做到使得尽量少的数据丢失。</p> <h4 id="异步复制同步丢失"><a href="#异步复制同步丢失" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%E5%90%8C%E6%AD%A5%E4%B8%A2%E5%A4%B1" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>异步复制同步丢失</h4> <p>对于 Redis 主节点与从节点之间的数据复制，是异步复制的，当客户端发送写请求给主节点的时候，客户端会返回 ok，接着主节点将写请求异步同步给各个从节点，但是如果此时主节点还没来得及同步给从节点时发生了断电，那么主节点内存中的数据会丢失。</p> <blockquote><p>减少异步复制的数据丢失的方案</p></blockquote> <p>Redis 配置里有一个参数 min-slaves-max-lag，表示一旦所有的从节点数据复制和同步的延迟都超过了 min-slaves-max-lag 定义的值，那么主节点就会拒绝接收任何请求。</p> <p>假设将 min-slaves-max-lag 配置为 10s 后，根据目前 master-&gt;slave 的复制速度，如果数据同步完成所需要时间超过10s，就会认为 master 未来宕机后损失的数据会很多，master 就拒绝写入新请求。这样就能将 master 和 slave 数据差控制在10s内，即使 master 宕机也只是这未复制的 10s 数据。</p> <p>那么对于客户端，当客户端发现 master 不可写后，我们可以采取降级措施，将数据暂时写入本地缓存和磁盘中，在一段时间（等 master 恢复正常）后重新写入 master 来保证数据不丢失，也可以将数据写入 kafka 消息队列，等 master 恢复正常，再隔一段时间去消费 kafka 中的数据，让将数据重新写入 master 。</p> <h4 id="集群产生脑裂数据丢失"><a href="#集群产生脑裂数据丢失" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E9%9B%86%E7%BE%A4%E4%BA%A7%E7%94%9F%E8%84%91%E8%A3%82%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>集群产生脑裂数据丢失</h4> <p>先来理解集群的脑裂现象，这就好比一个人有两个大脑，那么到底受谁控制呢？</p> <p>那么在 Redis 中，集群脑裂产生数据丢失的现象是怎样的呢？</p> <p>在 Redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。</p> <p>如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p> <p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在从节点中选举出一个 leeder 作为主节点，这时集群就有两个主节点了 —— <strong>脑裂出现了</strong>。</p> <p>这时候网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，<strong>因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题</strong>。</p> <p>总结一句话就是：由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</p> <blockquote><p>减少脑裂的数据丢的方案</p></blockquote> <p>当主节点发现「从节点下线的数量太多」，或者「网络延迟太大」的时候，那么主节点会禁止写操作，直接把错误返回给客户端。</p> <p>在 Redis 的配置文件中有两个参数我们可以设置：</p> <ul><li>min-slaves-to-write x，主节点必须要有<strong>至少 x 个从节点连接</strong>，如果小于这个数，主节点会禁止写数据。</li> <li>min-slaves-max-lag x，主从数据复制和同步的延迟<strong>不能超过 x 秒</strong>，如果主从同步的延迟超过 x 秒，主节点会禁止写数据。</li></ul> <p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p> <p>这两个配置项组合后的要求是，<strong>主节点连接的从节点中至少有 N 个从节点，「并且」主节点进行数据复制时的 ACK 消息延迟不能超过 T 秒</strong>，否则，主节点就不会再接收客户端的写请求了。</p> <p>即使原主节点是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从节点进行同步，自然也就无法和从节点进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，<strong>原主节点就会被限制接收客户端写请求，客户端也就不能在原主节点中写入新数据了</strong>。</p> <p><strong>等到新主节点上线时，就只有新主节点能接收和处理客户端请求，此时，新写的数据会被直接写到新主节点中。而原主节点会被哨兵降为从节点，即使它的数据被清空了，也不会有新数据丢失。我再来给你举个例子。</strong></p> <p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主节点因为某些原因卡住了 15s，导致哨兵判断主节点客观下线，开始进行主从切换。同时，因为原主节点卡住了 15s，没有一个从节点能和原主节点在 12s 内进行数据复制，原主节点也无法接收客户端请求了。这样一来，主从切换完成后，也只有新主节点能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p> <h3 id="主从如何做到故障自动切换"><a href="#主从如何做到故障自动切换" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html#%E4%B8%BB%E4%BB%8E%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E6%95%85%E9%9A%9C%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>主从如何做到故障自动切换？</h3> <p>主节点挂了 ，从节点是无法自动升级为主节点的，这个过程需要人工处理，在此期间 Redis 无法对外提供写操作。</p> <p>此时，Redis 哨兵机制就登场了，哨兵在发现主节点出现故障时，由哨兵自动完成故障发现和故障转移，并通知给应用方，从而实现高可用性。</p> <h1 id="为什么要有哨兵"><a href="#为什么要有哨兵" class="header-anchor">#</a> 为什么要有哨兵？</h1> <p>大家好，我是小林。</p> <p>这次聊聊，Redis 的哨兵机制。</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E5%93%A8%E5%85%B5%E6%8F%90%E7%BA%B2.png" alt="img"></p> <h2 id="为什么要有哨兵机制"><a href="#为什么要有哨兵机制" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>为什么要有哨兵机制？</h2> <p>在 Redis 的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/db568766644a4d10b8a91cdd2f8a4070.png" alt="主节点挂了"></p> <p>这时如果要恢复服务的话，需要人工介入，选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点，同时还需要通知上游那些连接 Redis 主节点的客户端，将其配置中的主节点 IP 地址更新为「新主节点」的 IP 地址。</p> <p>这样也不太“智能”了，要是有一个节点能监控「主节点」的状态，当发现主节点挂了 ，它自动将一个「从节点」切换为「主节点」的话，那么可以节省我们很多事情啊！</p> <p>Redis 在 2.8 版本以后提供的<strong>哨兵（*Sentinel*）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p> <h2 id="哨兵机制是如何工作的"><a href="#哨兵机制是如何工作的" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>哨兵机制是如何工作的？</h2> <p>哨兵其实是一个运行在特殊模式下的 Redis 进程，所以它也是一个节点。从“哨兵”这个名字也可以看得出来，它相当于是“观察者节点”，观察的对象是主从节点。</p> <p>当然，它不仅仅是观察那么简单，在它观察到有异常的状况下，会做出一些“动作”，来修复异常状态。</p> <p>哨兵节点主要负责三件事情：<strong>监控、选主、通知</strong>。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/775865f6bd894dfba8d373ee54d79af1.png" alt="哨兵的职责"></p> <p>所以，我们重点要学习这三件事情：</p> <ul><li>哨兵节点是如何监控节点的？又是如何判断主节点是否真的故障了？</li> <li>根据什么规则选择一个从节点切换为主节点？</li> <li>怎么把新主节点的相关信息通知给从节点和客户端呢？</li></ul> <h2 id="如何判断主节点真的故障了"><a href="#如何判断主节点真的故障了" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%BB%E8%8A%82%E7%82%B9%E7%9C%9F%E7%9A%84%E6%95%85%E9%9A%9C%E4%BA%86" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>如何判断主节点真的故障了？</h2> <p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/26f88373d8454682b9e0c1d4fd1611b4-20230309233114856.png" alt="哨兵监控主从节点"></p> <p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「<strong>主观下线</strong>」。这个「规定的时间」是配置项 <code>down-after-milliseconds</code> 参数设定的，单位是毫秒。</p> <blockquote><p>主观下线？难道还有客观下线？</p></blockquote> <p>是的没错，客观下线只适用于主节点。</p> <p>之所以针对「主节点」设计「主观下线」和「客观下线」两个状态，是因为有可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。</p> <p>所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成<strong>哨兵集群</strong>（<em>最少需要三台机器来部署哨兵集群</em>），<strong>通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况</strong>。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p> <p>具体是怎么判定主节点为「客观下线」的呢？</p> <p>当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/13e4361407ba46979e802eaa654dcf67.png" alt="img"></p> <p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p> <p>例如，现在有 3 个哨兵，quorum 配置的是 2，那么一个哨兵需要 2 张赞成票，就可以标记主节点为“客观下线”了。这 2 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。</p> <p>PS：quorum 的值一般设置为哨兵个数的二分之一加1，例如 3 个哨兵就设置 2。</p> <p>哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点。</p> <h2 id="由哪个哨兵进行主从故障转移"><a href="#由哪个哨兵进行主从故障转移" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E7%94%B1%E5%93%AA%E4%B8%AA%E5%93%A8%E5%85%B5%E8%BF%9B%E8%A1%8C%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>由哪个哨兵进行主从故障转移？</h2> <p>前面说过，为了更加“客观”的判断主节点故障了，一般不会只由单个哨兵的检测结果来判断，而是多个哨兵一起判断，这样可以减少误判概率，所以<strong>哨兵是以哨兵集群的方式存在的</strong>。</p> <p>问题来了，由哨兵集群中的哪个节点进行主从故障转移呢？</p> <p>所以这时候，还需要在哨兵集群中选出一个 leader，让 leader 来执行主从切换。</p> <p>选举 leader 的过程其实是一个投票的过程，在投票开始前，肯定得有个「候选者」。</p> <blockquote><p>那谁来作为候选者呢？</p></blockquote> <p>哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者，所谓的候选者就是想当 Leader 的哨兵。</p> <p>举个例子，假设有三个哨兵。当哨兵 B 先判断到主节点「主观下线后」，就会给其他实例发送 is-master-down-by-addr 命令。接着，其他哨兵会根据自己和主节点的网络连接情况，做出赞成投票或者拒绝投票的响应。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/d0bed80d28a543fd8dcd299d4b06cf04.png" alt="img"></p> <p>当哨兵 B 收到赞成票数达到哨兵配置文件中的 quorum 配置项设定的值后，就会将主节点标记为「客观下线」，此时的哨兵 B 就是一个Leader 候选者。</p> <blockquote><p>候选者如何选举成为 Leader？</p></blockquote> <p>候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。</p> <p>每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。</p> <p>那么在投票过程中，任何一个「候选者」，要满足两个条件：</p> <ul><li>第一，拿到半数以上的赞成票；</li> <li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li></ul> <p>举个例子，假设哨兵节点有 3 个，quorum 设置为 2，那么任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以选举成功了。如果没有满足条件，就需要重新进行选举。</p> <p>这时候有的同学就会问了，如果某个时间点，刚好有两个哨兵节点判断到主节点为客观下线，那这时不就有两个候选者了？这时该如何决定谁是 Leader 呢？</p> <p>每位候选者都会先给自己投一票，然后向其他哨兵发起投票请求。如果投票者先收到「候选者 A」的投票请求，就会先投票给它，如果投票者用完投票机会后，收到「候选者 B」的投票请求后，就会拒绝投票。这时，候选者 A 先满足了上面的那两个条件，所以「候选者 A」就会被选举为 Leader。</p> <blockquote><p>为什么哨兵节点至少要有 3 个？</p></blockquote> <p>如果哨兵集群中只有 2 个哨兵节点，此时如果一个哨兵想要成功成为 Leader，必须获得 2 票，而不是 1 票。</p> <p>所以，如果哨兵集群中有个哨兵挂掉了，那么就只剩一个哨兵了，如果这个哨兵想要成为 Leader，这时票数就没办法达到 2 票，就无法成功成为 Leader，这时是无法进行主从节点切换的。</p> <p>因此，通常我们至少会配置 3 个哨兵节点。这时，如果哨兵集群中有个哨兵挂掉了，那么还剩下两个个哨兵，如果这个哨兵想要成为 Leader，这时还是有机会达到 2 票的，所以还是可以选举成功的，不会导致无法进行主从节点切换。</p> <p>当然，你要问，如果 3 个哨兵节点，挂了 2 个怎么办？这个时候得人为介入了，或者增加多一点哨兵节点。</p> <p>再说一个问题，Redis 1 主 4 从，5 个哨兵 ，quorum 设置为 3，如果 2 个哨兵故障，当主节点宕机时，哨兵能否判断主节点“客观下线”？主从能否自动切换？</p> <ul><li><strong>哨兵集群可以判定主节点“客观下线”</strong>。哨兵集群还剩下 3 个哨兵，当一个哨兵判断主节点“主观下线”后，询问另外 2 个哨兵后，有可能能拿到 3 张赞同票，这时就达到了 quorum 的值，因此，哨兵集群可以判定主节点为“客观下线”。</li> <li><strong>哨兵集群可以完成主从切换</strong>。当有个哨兵标记主节点为「客观下线」后，就会进行选举 Leader 的过程，因为此时哨兵集群还剩下 3 个哨兵，那么还是可以拿到半数以上（5/2+1=3）的票，而且也达到了 quorum 值，满足了选举 Leader 的两个条件， 所以就能选举成功，因此哨兵集群可以完成主从切换。</li></ul> <p>如果 quorum 设置为 2 ，并且如果有 3 个哨兵故障的话。此时哨兵集群还是可以判定主节点为“客观下线”，但是哨兵不能完成主从切换了，大家可以自己推演下。</p> <p>如果 quorum 设置为 3，并且如果有 3 个哨兵故障的话，哨兵集群即不能判定主节点为“客观下线”，也不能完成主从切换了。</p> <p>可以看到，quorum 为 2 的时候，并且如果有 3 个哨兵故障的话，虽然可以判定主节点为“客观下线”，但是不能完成主从切换，这样感觉「判定主节点为客观下线」这件事情白做了一样，既然这样，还不如不要做，quorum 为 3 的时候，就可以避免这种无用功。</p> <p>所以，<strong>quorum 的值建议设置为哨兵个数的二分之一加1</strong>，例如 3 个哨兵就设置 2，5 个哨兵设置为 3，而且<strong>哨兵节点的数量应该是奇数</strong>。</p> <h2 id="主从故障转移的过程是怎样的"><a href="#主从故障转移的过程是怎样的" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>主从故障转移的过程是怎样的？</h2> <p>在哨兵集群中通过投票的方式，选举出了哨兵 leader 后，就可以进行主从故障转移的过程了，如下图：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png" alt="img"></p> <p>主从故障转移操作包含以下四个步骤：</p> <ul><li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。</li> <li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li> <li>第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；</li> <li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li></ul> <h3 id="步骤一-选出新主节点"><a href="#步骤一-选出新主节点" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E6%AD%A5%E9%AA%A4%E4%B8%80-%E9%80%89%E5%87%BA%E6%96%B0%E4%B8%BB%E8%8A%82%E7%82%B9" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>步骤一：选出新主节点</h3> <p>故障转移操作第一步要做的就是在已下线主节点属下的所有「从节点」中，挑选出一个状态良好、数据完整的从节点，然后向这个「从节点」发送 SLAVEOF no one 命令，将这个「从节点」转换为「主节点」。</p> <p>那么多「从节点」，到底选择哪个从节点作为新主节点的？</p> <p>随机的方式好吗？随机的方式，实现起来很简单，但是如果选到一个网络状态不好的从节点作为新主节点，那么可能在将来不久又要做一次主从故障迁移。</p> <p>所以，我们首先要把网络状态不好的从节点给过滤掉。首先把已经下线的从节点过滤掉，然后把以往网络连接状态不好的从节点也给过滤掉。</p> <p>怎么判断从节点之前的网络连接状态不好呢？</p> <p>Redis 有个叫 down-after-milliseconds * 10 配置项，其down-after-milliseconds 是主从节点断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从节点的网络状况不好，不适合作为新主节点。</p> <p>至此，我们就把网络状态不好的从节点过滤掉了，接下来要对所有从节点进行三轮考察：<strong>优先级、复制进度、ID 号</strong>。在进行每一轮考察的时候，哪个从节点优先胜出，就选择其作为新主节点。</p> <ul><li>第一轮考察：哨兵首先会根据从节点的优先级来进行排序，优先级越小排名越靠前，</li> <li>第二轮考察：如果优先级相同，则查看复制的下标，哪个从「主节点」接收的复制数据多，哪个就靠前。</li> <li>第三轮考察：如果优先级和下标都相同，就选择从节点 ID 较小的那个。</li></ul> <h4 id="第一轮考察-优先级最高的从节点胜出"><a href="#第一轮考察-优先级最高的从节点胜出" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E7%AC%AC%E4%B8%80%E8%BD%AE%E8%80%83%E5%AF%9F-%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E9%AB%98%E7%9A%84%E4%BB%8E%E8%8A%82%E7%82%B9%E8%83%9C%E5%87%BA" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>第一轮考察：优先级最高的从节点胜出</h4> <p>Redis 有个叫 slave-priority 配置项，可以给从节点设置优先级。</p> <p>每一台从节点的服务器配置不一定是相同的，我们可以根据服务器性能配置来设置从节点的优先级。</p> <p>比如，如果 「 A 从节点」的物理内存是所有从节点中最大的， 那么我们可以把「 A 从节点」的优先级设置成最高。这样当哨兵进行第一轮考虑的时候，优先级最高的 A 从节点就会优先胜出，于是就会成为新主节点。</p> <h4 id="第二轮考察-复制进度最靠前的从节点胜出"><a href="#第二轮考察-复制进度最靠前的从节点胜出" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E7%AC%AC%E4%BA%8C%E8%BD%AE%E8%80%83%E5%AF%9F-%E5%A4%8D%E5%88%B6%E8%BF%9B%E5%BA%A6%E6%9C%80%E9%9D%A0%E5%89%8D%E7%9A%84%E4%BB%8E%E8%8A%82%E7%82%B9%E8%83%9C%E5%87%BA" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>第二轮考察：复制进度最靠前的从节点胜出</h4> <p>如果在第一轮考察中，发现优先级最高的从节点有两个，那么就会进行第二轮考察，比较两个从节点哪个复制进度。</p> <p>什么是复制进度？主从架构中，主节点会将写操作同步给从节点，在这个过程中，主节点会用 master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置（如下图中的「主服务器已经写入的数据」的位置），而从节点会用 slave_repl_offset 这个值记录当前的复制进度（如下图中的「从服务器要读的位置」的位置）。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/2db4831516b9a8b79f833cf0593c1f12-20230310003208754.png" alt="img"></p> <p>如果某个从节点的 slave_repl_offset 最接近 master_repl_offset，说明它的复制进度是最靠前的，于是就可以将它选为新主节点。</p> <h4 id="第三轮考察-id-号小的从节点胜出"><a href="#第三轮考察-id-号小的从节点胜出" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E7%AC%AC%E4%B8%89%E8%BD%AE%E8%80%83%E5%AF%9F-id-%E5%8F%B7%E5%B0%8F%E7%9A%84%E4%BB%8E%E8%8A%82%E7%82%B9%E8%83%9C%E5%87%BA" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>第三轮考察：ID 号小的从节点胜出</h4> <p>如果在第二轮考察中，发现有两个从节点优先级和复制进度都是一样的，那么就会进行第三轮考察，比较两个从节点的 ID 号，ID 号小的从节点胜出。</p> <p>什么是 ID 号？每个从节点都有一个编号，这个编号就是 ID 号，是用来唯一标识从节点的。</p> <p>到这里，选主的事情终于结束了。简单给大家总结下：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E9%80%89%E4%B8%BB%E8%BF%87%E7%A8%8B.webp" alt="img"></p> <p>在选举出从节点后，哨兵 leader 向被选中的从节点发送 <code>SLAVEOF no one</code> 命令，让这个从节点解除从节点的身份，将其变为新主节点。</p> <p>如下图，哨兵 leader 向被选中的从节点 server2 发送 <code>SLAVEOF no one</code> 命令，将该从节点升级为新主节点。</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E5%8D%87%E7%BA%A7%E4%BB%8E%E8%8A%82%E7%82%B9%E4%B8%BA%E4%B8%BB%E8%8A%82%E7%82%B9.png" alt="img"></p> <p>在发送 <code>SLAVEOF no one</code> 命令之后，哨兵 leader 会以每秒一次的频率向被升级的从节点发送 <code>INFO</code> 命令（没进行故障转移之前，<code>INFO</code> 命令的频率是每十秒一次），并观察命令回复中的角色信息，当被升级节点的角色信息从原来的 slave 变为 master 时，哨兵 leader 就知道被选中的从节点已经顺利升级为主节点了。</p> <p>如下图，选中的从节点 server2 升级成了新主节点：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E5%8D%87%E4%B8%BB%E8%8A%82%E7%82%B9%E6%88%90%E5%8A%9F.png" alt="img"></p> <h3 id="步骤二-将从节点指向新主节点"><a href="#步骤二-将从节点指向新主节点" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E6%AD%A5%E9%AA%A4%E4%BA%8C-%E5%B0%86%E4%BB%8E%E8%8A%82%E7%82%B9%E6%8C%87%E5%90%91%E6%96%B0%E4%B8%BB%E8%8A%82%E7%82%B9" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>步骤二：将从节点指向新主节点</h3> <p>当新主节点出现之后，哨兵 leader 下一步要做的就是，让已下线主节点属下的所有「从节点」指向「新主节点」，这一动作可以通过向「从节点」发送 <code>SLAVEOF</code> 命令来实现。</p> <p>如下图，哨兵 leader 向所有从节点（server3和server4）发送 <code>SLAVEOF</code> ，让它们成为新主节点的从节点。</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E4%BB%8E%E8%8A%82%E7%82%B9%E6%8C%87%E5%90%91%E6%96%B0%E4%B8%BB%E8%8A%82%E7%82%B9.png" alt="img"></p> <p>所有从节点指向新主节点后的拓扑图如下：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E4%BB%8E%E8%8A%82%E7%82%B9%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8A%9F.png" alt="img"></p> <h3 id="步骤三-通知客户的主节点已更换"><a href="#步骤三-通知客户的主节点已更换" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E6%AD%A5%E9%AA%A4%E4%B8%89-%E9%80%9A%E7%9F%A5%E5%AE%A2%E6%88%B7%E7%9A%84%E4%B8%BB%E8%8A%82%E7%82%B9%E5%B7%B2%E6%9B%B4%E6%8D%A2" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>步骤三：通知客户的主节点已更换</h3> <p>经过前面一系列的操作后，哨兵集群终于完成主从切换的工作，那么新主节点的信息要如何通知给客户端呢？</p> <p>这主要<strong>通过 Redis 的发布者/订阅者机制来实现</strong>的。每个哨兵节点提供发布者/订阅者机制，客户端可以从哨兵订阅消息。</p> <p>哨兵提供的消息订阅频道有很多，不同频道包含了主从节点切换过程中的不同关键事件，几个常见的事件如下：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E5%93%A8%E5%85%B5%E9%A2%91%E9%81%93.webp" alt="img"></p> <p>客户端和哨兵建立连接后，客户端会订阅哨兵提供的频道。<strong>主从切换完成后，哨兵就会向 <code>+switch-master</code> 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里面的新主节点的 IP 地址和端口进行通信了</strong>。</p> <p>通过发布者/订阅者机制机制，有了这些事件通知，客户端不仅可以在主从切换后得到新主节点的连接信息，还可以监控到主从节点切换过程中发生的各个重要事件。这样，客户端就可以知道主从切换进行到哪一步了，有助于了解切换进度。</p> <h3 id="步骤四-将旧主节点变为从节点"><a href="#步骤四-将旧主节点变为从节点" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E6%AD%A5%E9%AA%A4%E5%9B%9B-%E5%B0%86%E6%97%A7%E4%B8%BB%E8%8A%82%E7%82%B9%E5%8F%98%E4%B8%BA%E4%BB%8E%E8%8A%82%E7%82%B9" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>步骤四：将旧主节点变为从节点</h3> <p>故障转移操作最后要做的是，继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 <code>SLAVEOF</code> 命令，让它成为新主节点的从节点，如下图：</p> <p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E6%97%A7%E4%B8%BB%E8%8A%82%E7%82%B9%E5%8F%98%E4%B8%BA%E6%96%B0%E4%B8%BB%E8%8A%82%E7%82%B9.png" alt="img"></p> <p>至此，整个主从节点的故障转移的工作结束。</p> <h2 id="哨兵集群是如何组成的"><a href="#哨兵集群是如何组成的" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E6%88%90%E7%9A%84" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>哨兵集群是如何组成的？</h2> <p>前面提到了 Redis 的发布者/订阅者机制，那就不得不提一下哨兵集群的组成方式，因为它也用到了这个技术。</p> <p>在我第一次搭建哨兵集群的时候，当时觉得很诧异。因为在配置哨兵的信息时，竟然只需要填下面这几个参数，设置主节点名字、主节点的 IP 地址和端口号以及 quorum 值。</p> <div class="language-c extra-class"><pre class="language-c"><code>sentinel monitor <span class="token operator">&lt;</span>master<span class="token operator">-</span>name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>ip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>redis<span class="token operator">-</span>port<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>quorum<span class="token operator">&gt;</span> 
</code></pre></div><p>不需要填其他哨兵节点的信息，我就好奇它们是如何感知对方的，又是如何组成哨兵集群的？</p> <p>后面才了解到，<strong>哨兵节点之间是通过 Redis 的发布者/订阅者机制来相互发现的</strong>。</p> <p>在主从集群中，主节点上有一个名为<code>__sentinel__:hello</code>的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</p> <p>在下图中，哨兵 A 把自己的 IP 地址和端口的信息发布到<code>__sentinel__:hello</code> 频道上，哨兵 B 和 C 订阅了该频道。那么此时，哨兵 B 和 C 就可以从这个频道直接获取哨兵 A 的 IP 地址和端口号。然后，哨兵 B、C 可以和哨兵 A 建立网络连接。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/a6286053c6884cf58bf397d01674fe80.png" alt="img"></p> <p>通过这个方式，哨兵 B 和 C 也可以建立网络连接，这样一来，哨兵集群就形成了。</p> <blockquote><p>哨兵集群会对「从节点」的运行状态进行监控，那哨兵集群如何知道「从节点」的信息？</p></blockquote> <p>主节点知道所有「从节点」的信息，所以哨兵会每 10 秒一次的频率向主节点发送 INFO 命令来获取所有「从节点」的信息。</p> <p>如下图所示，哨兵 B 给主节点发送 INFO 命令，主节点接受到这个命令后，就会把从节点列表返回给哨兵。接着，哨兵就可以根据从节点列表中的连接信息，和每个从节点建立连接，并在这个连接上持续地对从节点进行监控。哨兵 A 和 C 可以通过相同的方法和从节点建立连接。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/fdd5f695bb3643258662886f9fba0aab.png" alt="img"></p> <p>正式通过 Redis 的发布者/订阅者机制，哨兵之间可以相互感知，然后组成集群，同时，哨兵又通过 INFO 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。</p> <h2 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> <a href="https://www.xiaolincoding.com/redis/cluster/sentinel.html#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>总结</h2> <p>Redis 在 2.8 版本以后提供的<strong>哨兵（*Sentinel*）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p> <p>哨兵一般是以集群的方式部署，至少需要 3 个哨兵节点，哨兵集群主要负责三件事情：<strong>监控、选主、通知</strong>。</p> <p>哨兵节点通过 Redis 的发布者/订阅者机制，哨兵之间可以相互感知，相互连接，然后组成哨兵集群，同时哨兵又通过 INFO 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。</p> <p><em>1、第一轮投票：判断主节点下线</em></p> <p>当哨兵集群中的某个哨兵判定主节点下线（主观下线）后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p> <p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p> <p><em>2、第二轮投票：选出哨兵leader</em></p> <p>某个哨兵判定主节点客观下线后，该哨兵就会发起投票，告诉其他哨兵，它想成为 leader，想成为 leader 的哨兵节点，要满足两个条件：</p> <ul><li>第一，拿到半数以上的赞成票；</li> <li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li></ul> <p><em>3、由哨兵 leader 进行主从故障转移</em></p> <p>选举出了哨兵 leader 后，就可以进行主从故障转移的过程了。该操作包含以下四个步骤：</p> <ul><li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点，选择的规则：
<ul><li>过滤掉已经离线的从节点；</li> <li>过滤掉历史网络连接状态不好的从节点；</li> <li>将剩下的从节点，进行三轮考察：优先级、复制进度、ID 号。在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点。</li></ul></li> <li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li> <li>第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；</li> <li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ifan/Notes/数据库/Redis/缓存篇.html" class="prev">
        缓存篇
      </a></span> <span class="next"><a href="/ifan/Notes/数据库/Redis/面试篇.html">
        面试篇
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ifan/assets/js/app.5e29002d.js" defer></script><script src="/ifan/assets/js/2.733019b2.js" defer></script><script src="/ifan/assets/js/83.7bac340f.js" defer></script>
  </body>
</html>
