<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试题 | Notes</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="办法总比问题多">
    
    <link rel="preload" href="/ifan/assets/css/0.styles.d46f727e.css" as="style"><link rel="preload" href="/ifan/assets/js/app.1d8f04c4.js" as="script"><link rel="preload" href="/ifan/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/ifan/assets/js/58.099f7ab4.js" as="script"><link rel="prefetch" href="/ifan/assets/js/10.9d2debbc.js"><link rel="prefetch" href="/ifan/assets/js/100.ce0650f4.js"><link rel="prefetch" href="/ifan/assets/js/11.b481b7e3.js"><link rel="prefetch" href="/ifan/assets/js/12.a1c93484.js"><link rel="prefetch" href="/ifan/assets/js/13.d78e499d.js"><link rel="prefetch" href="/ifan/assets/js/14.0d2150b9.js"><link rel="prefetch" href="/ifan/assets/js/15.01c694bf.js"><link rel="prefetch" href="/ifan/assets/js/16.d9b12807.js"><link rel="prefetch" href="/ifan/assets/js/17.43c1b0bd.js"><link rel="prefetch" href="/ifan/assets/js/18.903829cf.js"><link rel="prefetch" href="/ifan/assets/js/19.b1444637.js"><link rel="prefetch" href="/ifan/assets/js/20.efcc37f6.js"><link rel="prefetch" href="/ifan/assets/js/21.81da4056.js"><link rel="prefetch" href="/ifan/assets/js/22.2fa41b40.js"><link rel="prefetch" href="/ifan/assets/js/23.f343dea3.js"><link rel="prefetch" href="/ifan/assets/js/24.25c61120.js"><link rel="prefetch" href="/ifan/assets/js/25.9cb69cdb.js"><link rel="prefetch" href="/ifan/assets/js/26.1c1a1096.js"><link rel="prefetch" href="/ifan/assets/js/27.3e698f68.js"><link rel="prefetch" href="/ifan/assets/js/28.63f7f11e.js"><link rel="prefetch" href="/ifan/assets/js/29.8a400aa1.js"><link rel="prefetch" href="/ifan/assets/js/3.06be9fda.js"><link rel="prefetch" href="/ifan/assets/js/30.dd445b3e.js"><link rel="prefetch" href="/ifan/assets/js/31.21730518.js"><link rel="prefetch" href="/ifan/assets/js/32.698329c5.js"><link rel="prefetch" href="/ifan/assets/js/33.7fcf3386.js"><link rel="prefetch" href="/ifan/assets/js/34.3e9cf496.js"><link rel="prefetch" href="/ifan/assets/js/35.a5f742a8.js"><link rel="prefetch" href="/ifan/assets/js/36.5cdf7c9c.js"><link rel="prefetch" href="/ifan/assets/js/37.92b7c857.js"><link rel="prefetch" href="/ifan/assets/js/38.de0727c0.js"><link rel="prefetch" href="/ifan/assets/js/39.cd1d4ee5.js"><link rel="prefetch" href="/ifan/assets/js/4.0dd8aefa.js"><link rel="prefetch" href="/ifan/assets/js/40.e2d55b45.js"><link rel="prefetch" href="/ifan/assets/js/41.6fc8c625.js"><link rel="prefetch" href="/ifan/assets/js/42.f5669db3.js"><link rel="prefetch" href="/ifan/assets/js/43.0d002814.js"><link rel="prefetch" href="/ifan/assets/js/44.59193229.js"><link rel="prefetch" href="/ifan/assets/js/45.3933ef6d.js"><link rel="prefetch" href="/ifan/assets/js/46.1d702023.js"><link rel="prefetch" href="/ifan/assets/js/47.61263332.js"><link rel="prefetch" href="/ifan/assets/js/48.d1910cf7.js"><link rel="prefetch" href="/ifan/assets/js/49.ba295b07.js"><link rel="prefetch" href="/ifan/assets/js/5.14db227c.js"><link rel="prefetch" href="/ifan/assets/js/50.48945079.js"><link rel="prefetch" href="/ifan/assets/js/51.922c4a4a.js"><link rel="prefetch" href="/ifan/assets/js/52.90c41fbb.js"><link rel="prefetch" href="/ifan/assets/js/53.5b1ba980.js"><link rel="prefetch" href="/ifan/assets/js/54.8e84c44d.js"><link rel="prefetch" href="/ifan/assets/js/55.c277b13f.js"><link rel="prefetch" href="/ifan/assets/js/56.6d8a04a9.js"><link rel="prefetch" href="/ifan/assets/js/57.021c1663.js"><link rel="prefetch" href="/ifan/assets/js/59.e19ec6bd.js"><link rel="prefetch" href="/ifan/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/ifan/assets/js/60.4ece97ff.js"><link rel="prefetch" href="/ifan/assets/js/61.72dd49dc.js"><link rel="prefetch" href="/ifan/assets/js/62.2212d8af.js"><link rel="prefetch" href="/ifan/assets/js/63.cd2240fd.js"><link rel="prefetch" href="/ifan/assets/js/64.266f0c5f.js"><link rel="prefetch" href="/ifan/assets/js/65.e5dd692b.js"><link rel="prefetch" href="/ifan/assets/js/66.e97c1fb7.js"><link rel="prefetch" href="/ifan/assets/js/67.c99c58ad.js"><link rel="prefetch" href="/ifan/assets/js/68.1c7b8840.js"><link rel="prefetch" href="/ifan/assets/js/69.b1ce3ceb.js"><link rel="prefetch" href="/ifan/assets/js/7.54611d34.js"><link rel="prefetch" href="/ifan/assets/js/70.742be5c0.js"><link rel="prefetch" href="/ifan/assets/js/71.50dee511.js"><link rel="prefetch" href="/ifan/assets/js/72.0653d81c.js"><link rel="prefetch" href="/ifan/assets/js/73.7a6b4080.js"><link rel="prefetch" href="/ifan/assets/js/74.200096d7.js"><link rel="prefetch" href="/ifan/assets/js/75.7ad0d457.js"><link rel="prefetch" href="/ifan/assets/js/76.4dae384f.js"><link rel="prefetch" href="/ifan/assets/js/77.d23e58be.js"><link rel="prefetch" href="/ifan/assets/js/78.30da3aa8.js"><link rel="prefetch" href="/ifan/assets/js/79.77a53c0e.js"><link rel="prefetch" href="/ifan/assets/js/8.3c3e2ed8.js"><link rel="prefetch" href="/ifan/assets/js/80.3b3507b6.js"><link rel="prefetch" href="/ifan/assets/js/81.0633d028.js"><link rel="prefetch" href="/ifan/assets/js/82.3bb840ca.js"><link rel="prefetch" href="/ifan/assets/js/83.71d297d6.js"><link rel="prefetch" href="/ifan/assets/js/84.67ddf266.js"><link rel="prefetch" href="/ifan/assets/js/85.88236cdb.js"><link rel="prefetch" href="/ifan/assets/js/86.c46c3552.js"><link rel="prefetch" href="/ifan/assets/js/87.ed3b9cdf.js"><link rel="prefetch" href="/ifan/assets/js/88.9717ca00.js"><link rel="prefetch" href="/ifan/assets/js/89.7dd65246.js"><link rel="prefetch" href="/ifan/assets/js/9.46fdf317.js"><link rel="prefetch" href="/ifan/assets/js/90.48ce955c.js"><link rel="prefetch" href="/ifan/assets/js/91.e833ee44.js"><link rel="prefetch" href="/ifan/assets/js/92.b9973f76.js"><link rel="prefetch" href="/ifan/assets/js/93.d07c4aae.js"><link rel="prefetch" href="/ifan/assets/js/94.6980a27c.js"><link rel="prefetch" href="/ifan/assets/js/95.4cb983e3.js"><link rel="prefetch" href="/ifan/assets/js/96.54504fb8.js"><link rel="prefetch" href="/ifan/assets/js/97.ce4e7809.js"><link rel="prefetch" href="/ifan/assets/js/98.7b7b8e3c.js"><link rel="prefetch" href="/ifan/assets/js/99.023a5792.js">
    <link rel="stylesheet" href="/ifan/assets/css/0.styles.d46f727e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ifan/" class="home-link router-link-active"><!----> <span class="site-name">Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ifan/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="what?" class="dropdown-title"><span class="title">what?</span> <span class="arrow down"></span></button> <button type="button" aria-label="what?" class="mobile-dropdown-title"><span class="title">what?</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/ifan/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="what?" class="dropdown-title"><span class="title">what?</span> <span class="arrow down"></span></button> <button type="button" aria-label="what?" class="mobile-dropdown-title"><span class="title">what?</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Maven</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>软件测试相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringBoot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MySQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Netty</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Summary</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ifan/Notes/Summary/summary1.html" aria-current="page" class="active sidebar-link">summary1</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#面试题" class="sidebar-link">面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_1-高并发秒杀超卖问题" class="sidebar-link">1.高并发秒杀超卖问题</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_2-测试-淘宝购物车" class="sidebar-link">2.测试-淘宝购物车</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_3-典型电商促销场景下的云端压力测试实战" class="sidebar-link">3.典型电商促销场景下的云端压力测试实战</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_4-liunx下怎么查进程-怎么查端口" class="sidebar-link">4.liunx下怎么查进程，怎么查端口</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_5-线程池核心参数" class="sidebar-link">5.线程池核心参数</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_6-spring-涉及到的设计模式汇总" class="sidebar-link">6.Spring-涉及到的设计模式汇总</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_7-jdbc建立连接流程" class="sidebar-link">7. JDBC建立连接流程</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_8-布隆过滤器" class="sidebar-link">8.布隆过滤器</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_9-threadlocal" class="sidebar-link">9.ThreadLocal</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_10-session是什么-它与cookie有什么区别" class="sidebar-link">10.Session是什么？它与Cookie有什么区别？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_11-tomcat如何以及为什么要打破双亲委派模型-顺带介绍一下双亲委派模型" class="sidebar-link">11.tomcat如何以及为什么要打破双亲委派模型（顺带介绍一下双亲委派模型）</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_12-四种引用的应用场景" class="sidebar-link">12.四种引用的应用场景</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_13-redis哨兵如何实现通信-结点宕机如何处理" class="sidebar-link">13.Redis哨兵如何实现通信，结点宕机如何处理</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_14-spring如何解决ioc时的循环依赖问题" class="sidebar-link">14.Spring如何解决IOC时的循环依赖问题</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_15-一般是怎么创建线程" class="sidebar-link">15.一般是怎么创建线程?</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_16-线程池类型" class="sidebar-link">16.线程池类型</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_17-对象的生命周期" class="sidebar-link">17.对象的生命周期</a></li></ul></li></ul></li><li><a href="/ifan/Notes/Summary/设计模式.html" class="sidebar-link">设计模式</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java IO</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础和原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Notes</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="面试题"><a href="#面试题" class="header-anchor">#</a> 面试题</h2> <h3 id="_1-高并发秒杀超卖问题"><a href="#_1-高并发秒杀超卖问题" class="header-anchor">#</a> <strong>1.高并发秒杀超卖问题</strong></h3> <p>1.数据库层面的互斥锁，2.应用层面的分布式锁，3.redis的单线程特性+内存运行（预减库存，但存在缓存数据一致性问题）</p> <h3 id="_2-测试-淘宝购物车"><a href="#_2-测试-淘宝购物车" class="header-anchor">#</a> <strong>2.测试-淘宝购物车</strong></h3> <p>界面测试-功能测试-性能测试-兼容性测试-网络环境测试-异常测试（内存，网络，商品操作是清理后台应用有何影响）-本地-国际化测试（习俗，文化，语言）</p> <h3 id="_3-典型电商促销场景下的云端压力测试实战"><a href="#_3-典型电商促销场景下的云端压力测试实战" class="header-anchor">#</a> <strong>3.典型电商促销场景下的云端压力测试实战</strong></h3> <p>瞬间集中并发，传统压测工具Loadrunner和Jmeter，基础数据，热点数据，缓存数据，一次性数据</p> <p><strong>压测场景建模</strong></p> <p>完成业务场景建模后，基于其进行压测场景建模，这里要考虑到采用的测试策略，当然，测试策略的制定需要结合系统架构（需要梳理清各服务间的依赖和调用关系）和业务特点来说。</p> <p>比如抽奖抢券秒杀场景，就需要采用并发测试以及超卖验证等测试策略。</p> <p>考虑到业务配比的情况，我们还需要进行单接口的基准测试以及单机混合场景容量测试。</p> <p>核心业务流程，其特性要求系统具备高可用和稳定性，那么测试策略就需要采用高可用测试和稳定性测试。</p> <p><strong>1、压测</strong></p> <p>压测工作主要有如下几种情景，按照预先制定的测试策略执行即可（不排除临时特殊情况，这里需灵活调整）。</p> <p><strong>①、单机单接口测试</strong>：该策略主要是为了验证单接口的性能基准，避免整个调用链路过程中某个服务/接口成为瓶颈；</p> <p><strong>②、单机多接口测试</strong>：相较于微服务架构的服务解耦，有时候某些服务间互相调用依赖的强关系可能会造成资源竞争等情况，需要通过这种方式来排查验证；</p> <p><strong>③、单机混合场景测试</strong>：这种测试方式的主要作用是得到一个单机混合场景下的最优性能表现，为服务扩容和线上容量规划提供参考数据；</p> <p><strong>④、多节点测试</strong>：现在大多数的互联网企业都采用的集群/分布式/微服务架构，在多节点部署时候，考虑到SLB的边际递减效应，需要进行多节点测试；</p> <p>通过该种方式，来验证负载均衡递减比率，为生产扩容提供精确的参考依据；</p> <p><strong>⑤、高可用测试</strong>：高可用主要验证2点：<strong>服务异常/宕机是否可以恢复</strong>以及<strong>恢复到正常水*所耗费的时间</strong>（越短越好）。</p> <p><strong>⑥、稳定性测试</strong>：前面提到了核心业务流程必须保证稳定性，稳定性测试一般根据系统特点和业务类型，分为两类：5d<em>12h、7d</em>24h。</p> <p>一般来说，稳定性测试的执行时间，12h即可（当然，24h或者更长也可以，根据具体情况灵活调整）。</p> <p><img src="https://img2018.cnblogs.com/blog/983980/201906/983980-20190624003458858-843470018.png" alt="983980-20190624003458858-843470018"></p> <p>临时扩容或者服务降级限流甚至熔断等机制，保证系统在峰值流量下保持服务可用。</p> <h3 id="_4-liunx下怎么查进程-怎么查端口"><a href="#_4-liunx下怎么查进程-怎么查端口" class="header-anchor">#</a> <strong>4.liunx下怎么查进程，怎么查端口</strong></h3> <p>1、利用lsof命令查看，当命令参数设置为“-i”时用以显示符合条件的进程情况，语法为“lsof -i:端口号”；</p> <p>2、利用netstat命令查看，该命令会列出端口所有状态的连接，语法为“netstat-tunlp|grep 端口号”。</p> <h3 id="_5-线程池核心参数"><a href="#_5-线程池核心参数" class="header-anchor">#</a> <strong>5.线程池核心参数</strong></h3> <ol><li>corePoolSize：核心线程数。</li> <li>maximumPoolSize：最大线程数。<strong>线程池允许创建的最大线程数量，当线程池的任务队列满了之后，可以创建的最大线程数。</strong></li> <li>keepAliveTime：空闲线程存活时间。</li> <li>TimeUnit：时间单位。</li> <li>BlockingQueue：线程池任务队列。</li> <li>ThreadFactory：创建线程的工厂。</li> <li>RejectedExecutionHandler：拒绝策略。</li></ol> <p><strong>拒绝策略：当线程池的任务超出线程池队列可以存储的最大值之后，执行的策略。</strong>
默认的拒绝策略有以下 4 种：</p> <ul><li>AbortPolicy：拒绝并抛出异常。</li> <li>CallerRunsPolicy：使用当前调用的线程来执行此任务。</li> <li>DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。</li> <li>DiscardPolicy：忽略并抛弃当前任务。</li></ul> <p>线程池的默认策略是 AbortPolicy 拒绝并抛出异常。</p> <h3 id="_6-spring-涉及到的设计模式汇总"><a href="#_6-spring-涉及到的设计模式汇总" class="header-anchor">#</a> <strong>6.Spring-涉及到的设计模式汇总</strong></h3> <p><strong>1. 简单工厂</strong></p> <p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p> <p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p> <p><strong>2. 工厂方法（Factory Method）</strong></p> <p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p> <p><strong>3. 单例（Singleton）</strong></p> <p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p> <p>Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为Spring管理的是是任意的Java对象。</p> <p><strong>4. 适配器（Adapter）</strong></p> <p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p> <p>Spring中在对于AOP的处理中有Adapter模式的例子</p> <p><strong>5.包装器（Decorator）</strong></p> <p>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</p> <p><strong>6. 代理（Proxy）</strong></p> <p>为其他对象提供一种代理以控制对这个对象的访问。</p> <p>从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。</p> <p><strong>7.观察者（Observer）</strong></p> <p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p> <p><strong>8. 策略（Strategy）</strong></p> <p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p> <p><strong>9.模板方法（Template Method）</strong></p> <p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p> <p>Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。Spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。</p> <h3 id="_7-jdbc建立连接流程"><a href="#_7-jdbc建立连接流程" class="header-anchor">#</a> <strong>7. JDBC建立连接流程</strong></h3> <p>SPI（服务提供接口），定义标准，厂商实现接口，提供Jar包，ClassLoader记载对应的jar包，执行对应的方法。</p> <h3 id="_8-布隆过滤器"><a href="#_8-布隆过滤器" class="header-anchor">#</a> <strong>8.布隆过滤器</strong></h3> <p>布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。<strong>它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难</strong>。(布隆过滤器使用了K个hash函数计算，所有可能在多个位置hash索引为1，这样可能会出现一个从未索引的值，在布隆过滤器中可以被查询到的情况，误判（可预测比例）)<strong>当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中</strong>。</p> <p>利用布隆过滤器我们可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当根据 ID 进行数据查询的时候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是缓存穿透不能完全解决，我们只能将其控制在一个可以容忍的范围内。</p> <h3 id="_9-threadlocal"><a href="#_9-threadlocal" class="header-anchor">#</a> <strong>9.ThreadLocal</strong></h3> <p>https://pdai.tech/md/java/thread/java-thread-x-threadlocal.html</p> <h3 id="_10-session是什么-它与cookie有什么区别"><a href="#_10-session是什么-它与cookie有什么区别" class="header-anchor">#</a> <strong>10.<a href="https://segmentfault.com/a/1190000041429984" target="_blank" rel="noopener noreferrer">Session是什么？它与Cookie有什么区别？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></h3> <p>https://www.51cto.com/article/679219.html</p> <h3 id="_11-tomcat如何以及为什么要打破双亲委派模型-顺带介绍一下双亲委派模型"><a href="#_11-tomcat如何以及为什么要打破双亲委派模型-顺带介绍一下双亲委派模型" class="header-anchor">#</a> <strong>11.tomcat如何以及为什么要打破双亲委派模型（顺带介绍一下双亲委派模型）</strong></h3> <p>双亲委派模型（Parent Delegation Model）是Java类加载器的一种工作机制，它是Java安全模型的核心之一。在Java中，类加载器（ClassLoader）负责将类的字节码加载到内存中，并生成对应的Class对象供程序使用。双亲委派模型规定了类加载器的工作流程和层次结构，保证了类的加载的安全性和一致性。</p> <p>如果一个类加载器收到了加载某个类的请求，则该类加载器并不会去加载该类，而是把这个请求委派给父类加载器，每一个层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶端的启动类加载器；只有当父类加载器在其搜索范围内无法找到所需的类，并将该结果反馈给子类加载器，子类加载器会尝试去自己加载。</p> <p>双亲委派模型的基本原则是：当一个类加载器需要加载一个类时，它首先会将这个任务委托给父类加载器。如果父类加载器无法加载这个类，子类加载器才会尝试加载。这种委派机制一直向上追溯，直到顶层的启动类加载器（BootStrap ClassLoader）。</p> <p>双亲委派模型的优势在于保证了类的加载的唯一性和一致性。当一个类被加载后，它会被缓存在加载器的缓存中，下次再次加载这个类时，直接从缓存中取出，不再重新加载。这样可以避免重复加载同一个类，节省了内存空间，提高了系统的性能。</p> <p>双亲委派模型还增强了Java的安全性。通过委派机制，保证了核心类库的安全性，防止用户自定义的类替换核心类库中的类，避免了恶意代码的注入，提高了系统的稳定性和安全性。例如，当我们编写一个Java应用程序时，如果需要使用String类，那么首先会尝试从父类加载器中加载。只有当父类加载器无法加载时，才会尝试从当前类加载器中加载。这样就保证了我们使用的是JDK中的标准String类，而不是自己定义的String类。</p> <p>双亲委派模型还可以实现类的隔离和防止类的冲突。例如，如果两个不同的类加载器加载了同一个类，由于类加载器是独立的，它们会生成两个不同的Class对象，因此这两个类是不相等的，可以实现类的隔离和防止类的冲突。</p> <p>总结来说，双亲委派模型是Java类加载器的一种工作机制，通过委派机制和层次结构，保证了类的加载的安全性和一致性，增强了Java的安全性，实现了类的隔离和防止类的冲突。它是Java安全模型的重要组成部分，也是Java语言的一个重要特性。</p> <p>打破双亲委派模型（JDBC和Tomcat）</p> <p><strong>因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。</strong></p> <p>JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于 $JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，**根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。**也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。</p> <p><strong>Tomcat为什么要破坏双亲委派模型<a href="https://www.cnblogs.com/yueshutong/p/11430885.html#134638671" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></p> <p><strong>每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。</strong></p> <p>事实上，tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的：</p> <ul><li>对于各个 <code>webapp</code>中的 <code>class</code>和 <code>lib</code>，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。</li> <li>与 <code>jvm</code>一样的安全性问题。使用单独的 <code>classloader</code>去装载 <code>tomcat</code>自身的类库，以免其他恶意或无意的破坏；</li> <li>热部署。相信大家一定为 <code>tomcat</code>修改文件不用重启就自动重新装载类库而惊叹吧。</li></ul> <h3 id="_12-四种引用的应用场景"><a href="#_12-四种引用的应用场景" class="header-anchor">#</a> <strong>12.四种引用的应用场景</strong></h3> <p>Java中共有四种引用类型，包括强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference），它们各自有着不同的应用场景。</p> <ol><li>强引用（Strong Reference）： 强引用是指在程序中普遍存在的引用方式，如果一个对象具有强引用，那么垃圾收集器就不会回收它。当一个对象被多个强引用所引用时，垃圾收集器也不会回收它，直到所有强引用都被释放掉。</li></ol> <p>应用场景： 强引用通常用于对象的普通应用场景，例如在方法中创建对象并将其赋值给局部变量，或者在类中将对象作为成员变量存储。这些对象在程序运行期间一般都需要保持存在，因此使用强引用可以确保它们不会被垃圾收集器回收。</p> <ol><li>软引用（Soft Reference）： 软引用是一种比较弱的引用类型，如果一个对象只有软引用，则在系统内存不足时，垃圾收集器会将其回收。软引用通常用于缓存，如果内存充足，则可以从缓存中获取对象，否则需要重新创建。</li></ol> <p>应用场景： 软引用通常用于缓存和高速缓存的实现。在缓存中，一些经常使用的对象可以被存储在内存中，以便快速访问。如果系统内存不足，垃圾收集器会回收这些对象，从而释放内存。</p> <ol><li>弱引用（Weak Reference）： 弱引用是比软引用更弱的引用类型，如果一个对象只有弱引用，则在下一次垃圾收集时，无论内存是否充足，都会被回收。弱引用通常用于实现缓存或对象注册表，这些对象的生命周期通常比较短。</li></ol> <p>应用场景： 弱引用通常用于缓存或对象注册表中，这些对象的生命周期通常很短，但在某些情况下需要进行访问。通过使用弱引用，可以确保这些对象在不需要时可以被回收，从而避免内存泄漏。</p> <ol><li>虚引用（Phantom Reference）： 虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。虚引用是最弱的引用类型，它无法通过引用访问到对象，也无法通过引用获取到对象的状态。虚引用主要用于跟踪对象被垃圾回收的状态，可以通过虚引用观察到一个对象是否已经被垃圾收集器回收。</li></ol> <p>五，引用队列（ReferenceQueue）</p> <p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p> <p>与软引用、弱引用不同，虚引用必须和引用队列一起使用。</p> <p><strong>四种引用比较</strong></p> <table><thead><tr><th>引用类型</th> <th>被垃圾回收时间</th> <th>用途</th> <th>生存时间</th></tr></thead> <tbody><tr><td>强引用</td> <td>从来不会</td> <td>对象的一般状态</td> <td>JVM停止运行时终止</td></tr> <tr><td>软引用</td> <td>当内存不足时</td> <td>对象缓存</td> <td>内存不足时终止</td></tr> <tr><td>弱引用</td> <td>正常垃圾回收时</td> <td>对象缓存</td> <td>垃圾回收后终止</td></tr> <tr><td>虚引用</td> <td>正常垃圾回收时</td> <td>跟踪对象的垃圾回收</td> <td>垃圾回收后终止</td></tr></tbody></table> <h3 id="_13-redis哨兵如何实现通信-结点宕机如何处理"><a href="#_13-redis哨兵如何实现通信-结点宕机如何处理" class="header-anchor">#</a> <strong>13.Redis哨兵如何实现通信，结点宕机如何处理</strong></h3> <p>心跳机制-通信（master或者slave宕机）</p> <h3 id="_14-spring如何解决ioc时的循环依赖问题"><a href="#_14-spring如何解决ioc时的循环依赖问题" class="header-anchor">#</a> <strong>14.Spring如何解决IOC时的循环依赖问题</strong></h3> <p>如果不考虑Spring，循环依赖并不是问题，因为对象之间相互依赖是很正常的事情。比如</p> <div class="language-ini extra-class"><pre class="language-ini"><code><span class="token key attr-name">A a</span> <span class="token punctuation">=</span> <span class="token value attr-value">new A();</span>
<span class="token key attr-name">B b</span> <span class="token punctuation">=</span> <span class="token value attr-value">new B();</span>

<span class="token key attr-name">a.b</span> <span class="token punctuation">=</span> <span class="token value attr-value">b;</span>
<span class="token key attr-name">b.a</span> <span class="token punctuation">=</span> <span class="token value attr-value">a;</span>
</code></pre></div><p>这样，A,B就依赖上了。</p> <p><strong>Bean的生命周期</strong></p> <p>这里不会对Bean的生命周期进行详细的描述，只描述一下大概的过程。</p> <p>Bean的生命周期指的就是：在Spring中，Bean是如何生成的？</p> <p>被Spring管理的对象叫做Bean。Bean的生成步骤如下：</p> <ol><li><p>Spring扫描class得到BeanDefinition</p></li> <li><p>根据得到的BeanDefinition去生成bean</p></li> <li><p>首先根据class推断构造方法</p></li> <li><p>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</p></li> <li><p>填充原始对象中的属性（依赖注入）</p></li> <li><p>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象（这个是AOP切面类的对象）</p></li> <li><p>把最终生成的代理对象放入单例池（源码中叫做singletonObjects）中，下次getBean时就直接从单例池拿即可</p></li></ol> <p>可以看到，对于Spring中的Bean的生成过程，步骤还是很多的，并且不仅仅只有上面的7步，还有很多很多，比如Aware回调、初始化等等，这里不详细讨论。</p> <p>可以发现，在Spring中，构造一个Bean，包括了new这个步骤（第4步构造方法反射）。</p> <p>得到一个原始对象后，Spring需要给对象中的属性进行依赖注入，那么这个注入过程是怎样的？</p> <p>比如上文说的A类，A类中存在一个B类的b属性，所以，当A类生成了一个原始对象之后，就会去给b属性去赋值，此时就会根据b属性的类型和属性名去BeanFactory中去获取B类所对应的单例bean。如果此时BeanFactory中存在B对应的Bean，那么直接拿来赋值给b属性；如果此时BeanFactory中不存在B对应的Bean，则需要生成一个B对应的Bean，然后赋值给b属性。</p> <p>问题就出现在第二种情况，如果此时B类在BeanFactory中还没有生成对应的Bean，那么就需要去生成，就会经过B的Bean的生命周期。</p> <p>那么在创建B类的Bean的过程中，如果B类中存在一个A类的a属性，那么在创建B的Bean的过程中就需要A类对应的Bean，但是，触发B类Bean的创建的条件是A类Bean在创建过程中的依赖注入，所以这里就出现了循环依赖：</p> <p>ABean创建--&gt;依赖了B属性--&gt;触发BBean创建---&gt;B依赖了A属性---&gt;需要ABean（但ABean还在创建过程中）</p> <p>从而导致ABean创建不出来，BBean也创建不出来。</p> <p>这是循环依赖的场景，但是上文说了，在Spring中，通过某些机制帮开发者解决了部分循环依赖的问题，这个机制就是<strong>三级缓存</strong>。</p> <p><strong>三级缓存</strong></p> <p>三级缓存是通用的叫法。</p> <p>一级缓存为：singletonObjects</p> <p>二级缓存为：earlySingletonObjects</p> <p>三级缓存为：singletonFactories</p> <p><strong>先稍微解释一下这三个缓存的作用，后面详细分析：</strong></p> <p>singletonObjects中缓存的是已经经历了完整生命周期的bean对象。</p> <p>earlySingletonObjects比singletonObjects多了一个early，表示缓存的是早期的bean对象。早期是什么意思？表示Bean的生命周期还没走完就把这个Bean放入earlySingletonObjects。</p> <p>singletonFactories中缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31926946e894c078a6857aa7729edeb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="jj"></p> <p>A的Bean在创建过程中，在进行依赖注入之前，先把A的原始Bean放入缓存（提早暴露，只要放到缓存了，其他Bean需要时就可以从缓存中拿了），放入缓存后，再进行依赖注入，此时A的Bean依赖了B的Bean，如果B的Bean不存在，则需要创建B的Bean，而创建B的Bean的过程和A一样，也是先创建一个B的原始对象，然后把B的原始对象提早暴露出来放入缓存中，然后在对B的原始对象进行依赖注入A，此时能从缓存中拿到A的原始对象（<strong>虽然是A的原始对象，还不是最终的Bean</strong>），B的原始对象依赖注入完了之后，B的生命周期结束，那么A的生命周期也能结束。</p> <p>因为整个过程中，都只有一个A原始对象，所以对于B而言，就算在属性注入时，注入的是A原始对象，也没有关系，因为A原始对象在后续的生命周期中在堆中没有发生变化。</p> <p>上面是在A和B都没有AOP面向切面方法的切面类的情况下，由于AOP的切面类也需要生成Bean，所以只有一集缓存是不够的。</p> <p>从上面这个分析过程中可以得出，只需要一个缓存就能解决循环依赖了，那么为什么Spring中还需要singletonFactories呢？</p> <p>这是难点，基于上面的场景想一个问题：<strong>如果A的原始对象注入给B的属性之后，A的原始对象进行了AOP产生了一个代理对象，此时就会出现，对于A而言，它的Bean对象其实应该是AOP之后的代理对象，而B的a属性对应的并不是AOP之后的代理对象，这就产生了冲突。B依赖的A和最终的A不是同一个对象。</strong></p> <p>AOP就是通过一个BeanPostProcessor来实现的，这个BeanPostProcessor就是AnnotationAwareAspectJAutoProxyCreator，它的父类是AbstractAutoProxyCreator，而在Spring中AOP利用的要么是JDK动态代理，要么CGLib的动态代理，所以如果给一个类中的某个方法设置了切面，那么这个类最终就需要生成一个代理对象。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b4b3f947444579b57c1a7e79049293~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="s"></p> <p>左边文字：</p> <p>这个ObjectFactory就是上文说的labmda表达式，中间有getEarlyBeanReference方法，注意存入singletonFactories时并不会执行lambda表达式，也就是不会执行getEarlyBeanReference方法</p> <p>右边文字：</p> <p>从singletonFactories根据beanName得到一个ObjectFactory，然后执行ObjectFactory，也就是执行getEarlyBeanReference方法，此时会得到一个A原始对象经过AOP之后的代理对象，然后把该代理对象放入earlySingletonObjects中，注意此时并没有把代理对象放入singletonObjects中，那什么时候放入到singletonObjects中呢？</p> <p>这个时候得来理解一下earlySingletonObjects的作用，此时，我们只得到了A原始对象的代理对象，这个对象还不完整，因为A原始对象还没有进行属性填充，所以此时不能直接把A的代理对象放入singletonObjects中，所以只能把代理对象放入earlySingletonObjects，假设现在有其他对象依赖了A，那么则可以从earlySingletonObjects中得到A原始对象的代理对象了，并且是A的同一个代理对象。</p> <p>当B创建完了之后，A继续进行生命周期，而A在完成属性注入后，会按照它本身的逻辑去进行AOP，而此时我们知道A原始对象已经经历过了AOP，所以对于A本身而言，不会再去进行AOP了，那么怎么判断一个对象是否经历过了AOP呢？会利用上文提到的earlyProxyReferences，在AbstractAutoProxyCreator的postProcessAfterInitialization方法中，会去判断当前beanName是否在earlyProxyReferences，如果在则表示已经提前进行过AOP了，无需再次进行AOP。</p> <p>对于A而言，进行了AOP的判断后，以及BeanPostProcessor的执行之后，就需要把A对应的对象放入singletonObjects中了，但是我们知道，应该是要A的代理对象放入singletonObjects中，所以此时需要从earlySingletonObjects中得到代理对象，然后入singletonObjects中。</p> <p>整个循环依赖解决完毕。</p> <p>总结一下三级缓存：</p> <ol><li><p>singletonObjects：缓存某个beanName对应的经过了完整生命周期的bean</p></li> <li><p>earlySingletonObjects：缓存提前拿原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期</p></li> <li><p>singletonFactories：缓存的是一个ObjectFactory，主要用来去生成原始对象进行了AOP之后得到的代理对象，在每个Bean的生成过程中，都会提前暴露一个工厂，这个工厂可能用到，也可能用不到，如果没有出现循环依赖依赖本bean，那么这个工厂无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可，如果出现了循环依赖依赖了本bean，则另外那个bean执行ObjectFactory提交得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)。</p></li> <li><p>其实还要一个缓存，就是earlyProxyReferences，它用来记录某个原始对象是否进行过AOP了。</p></li></ol> <h3 id="_15-一般是怎么创建线程"><a href="#_15-一般是怎么创建线程" class="header-anchor">#</a> 15.一般是怎么创建线程?</h3> <p>1、继承 Thread 类</p> <p>通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。</p> <ul><li>首先定义一个类来继承 Thread 类，重写 run 方法。</li> <li>然后创建这个子类对象，并调用 start 方法启动线程。</li></ul> <p><img src="https://ask.qcloudimg.com/http-save/yehe-2219188/uaa1zy9cb5.png?imageView2/2/w/1200" alt="img"></p> <p><strong>2、实现 Runnable 接口</strong></p> <p>通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。</p> <ul><li>首先定义一个类实现 Runnable 接口，并实现 run 方法。</li> <li>然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中</li> <li>最后调用 start 方法启动线程。</li></ul> <p><img src="https://ask.qcloudimg.com/http-save/yehe-2219188/qucp8pstk7.png?imageView2/2/w/1200" alt="img"></p> <p><strong>3、实现 Callable 接口，并结合 Future 实现</strong></p> <ul><li>首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。</li> <li>然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。</li> <li>把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。</li> <li>通过 FutureTask 的 get 方法获取线程的执行结果。</li></ul> <p><img src="https://ask.qcloudimg.com/http-save/yehe-2219188/zglut4qdvh.png?imageView2/2/w/1200" alt="img"></p> <p><strong>4、通过线程池创建线程</strong></p> <p>此处用 JDK 自带的 Executors 来创建线程池对象。</p> <ul><li>首先，定一个 Runnable 的实现类，重写 run 方法。</li> <li>然后创建一个拥有固定线程数的线程池。</li> <li>最后通过 ExecutorService 对象的 execute 方法传入线程对象。</li></ul> <p><img src="https://ask.qcloudimg.com/http-save/yehe-2219188/grx8pgz81h.png?imageView2/2/w/1200" alt="img"></p> <h3 id="_16-线程池类型"><a href="#_16-线程池类型" class="header-anchor">#</a> 16.线程池类型</h3> <p><strong>1、newCachedThreadPool</strong></p> <p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p> <p>这种类型的线程池特点是：</p> <p>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</p> <p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p> <p>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统OOM。</p> <p><strong>2、newFixedThreadPool</strong></p> <p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p> <p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p> <p><strong>3、newSingleThreadExecutor</strong></p> <p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p> <p><strong>4、newScheduleThreadPool</strong></p> <p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p> <p><strong>5、newSingleThreadScheduledExecutor</strong></p> <p>创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行并且可定时或者延迟执行线程活动。</p> <h3 id="_17-对象的生命周期"><a href="#_17-对象的生命周期" class="header-anchor">#</a> 17.对象的生命周期</h3> <p>在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：<strong>创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）</strong>。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ifan/Notes/JVM/JUC/并发编程.html" class="prev">
        并发编程
      </a></span> <span class="next"><a href="/ifan/Notes/Summary/设计模式.html">
        设计模式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ifan/assets/js/app.1d8f04c4.js" defer></script><script src="/ifan/assets/js/2.733019b2.js" defer></script><script src="/ifan/assets/js/58.099f7ab4.js" defer></script>
  </body>
</html>
