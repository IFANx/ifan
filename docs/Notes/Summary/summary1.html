<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试题 | Notes</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="办法总比问题多">
    
    <link rel="preload" href="/ifan/assets/css/0.styles.9066d5db.css" as="style"><link rel="preload" href="/ifan/assets/js/app.5e29002d.js" as="script"><link rel="preload" href="/ifan/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/ifan/assets/js/58.2f387033.js" as="script"><link rel="prefetch" href="/ifan/assets/js/10.8b80ea1e.js"><link rel="prefetch" href="/ifan/assets/js/100.1ddacebb.js"><link rel="prefetch" href="/ifan/assets/js/101.82fc3a71.js"><link rel="prefetch" href="/ifan/assets/js/102.8f1c1a78.js"><link rel="prefetch" href="/ifan/assets/js/103.4908c7f6.js"><link rel="prefetch" href="/ifan/assets/js/11.efdcfdae.js"><link rel="prefetch" href="/ifan/assets/js/12.b25c7308.js"><link rel="prefetch" href="/ifan/assets/js/13.54ea76bd.js"><link rel="prefetch" href="/ifan/assets/js/14.a55dbf23.js"><link rel="prefetch" href="/ifan/assets/js/15.01c694bf.js"><link rel="prefetch" href="/ifan/assets/js/16.d9772b2c.js"><link rel="prefetch" href="/ifan/assets/js/17.e8ae0051.js"><link rel="prefetch" href="/ifan/assets/js/18.f45ea548.js"><link rel="prefetch" href="/ifan/assets/js/19.2ddcd05d.js"><link rel="prefetch" href="/ifan/assets/js/20.af485201.js"><link rel="prefetch" href="/ifan/assets/js/21.e585d9c7.js"><link rel="prefetch" href="/ifan/assets/js/22.2b276ecc.js"><link rel="prefetch" href="/ifan/assets/js/23.f343dea3.js"><link rel="prefetch" href="/ifan/assets/js/24.7bd49739.js"><link rel="prefetch" href="/ifan/assets/js/25.3a911f9f.js"><link rel="prefetch" href="/ifan/assets/js/26.fa9a686d.js"><link rel="prefetch" href="/ifan/assets/js/27.274f0bfc.js"><link rel="prefetch" href="/ifan/assets/js/28.989a3a4f.js"><link rel="prefetch" href="/ifan/assets/js/29.abbf3945.js"><link rel="prefetch" href="/ifan/assets/js/3.b5397dbc.js"><link rel="prefetch" href="/ifan/assets/js/30.6738d5ae.js"><link rel="prefetch" href="/ifan/assets/js/31.21730518.js"><link rel="prefetch" href="/ifan/assets/js/32.63a4b525.js"><link rel="prefetch" href="/ifan/assets/js/33.60a93df6.js"><link rel="prefetch" href="/ifan/assets/js/34.2a08eef0.js"><link rel="prefetch" href="/ifan/assets/js/35.49883a6b.js"><link rel="prefetch" href="/ifan/assets/js/36.49d3a152.js"><link rel="prefetch" href="/ifan/assets/js/37.0b8ae546.js"><link rel="prefetch" href="/ifan/assets/js/38.80e5a545.js"><link rel="prefetch" href="/ifan/assets/js/39.cd1d4ee5.js"><link rel="prefetch" href="/ifan/assets/js/4.d12742be.js"><link rel="prefetch" href="/ifan/assets/js/40.c5a201e2.js"><link rel="prefetch" href="/ifan/assets/js/41.6fc8c625.js"><link rel="prefetch" href="/ifan/assets/js/42.9b3ce7f9.js"><link rel="prefetch" href="/ifan/assets/js/43.0d002814.js"><link rel="prefetch" href="/ifan/assets/js/44.0a1a4c6f.js"><link rel="prefetch" href="/ifan/assets/js/45.3933ef6d.js"><link rel="prefetch" href="/ifan/assets/js/46.1d702023.js"><link rel="prefetch" href="/ifan/assets/js/47.61263332.js"><link rel="prefetch" href="/ifan/assets/js/48.72af0861.js"><link rel="prefetch" href="/ifan/assets/js/49.cecf707f.js"><link rel="prefetch" href="/ifan/assets/js/5.216cae74.js"><link rel="prefetch" href="/ifan/assets/js/50.5c732b05.js"><link rel="prefetch" href="/ifan/assets/js/51.922c4a4a.js"><link rel="prefetch" href="/ifan/assets/js/52.523e7102.js"><link rel="prefetch" href="/ifan/assets/js/53.f0c1485e.js"><link rel="prefetch" href="/ifan/assets/js/54.925cc9f8.js"><link rel="prefetch" href="/ifan/assets/js/55.4055e6c2.js"><link rel="prefetch" href="/ifan/assets/js/56.b303ce96.js"><link rel="prefetch" href="/ifan/assets/js/57.abc2d066.js"><link rel="prefetch" href="/ifan/assets/js/59.3e5929a1.js"><link rel="prefetch" href="/ifan/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/ifan/assets/js/60.0072cfa1.js"><link rel="prefetch" href="/ifan/assets/js/61.36fe6db7.js"><link rel="prefetch" href="/ifan/assets/js/62.7e153e1d.js"><link rel="prefetch" href="/ifan/assets/js/63.cf107bce.js"><link rel="prefetch" href="/ifan/assets/js/64.c79ab33b.js"><link rel="prefetch" href="/ifan/assets/js/65.a77be777.js"><link rel="prefetch" href="/ifan/assets/js/66.2177acf6.js"><link rel="prefetch" href="/ifan/assets/js/67.7991ba80.js"><link rel="prefetch" href="/ifan/assets/js/68.661cba4c.js"><link rel="prefetch" href="/ifan/assets/js/69.7f61b0e3.js"><link rel="prefetch" href="/ifan/assets/js/7.40dfeb27.js"><link rel="prefetch" href="/ifan/assets/js/70.2e686987.js"><link rel="prefetch" href="/ifan/assets/js/71.83f60807.js"><link rel="prefetch" href="/ifan/assets/js/72.0de4b6d0.js"><link rel="prefetch" href="/ifan/assets/js/73.f5e95877.js"><link rel="prefetch" href="/ifan/assets/js/74.33166f67.js"><link rel="prefetch" href="/ifan/assets/js/75.9514b8d2.js"><link rel="prefetch" href="/ifan/assets/js/76.ca76724a.js"><link rel="prefetch" href="/ifan/assets/js/77.1e8f5846.js"><link rel="prefetch" href="/ifan/assets/js/78.d654fa1d.js"><link rel="prefetch" href="/ifan/assets/js/79.38e3f116.js"><link rel="prefetch" href="/ifan/assets/js/8.53bb2c64.js"><link rel="prefetch" href="/ifan/assets/js/80.bc63ee47.js"><link rel="prefetch" href="/ifan/assets/js/81.c9e1e301.js"><link rel="prefetch" href="/ifan/assets/js/82.f5ea0a9c.js"><link rel="prefetch" href="/ifan/assets/js/83.7bac340f.js"><link rel="prefetch" href="/ifan/assets/js/84.9ec379e2.js"><link rel="prefetch" href="/ifan/assets/js/85.88c24482.js"><link rel="prefetch" href="/ifan/assets/js/86.60b59a04.js"><link rel="prefetch" href="/ifan/assets/js/87.cb1c5e17.js"><link rel="prefetch" href="/ifan/assets/js/88.a15e7aee.js"><link rel="prefetch" href="/ifan/assets/js/89.afb0a74b.js"><link rel="prefetch" href="/ifan/assets/js/9.05495c9e.js"><link rel="prefetch" href="/ifan/assets/js/90.48dfb82e.js"><link rel="prefetch" href="/ifan/assets/js/91.679f330a.js"><link rel="prefetch" href="/ifan/assets/js/92.e5ea1aff.js"><link rel="prefetch" href="/ifan/assets/js/93.bd3e3f95.js"><link rel="prefetch" href="/ifan/assets/js/94.6850d1a0.js"><link rel="prefetch" href="/ifan/assets/js/95.1e2d6d91.js"><link rel="prefetch" href="/ifan/assets/js/96.b7d1254c.js"><link rel="prefetch" href="/ifan/assets/js/97.40a29e27.js"><link rel="prefetch" href="/ifan/assets/js/98.1d9f9bb8.js"><link rel="prefetch" href="/ifan/assets/js/99.69e350da.js">
    <link rel="stylesheet" href="/ifan/assets/css/0.styles.9066d5db.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ifan/" class="home-link router-link-active"><!----> <span class="site-name">Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ifan/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="what?" class="dropdown-title"><span class="title">what?</span> <span class="arrow down"></span></button> <button type="button" aria-label="what?" class="mobile-dropdown-title"><span class="title">what?</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/ifan/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="what?" class="dropdown-title"><span class="title">what?</span> <span class="arrow down"></span></button> <button type="button" aria-label="what?" class="mobile-dropdown-title"><span class="title">what?</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Maven</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>软件测试相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringBoot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MySQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Netty</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Summary</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ifan/Notes/Summary/summary2.html" class="sidebar-link">summary2</a></li><li><a href="/ifan/Notes/Summary/summary1.html" aria-current="page" class="active sidebar-link">summary1</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#面试题" class="sidebar-link">面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_1-高并发秒杀超卖问题" class="sidebar-link">1.高并发秒杀超卖问题</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_2-测试-淘宝购物车" class="sidebar-link">2.测试-淘宝购物车</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_3-典型电商促销场景下的云端压力测试实战" class="sidebar-link">3.典型电商促销场景下的云端压力测试实战</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_4-liunx下怎么查进程-怎么查端口" class="sidebar-link">4.liunx下怎么查进程，怎么查端口</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_5-线程池核心参数" class="sidebar-link">5.线程池核心参数</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_6-spring-涉及到的设计模式汇总" class="sidebar-link">6.Spring-涉及到的设计模式汇总</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_7-jdbc建立连接流程" class="sidebar-link">7. JDBC建立连接流程</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_8-布隆过滤器" class="sidebar-link">8.布隆过滤器</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_9-threadlocal" class="sidebar-link">9.ThreadLocal</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_10-session是什么-它与cookie有什么区别" class="sidebar-link">10.Session是什么？它与Cookie有什么区别？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_11-tomcat如何以及为什么要打破双亲委派模型-顺带介绍一下双亲委派模型" class="sidebar-link">11.tomcat如何以及为什么要打破双亲委派模型（顺带介绍一下双亲委派模型）</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_12-四种引用的应用场景" class="sidebar-link">12.四种引用的应用场景</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_13-redis哨兵如何实现通信-结点宕机如何处理" class="sidebar-link">13.Redis哨兵如何实现通信，结点宕机如何处理</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_14-spring如何解决ioc时的循环依赖问题" class="sidebar-link">14.Spring如何解决IOC时的循环依赖问题</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_15-一般是怎么创建线程" class="sidebar-link">15.一般是怎么创建线程?</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_16-线程池类型" class="sidebar-link">16.线程池类型</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_17-对象的生命周期" class="sidebar-link">17.对象的生命周期</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_18-线程池中后备队列满了的任务拒绝策略" class="sidebar-link">18.线程池中后备队列满了的任务拒绝策略</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_19-redis如何实现分布式锁" class="sidebar-link">19.redis如何实现分布式锁</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_20-autowired和-resource区别" class="sidebar-link">20.@Autowired和@Resource区别</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_21-spring-注解" class="sidebar-link">21.Spring 注解</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_22-spring注解分类" class="sidebar-link">22.Spring注解分类</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_23-repository和-controller、-service、-component" class="sidebar-link">23.@Repository和@Controller、@Service、@Component</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_24-spring中-component和-bean的区别" class="sidebar-link">24.Spring中@Component和@Bean的区别</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_25-spring-factories-springboot如何自动注入-装配-maven引入的第三方库jar" class="sidebar-link">25.Spring.factories(SpringBoot如何自动注入(装配)Maven引入的第三方库jar)</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_26-springboot的自动装配原理" class="sidebar-link">26.SpringBoot的自动装配原理</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_27-单点登录" class="sidebar-link">27.单点登录</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_28-零拷贝" class="sidebar-link">28.零拷贝</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_29-tcp建立连接为什么是三次握手-而不是两次或四次" class="sidebar-link">29.TCP建立连接为什么是三次握手，而不是两次或四次？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_30-tcp四次挥手为什么有时会是三次挥手" class="sidebar-link">30.TCP四次挥手为什么有时会是三次挥手？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_31-如何对app做安全测试" class="sidebar-link">31.如何对app做安全测试</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_32-这四种隔离级别具体是如何实现的呢" class="sidebar-link">32.这四种隔离级别具体是如何实现的呢？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_33-可重复读隔离级别如何用mvcc解决幻读问题" class="sidebar-link">33.可重复读隔离级别如何用mvcc解决幻读问题</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_34-元数据锁" class="sidebar-link">34.元数据锁</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_35-意向锁" class="sidebar-link">35.意向锁</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_36-行级锁" class="sidebar-link">36.行级锁</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_37-mysql-log" class="sidebar-link">37.MySQL Log</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_38-redo-log-循环写-和binlog-全量日志-的-区别" class="sidebar-link">38.redo log（循环写）和binlog（全量日志）的 区别</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_34-为什么redis选择使用跳表而不是红黑树来实现有序集合" class="sidebar-link">34.为什么Redis选择使用跳表而不是红黑树来实现有序集合？</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_35-红黑树-二叉搜索树之一" class="sidebar-link">35.红黑树（二叉搜索树之一）</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_36-内存屏障" class="sidebar-link">36.内存屏障</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_37-三色标记法gc" class="sidebar-link">37.三色标记法GC</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_38-cms与g1收集器" class="sidebar-link">38.CMS与G1收集器</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_39-springboot的类加载过程" class="sidebar-link">39.SpringBoot的类加载过程</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_40-类加载过程" class="sidebar-link">40.类加载过程</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#" class="sidebar-link"></a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_41-java类加载初始化顺序-重在顺序" class="sidebar-link">41.java类加载初始化顺序（重在顺序）</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_42-jvm运行时内存结构-五个分区" class="sidebar-link">42.JVM运行时内存结构（五个分区）</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_43-逃逸分析" class="sidebar-link">43.逃逸分析</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_44-tcp延迟确认机制" class="sidebar-link">44.TCP延迟确认机制</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_45-transactional注解" class="sidebar-link">45.@Transactional注解</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_46-事务传播机制" class="sidebar-link">46.事务传播机制</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_47-倒排索引" class="sidebar-link">47.倒排索引</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_48-redis的内存淘汰策略" class="sidebar-link">48.Redis的内存淘汰策略</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_49-jdk动态代理" class="sidebar-link">49.JDK动态代理</a></li><li class="sidebar-sub-header"><a href="/ifan/Notes/Summary/summary1.html#_50-fast-fail机制" class="sidebar-link">50.Fast-fail机制</a></li></ul></li></ul></li><li><a href="/ifan/Notes/Summary/高频点.html" class="sidebar-link">高频点</a></li><li><a href="/ifan/Notes/Summary/设计模式.html" class="sidebar-link">设计模式</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java IO</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础和原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Notes</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="面试题"><a href="#面试题" class="header-anchor">#</a> 面试题</h2> <h3 id="_1-高并发秒杀超卖问题"><a href="#_1-高并发秒杀超卖问题" class="header-anchor">#</a> <strong>1.高并发秒杀超卖问题</strong></h3> <p>1.数据库层面的互斥锁，2.应用层面的分布式锁，3.redis的单线程特性+内存运行（预减库存）</p> <h3 id="_2-测试-淘宝购物车"><a href="#_2-测试-淘宝购物车" class="header-anchor">#</a> <strong>2.测试-淘宝购物车</strong></h3> <p>界面测试-功能测试-性能测试-兼容性测试-网络环境测试-异常测试（内存，网络，商品操作是清理后台应用有何影响）-本地-国际化测试（习俗，文化，语言）</p> <h3 id="_3-典型电商促销场景下的云端压力测试实战"><a href="#_3-典型电商促销场景下的云端压力测试实战" class="header-anchor">#</a> <strong>3.典型电商促销场景下的云端压力测试实战</strong></h3> <p>瞬间集中并发，传统压测工具Loadrunner和Jmeter，基础数据，热点数据，缓存数据，一次性数据</p> <p><strong>压测场景建模</strong></p> <p>完成业务场景建模后，基于其进行压测场景建模，这里要考虑到采用的测试策略，当然，测试策略的制定需要结合系统架构（需要梳理清各服务间的依赖和调用关系）和业务特点来说。</p> <p>比如抽奖抢券秒杀场景，就需要采用并发测试以及超卖验证等测试策略。</p> <p>考虑到业务配比的情况，我们还需要进行单接口的基准测试以及单机混合场景容量测试。</p> <p>核心业务流程，其特性要求系统具备高可用和稳定性，那么测试策略就需要采用高可用测试和稳定性测试。</p> <p><strong>1、压测</strong></p> <p>压测工作主要有如下几种情景，按照预先制定的测试策略执行即可（不排除临时特殊情况，这里需灵活调整）。</p> <p><strong>①、单机单接口测试</strong>：该策略主要是为了验证单接口的性能基准，避免整个调用链路过程中某个服务/接口成为瓶颈；</p> <p><strong>②、单机多接口测试</strong>：相较于微服务架构的服务解耦，有时候某些服务间互相调用依赖的强关系可能会造成资源竞争等情况，需要通过这种方式来排查验证；</p> <p><strong>③、单机混合场景测试</strong>：这种测试方式的主要作用是得到一个单机混合场景下的最优性能表现，为服务扩容和线上容量规划提供参考数据；</p> <p><strong>④、多节点测试</strong>：现在大多数的互联网企业都采用的集群/分布式/微服务架构，在多节点部署时候，考虑到SLB的边际递减效应，需要进行多节点测试；</p> <p>通过该种方式，来验证负载均衡递减比率，为生产扩容提供精确的参考依据；</p> <p><strong>⑤、高可用测试</strong>：高可用主要验证2点：<strong>服务异常/宕机是否可以恢复</strong>以及<strong>恢复到正常水*所耗费的时间</strong>（越短越好）。</p> <p><strong>⑥、稳定性测试</strong>：前面提到了核心业务流程必须保证稳定性，稳定性测试一般根据系统特点和业务类型，分为两类：5d<em>12h、7d</em>24h。</p> <p>一般来说，稳定性测试的执行时间，12h即可（当然，24h或者更长也可以，根据具体情况灵活调整）。</p> <p><img src="https://img2018.cnblogs.com/blog/983980/201906/983980-20190624003458858-843470018.png" alt="983980-20190624003458858-843470018"></p> <p>临时扩容或者服务降级限流甚至熔断等机制，保证系统在峰值流量下保持服务可用。</p> <h3 id="_4-liunx下怎么查进程-怎么查端口"><a href="#_4-liunx下怎么查进程-怎么查端口" class="header-anchor">#</a> <strong>4.liunx下怎么查进程，怎么查端口</strong></h3> <p>1、利用lsof命令查看，当命令参数设置为“-i”时用以显示符合条件的进程情况，语法为“lsof -i:端口号”；</p> <p>2、利用netstat命令查看，该命令会列出端口所有状态的连接，语法为“netstat-tunlp|grep 端口号”。</p> <h3 id="_5-线程池核心参数"><a href="#_5-线程池核心参数" class="header-anchor">#</a> <strong>5.线程池核心参数</strong></h3> <ol><li>corePoolSize：核心线程数。</li> <li>maximumPoolSize：最大线程数。<strong>线程池允许创建的最大线程数量，当线程池的任务队列满了之后，可以创建的最大线程数。</strong></li> <li>keepAliveTime：空闲线程存活时间。</li> <li>TimeUnit：时间单位。</li> <li>BlockingQueue：线程池任务队列。</li> <li>ThreadFactory：创建线程的工厂。</li> <li>RejectedExecutionHandler：拒绝策略。</li></ol> <p><strong>拒绝策略：当线程池的任务超出线程池队列可以存储的最大值之后，执行的策略。</strong>
默认的拒绝策略有以下 4 种：</p> <ul><li>AbortPolicy：拒绝并抛出异常。</li> <li>CallerRunsPolicy：使用当前调用的线程来执行此任务。</li> <li>DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。</li> <li>DiscardPolicy：忽略并抛弃当前任务。</li></ul> <p>线程池的默认策略是 AbortPolicy 拒绝并抛出异常。</p> <h3 id="_6-spring-涉及到的设计模式汇总"><a href="#_6-spring-涉及到的设计模式汇总" class="header-anchor">#</a> <strong>6.Spring-涉及到的设计模式汇总</strong></h3> <p><strong>1. 简单工厂</strong></p> <p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p> <p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p> <p><strong>2. 工厂方法（Factory Method）</strong></p> <p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p> <p><strong>3. 单例（Singleton）</strong></p> <p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p> <p>Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为Spring管理的是是任意的Java对象。</p> <p><strong>4. 适配器（Adapter）</strong></p> <p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p> <p>Spring中在对于AOP的处理中有Adapter模式的例子</p> <p><strong>5.包装器（Decorator）</strong></p> <p>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</p> <p><strong>6. 代理（Proxy）</strong></p> <p>为其他对象提供一种代理以控制对这个对象的访问。</p> <p>从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。</p> <p><strong>7.观察者（Observer）</strong></p> <p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p> <p><strong>8. 策略（Strategy）</strong></p> <p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p> <p><strong>9.模板方法（Template Method）</strong></p> <p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p> <p>Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。Spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。</p> <h3 id="_7-jdbc建立连接流程"><a href="#_7-jdbc建立连接流程" class="header-anchor">#</a> <strong>7. JDBC建立连接流程</strong></h3> <p>SPI（服务提供接口），定义标准，厂商实现接口，提供Jar包，ClassLoader记载对应的jar包，执行对应的方法。</p> <h3 id="_8-布隆过滤器"><a href="#_8-布隆过滤器" class="header-anchor">#</a> <strong>8.布隆过滤器</strong></h3> <p>布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。<strong>它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难</strong>。(布隆过滤器使用了K个hash函数计算，所有可能在多个位置hash索引为1，这样可能会出现一个从未索引的值，在布隆过滤器中可以被查询到的情况，误判（可预测比例）)<strong>当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中</strong>。</p> <p>利用布隆过滤器我们可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当根据 ID 进行数据查询的时候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是缓存穿透不能完全解决，我们只能将其控制在一个可以容忍的范围内。</p> <h3 id="_9-threadlocal"><a href="#_9-threadlocal" class="header-anchor">#</a> <strong>9.ThreadLocal</strong></h3> <p>https://pdai.tech/md/java/thread/java-thread-x-threadlocal.html</p> <p>ThrealLocal在线程池中，由于部分线程可能永远不会被销毁，在这种线程中的ThrealLocal变量可能会一直被保留，造成内存泄漏。（相当于实际这个线程已经在执行其他任务，这个ThreadLocal对象并没有实际作用，但由于在这个线程的ThreadLocalMap中仍然存在《线程ID，ThreadLocal对象的引用》，强引用，于是ThreadLocal对象无法被释放，造成内存泄漏）</p> <h3 id="_10-session是什么-它与cookie有什么区别"><a href="#_10-session是什么-它与cookie有什么区别" class="header-anchor">#</a> <strong>10.<a href="https://segmentfault.com/a/1190000041429984" target="_blank" rel="noopener noreferrer">Session是什么？它与Cookie有什么区别？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></h3> <p>https://www.51cto.com/article/679219.html</p> <h3 id="_11-tomcat如何以及为什么要打破双亲委派模型-顺带介绍一下双亲委派模型"><a href="#_11-tomcat如何以及为什么要打破双亲委派模型-顺带介绍一下双亲委派模型" class="header-anchor">#</a> <strong>11.tomcat如何以及为什么要打破双亲委派模型（顺带介绍一下双亲委派模型）</strong></h3> <p>双亲委派模型（Parent Delegation Model）是Java类加载器的一种工作机制，它是Java安全模型的核心之一。在Java中，类加载器（ClassLoader）负责将类的字节码加载到内存中，并生成对应的Class对象供程序使用。双亲委派模型规定了类加载器的工作流程和层次结构，保证了类的加载的安全性和一致性。</p> <p>如果一个类加载器收到了加载某个类的请求，则该类加载器并不会去加载该类，而是把这个请求委派给父类加载器，每一个层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶端的启动类加载器；只有当父类加载器在其搜索范围内无法找到所需的类，并将该结果反馈给子类加载器，子类加载器会尝试去自己加载。</p> <p>双亲委派模型的基本原则是：当一个类加载器需要加载一个类时，它首先会将这个任务委托给父类加载器。如果父类加载器无法加载这个类，子类加载器才会尝试加载。这种委派机制一直向上追溯，直到顶层的启动类加载器（BootStrap ClassLoader）。</p> <p>双亲委派模型的优势在于保证了类的加载的唯一性和一致性。当一个类被加载后，它会被缓存在加载器的缓存中，下次再次加载这个类时，直接从缓存中取出，不再重新加载。这样可以避免重复加载同一个类，节省了内存空间，提高了系统的性能。</p> <p>双亲委派模型还增强了Java的安全性。通过委派机制，保证了核心类库的安全性，防止用户自定义的类替换核心类库中的类，避免了恶意代码的注入，提高了系统的稳定性和安全性。例如，当我们编写一个Java应用程序时，如果需要使用String类，那么首先会尝试从父类加载器中加载。只有当父类加载器无法加载时，才会尝试从当前类加载器中加载。这样就保证了我们使用的是JDK中的标准String类，而不是自己定义的String类。</p> <p>双亲委派模型还可以实现类的隔离和防止类的冲突。例如，如果两个不同的类加载器加载了同一个类，由于类加载器是独立的，它们会生成两个不同的Class对象，因此这两个类是不相等的，可以实现类的隔离和防止类的冲突。</p> <p>总结来说，双亲委派模型是Java类加载器的一种工作机制，通过委派机制和层次结构，保证了类的加载的安全性和一致性，增强了Java的安全性，实现了类的隔离和防止类的冲突。它是Java安全模型的重要组成部分，也是Java语言的一个重要特性。</p> <p>打破双亲委派模型（JDBC和Tomcat）</p> <p><strong>因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。</strong></p> <p>JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于 $JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，**根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。**也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。</p> <p><strong>Tomcat为什么要破坏双亲委派模型<a href="https://www.cnblogs.com/yueshutong/p/11430885.html#134638671" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></p> <p><strong>每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。</strong></p> <p>事实上，tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的：</p> <ul><li>对于各个 <code>webapp</code>中的 <code>class</code>和 <code>lib</code>，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。</li> <li>与 <code>jvm</code>一样的安全性问题。使用单独的 <code>classloader</code>去装载 <code>tomcat</code>自身的类库，以免其他恶意或无意的破坏；</li> <li>热部署。相信大家一定为 <code>tomcat</code>修改文件不用重启就自动重新装载类库而惊叹吧。</li></ul> <h3 id="_12-四种引用的应用场景"><a href="#_12-四种引用的应用场景" class="header-anchor">#</a> <strong>12.四种引用的应用场景</strong></h3> <p>Java中共有四种引用类型，包括强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference），它们各自有着不同的应用场景。</p> <ol><li>强引用（Strong Reference）： 强引用是指在程序中普遍存在的引用方式，如果一个对象具有强引用，那么垃圾收集器就不会回收它。当一个对象被多个强引用所引用时，垃圾收集器也不会回收它，直到所有强引用都被释放掉。</li></ol> <p>应用场景： 强引用通常用于对象的普通应用场景，例如在方法中创建对象并将其赋值给局部变量，或者在类中将对象作为成员变量存储。这些对象在程序运行期间一般都需要保持存在，因此使用强引用可以确保它们不会被垃圾收集器回收。</p> <ol><li>软引用（Soft Reference）： 软引用是一种比较弱的引用类型，如果一个对象只有软引用，则在系统内存不足时，垃圾收集器会将其回收。软引用通常用于缓存，如果内存充足，则可以从缓存中获取对象，否则需要重新创建。</li></ol> <p>应用场景： 软引用通常用于缓存和高速缓存的实现。在缓存中，一些经常使用的对象可以被存储在内存中，以便快速访问。如果系统内存不足，垃圾收集器会回收这些对象，从而释放内存。</p> <ol><li>弱引用（Weak Reference）： 弱引用是比软引用更弱的引用类型，如果一个对象只有弱引用，则在下一次垃圾收集时，无论内存是否充足，都会被回收。弱引用通常用于实现缓存或对象注册表，这些对象的生命周期通常比较短。</li></ol> <p>应用场景： 弱引用通常用于缓存或对象注册表中，这些对象的生命周期通常很短，但在某些情况下需要进行访问。通过使用弱引用，可以确保这些对象在不需要时可以被回收，从而避免内存泄漏。</p> <ol><li>虚引用（Phantom Reference）： 虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。虚引用是最弱的引用类型，它无法通过引用访问到对象，也无法通过引用获取到对象的状态。虚引用主要用于跟踪对象被垃圾回收的状态，可以通过虚引用观察到一个对象是否已经被垃圾收集器回收。</li></ol> <p>五，引用队列（ReferenceQueue）</p> <p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p> <p>与软引用、弱引用不同，虚引用必须和引用队列一起使用。</p> <p><strong>四种引用比较</strong></p> <table><thead><tr><th>引用类型</th> <th>被垃圾回收时间</th> <th>用途</th> <th>生存时间</th></tr></thead> <tbody><tr><td>强引用</td> <td>从来不会</td> <td>对象的一般状态</td> <td>JVM停止运行时终止</td></tr> <tr><td>软引用</td> <td>当内存不足时</td> <td>对象缓存</td> <td>内存不足时终止</td></tr> <tr><td>弱引用</td> <td>正常垃圾回收时</td> <td>对象缓存</td> <td>垃圾回收后终止</td></tr> <tr><td>虚引用</td> <td>正常垃圾回收时</td> <td>跟踪对象的垃圾回收</td> <td>垃圾回收后终止</td></tr></tbody></table> <h3 id="_13-redis哨兵如何实现通信-结点宕机如何处理"><a href="#_13-redis哨兵如何实现通信-结点宕机如何处理" class="header-anchor">#</a> <strong>13.Redis哨兵如何实现通信，结点宕机如何处理</strong></h3> <p>心跳机制-通信（master或者slave宕机）</p> <h3 id="_14-spring如何解决ioc时的循环依赖问题"><a href="#_14-spring如何解决ioc时的循环依赖问题" class="header-anchor">#</a> <strong>14.Spring如何解决IOC时的循环依赖问题</strong></h3> <p>如果不考虑Spring，循环依赖并不是问题，因为对象之间相互依赖是很正常的事情。比如</p> <div class="language-ini extra-class"><pre class="language-ini"><code><span class="token key attr-name">A a</span> <span class="token punctuation">=</span> <span class="token value attr-value">new A();</span>
<span class="token key attr-name">B b</span> <span class="token punctuation">=</span> <span class="token value attr-value">new B();</span>

<span class="token key attr-name">a.b</span> <span class="token punctuation">=</span> <span class="token value attr-value">b;</span>
<span class="token key attr-name">b.a</span> <span class="token punctuation">=</span> <span class="token value attr-value">a;</span>
</code></pre></div><p>这样，A,B就依赖上了。</p> <p><strong>Bean的生命周期</strong></p> <p>这里不会对Bean的生命周期进行详细的描述，只描述一下大概的过程。</p> <p>Bean的生命周期指的就是：在Spring中，Bean是如何生成的？</p> <p>被Spring管理的对象叫做Bean。Bean的生成步骤如下：</p> <ol><li><p>Spring扫描class得到BeanDefinition</p></li> <li><p>根据得到的BeanDefinition去生成bean</p></li> <li><p>首先根据class推断构造方法</p></li> <li><p>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</p></li> <li><p>填充原始对象中的属性（依赖注入）</p></li> <li><p>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象（这个是AOP切面类的对象）</p></li> <li><p>把最终生成的代理对象放入单例池（源码中叫做singletonObjects）中，下次getBean时就直接从单例池拿即可</p></li></ol> <p>可以看到，对于Spring中的Bean的生成过程，步骤还是很多的，并且不仅仅只有上面的7步，还有很多很多，比如Aware回调、初始化等等，这里不详细讨论。</p> <p>可以发现，在Spring中，构造一个Bean，包括了new这个步骤（第4步构造方法反射）。</p> <p>得到一个原始对象后，Spring需要给对象中的属性进行依赖注入，那么这个注入过程是怎样的？</p> <p>比如上文说的A类，A类中存在一个B类的b属性，所以，当A类生成了一个原始对象之后，就会去给b属性去赋值，此时就会根据b属性的类型和属性名去BeanFactory中去获取B类所对应的单例bean。如果此时BeanFactory中存在B对应的Bean，那么直接拿来赋值给b属性；如果此时BeanFactory中不存在B对应的Bean，则需要生成一个B对应的Bean，然后赋值给b属性。</p> <p>问题就出现在第二种情况，如果此时B类在BeanFactory中还没有生成对应的Bean，那么就需要去生成，就会经过B的Bean的生命周期。</p> <p>那么在创建B类的Bean的过程中，如果B类中存在一个A类的a属性，那么在创建B的Bean的过程中就需要A类对应的Bean，但是，触发B类Bean的创建的条件是A类Bean在创建过程中的依赖注入，所以这里就出现了循环依赖：</p> <p>ABean创建--&gt;依赖了B属性--&gt;触发BBean创建---&gt;B依赖了A属性---&gt;需要ABean（但ABean还在创建过程中）</p> <p>从而导致ABean创建不出来，BBean也创建不出来。</p> <p>这是循环依赖的场景，但是上文说了，在Spring中，通过某些机制帮开发者解决了部分循环依赖的问题，这个机制就是<strong>三级缓存</strong>。</p> <p><strong>三级缓存</strong></p> <p>三级缓存是通用的叫法。</p> <p>一级缓存为：singletonObjects</p> <p>二级缓存为：earlySingletonObjects</p> <p>三级缓存为：singletonFactories</p> <p><strong>先稍微解释一下这三个缓存的作用，后面详细分析：</strong></p> <p>singletonObjects中缓存的是已经经历了完整生命周期的bean对象。</p> <p>earlySingletonObjects比singletonObjects多了一个early，表示缓存的是早期的bean对象。早期是什么意思？表示Bean的生命周期还没走完就把这个Bean放入earlySingletonObjects。</p> <p>singletonFactories中缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31926946e894c078a6857aa7729edeb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="jj"></p> <p>A的Bean在创建过程中，在进行依赖注入之前，先把A的原始Bean放入缓存（提早暴露，只要放到缓存了，其他Bean需要时就可以从缓存中拿了），放入缓存后，再进行依赖注入，此时A的Bean依赖了B的Bean，如果B的Bean不存在，则需要创建B的Bean，而创建B的Bean的过程和A一样，也是先创建一个B的原始对象，然后把B的原始对象提早暴露出来放入缓存中，然后在对B的原始对象进行依赖注入A，此时能从缓存中拿到A的原始对象（<strong>虽然是A的原始对象，还不是最终的Bean</strong>），B的原始对象依赖注入完了之后，B的生命周期结束，那么A的生命周期也能结束。</p> <p>因为整个过程中，都只有一个A原始对象，所以对于B而言，就算在属性注入时，注入的是A原始对象，也没有关系，因为A原始对象在后续的生命周期中在堆中没有发生变化。</p> <p>上面是在A和B都没有AOP面向切面方法的切面类的情况下，由于AOP的切面类也需要生成Bean，所以只有一集缓存是不够的。</p> <p>从上面这个分析过程中可以得出，只需要一个缓存就能解决循环依赖了，那么为什么Spring中还需要singletonFactories呢？</p> <p>这是难点，基于上面的场景想一个问题：<strong>如果A的原始对象注入给B的属性之后，A的原始对象进行了AOP产生了一个代理对象，此时就会出现，对于A而言，它的Bean对象其实应该是AOP之后的代理对象，而B的a属性对应的并不是AOP之后的代理对象，这就产生了冲突。B依赖的A和最终的A不是同一个对象。</strong></p> <p>AOP就是通过一个BeanPostProcessor来实现的，这个BeanPostProcessor就是AnnotationAwareAspectJAutoProxyCreator，它的父类是AbstractAutoProxyCreator，而在Spring中AOP利用的要么是JDK动态代理，要么CGLib的动态代理，所以如果给一个类中的某个方法设置了切面，那么这个类最终就需要生成一个代理对象。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b4b3f947444579b57c1a7e79049293~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="s"></p> <p>左边文字：</p> <p>这个ObjectFactory就是上文说的labmda表达式，中间有getEarlyBeanReference方法，注意存入singletonFactories时并不会执行lambda表达式，也就是不会执行getEarlyBeanReference方法</p> <p>右边文字：</p> <p>从singletonFactories根据beanName得到一个ObjectFactory，然后执行ObjectFactory，也就是执行getEarlyBeanReference方法，此时会得到一个A原始对象经过AOP之后的代理对象，然后把该代理对象放入earlySingletonObjects中，注意此时并没有把代理对象放入singletonObjects中，那什么时候放入到singletonObjects中呢？</p> <p>这个时候得来理解一下earlySingletonObjects的作用，此时，我们只得到了A原始对象的代理对象，这个对象还不完整，因为A原始对象还没有进行属性填充，所以此时不能直接把A的代理对象放入singletonObjects中，所以只能把代理对象放入earlySingletonObjects，假设现在有其他对象依赖了A，那么则可以从earlySingletonObjects中得到A原始对象的代理对象了，并且是A的同一个代理对象。</p> <p>当B创建完了之后，A继续进行生命周期，而A在完成属性注入后，会按照它本身的逻辑去进行AOP，而此时我们知道A原始对象已经经历过了AOP，所以对于A本身而言，不会再去进行AOP了，那么怎么判断一个对象是否经历过了AOP呢？会利用上文提到的earlyProxyReferences，在AbstractAutoProxyCreator的postProcessAfterInitialization方法中，会去判断当前beanName是否在earlyProxyReferences，如果在则表示已经提前进行过AOP了，无需再次进行AOP。</p> <p>对于A而言，进行了AOP的判断后，以及BeanPostProcessor的执行之后，就需要把A对应的对象放入singletonObjects中了，但是我们知道，应该是要A的代理对象放入singletonObjects中，所以此时需要从earlySingletonObjects中得到代理对象，然后入singletonObjects中。</p> <p>整个循环依赖解决完毕。</p> <p>总结一下三级缓存：</p> <ol><li><p>singletonObjects：缓存某个beanName对应的经过了完整生命周期的bean</p></li> <li><p>earlySingletonObjects：缓存提前拿原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期</p></li> <li><p>singletonFactories：缓存的是一个ObjectFactory，主要用来去生成原始对象进行了AOP之后得到的代理对象，在每个Bean的生成过程中，都会提前暴露一个工厂，这个工厂可能用到，也可能用不到，如果没有出现循环依赖依赖本bean，那么这个工厂无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可，如果出现了循环依赖依赖了本bean，则另外那个bean执行ObjectFactory提交得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)。</p></li> <li><p>其实还要一个缓存，就是earlyProxyReferences，它用来记录某个原始对象是否进行过AOP了。</p></li></ol> <h3 id="_15-一般是怎么创建线程"><a href="#_15-一般是怎么创建线程" class="header-anchor">#</a> 15.一般是怎么创建线程?</h3> <p>1、继承 Thread 类</p> <p>通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。</p> <ul><li>首先定义一个类来继承 Thread 类，重写 run 方法。</li> <li>然后创建这个子类对象，并调用 start 方法启动线程。</li></ul> <p><img src="https://ask.qcloudimg.com/http-save/yehe-2219188/uaa1zy9cb5.png?imageView2/2/w/1200" alt="img"></p> <p><strong>2、实现 Runnable 接口</strong></p> <p>通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。</p> <ul><li>首先定义一个类实现 Runnable 接口，并实现 run 方法。</li> <li>然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中</li> <li>最后调用 start 方法启动线程。</li></ul> <p><img src="https://ask.qcloudimg.com/http-save/yehe-2219188/qucp8pstk7.png?imageView2/2/w/1200" alt="img"></p> <p><strong>3、实现 Callable 接口，并结合 FutureTask 实现</strong></p> <ul><li>首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。</li> <li>然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。</li> <li>把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。</li> <li>通过 FutureTask 的 get 方法获取线程的执行结果。</li></ul> <p><img src="https://ask.qcloudimg.com/http-save/yehe-2219188/zglut4qdvh.png?imageView2/2/w/1200" alt="img"></p> <p><strong>4、通过线程池创建线程</strong></p> <p>此处用 JDK 自带的 Executors 来创建线程池对象。</p> <ul><li>首先，定一个 Runnable 的实现类，重写 run 方法。</li> <li>然后创建一个拥有固定线程数的线程池。</li> <li>最后通过 ExecutorService 对象的 execute 方法传入线程对象。</li></ul> <p><img src="https://ask.qcloudimg.com/http-save/yehe-2219188/grx8pgz81h.png?imageView2/2/w/1200" alt="img"></p> <h3 id="_16-线程池类型"><a href="#_16-线程池类型" class="header-anchor">#</a> 16.线程池类型</h3> <p><strong>1、newCachedThreadPool</strong></p> <p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p> <p>这种类型的线程池特点是：</p> <p>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</p> <p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p> <p>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统OOM。</p> <p><strong>2、newFixedThreadPool</strong></p> <p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p> <p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p> <p><strong>3、newSingleThreadExecutor</strong></p> <p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p> <p><strong>4、newScheduleThreadPool</strong></p> <p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p> <p><strong>5、newSingleThreadScheduledExecutor</strong></p> <p>创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行并且可定时或者延迟执行线程活动。</p> <h3 id="_17-对象的生命周期"><a href="#_17-对象的生命周期" class="header-anchor">#</a> 17.对象的生命周期</h3> <p>在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：<strong>创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）</strong>。</p> <h3 id="_18-线程池中后备队列满了的任务拒绝策略"><a href="#_18-线程池中后备队列满了的任务拒绝策略" class="header-anchor">#</a> 18.线程池中后备队列满了的任务拒绝策略</h3> <p>关于线程池的任务拒绝策略，我们要理解并记住，有如下的四种：</p> <p>1、直接丢弃（DiscardPolicy）</p> <p>2、丢弃队列中最老的任务(DiscardOldestPolicy)。</p> <p>3、抛异常</p> <p>4、将任务分给调用线程来执行。</p> <h3 id="_19-redis如何实现分布式锁"><a href="#_19-redis如何实现分布式锁" class="header-anchor">#</a> 19.redis如何实现分布式锁</h3> <p>我们在系统中修改已有数据时，需要先读取，然后进行修改保存，此时很容易遇到并发问题。由于修改和保存不是原子操作，在并发场景下，部分对数据的操作可能会丢失。在单服务器系统我们常用本地锁来避免并发带来的问题，然而，当服务采用集群方式部署时，本地锁无法在多个服务器之间生效，这时候保证数据的一致性就需要分布式锁来实现。</p> <p>Redis 锁主要利用 Redis 的 setnx 命令。</p> <ul><li>加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。</li> <li>解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。</li> <li>锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。</li></ul> <h3 id="_20-autowired和-resource区别"><a href="#_20-autowired和-resource区别" class="header-anchor">#</a> 20.@Autowired和@Resource区别</h3> <p>https://juejin.cn/post/7022507865701089317</p> <p>共同点：@Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。</p> <p>不同点：</p> <p>1、@Resource是JDK原生的注解，@Autowired是Spring2.5 引入的注解</p> <p>2、@Resource有两个属性name和type。Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p> <p>@Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。</p> <p>总结</p> <p>@Autowired功能虽说非常强大，但是也有些不足之处。比如它跟Spring强耦合了，如果换成了其他框架，功能就会失效。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持。</p> <p>除此之外，有些场景使用@Autowired无法满足的要求，改成@Resource却能解决问题。</p> <p>1、@Autowired默认按byType自动装配，而@Resource默认byName自动装配。</p> <p>2、@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。</p> <p>3、@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。</p> <p>4、@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。</p> <p>5、@Autowired是Spring定义的注解，而@Resource是JSR-250定义的注解。</p> <p>6、二者装配顺序不同</p> <p><strong>@Autowired</strong></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8fabb988e2d4fcb87e592cd8846be68~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p><strong>@Resource</strong></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e987c1684435481bbaf3b270dfdbaf59~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <h3 id="_21-spring-注解"><a href="#_21-spring-注解" class="header-anchor">#</a> 21.Spring 注解</h3> <p>@Repository和@Controller、@Service、@<a href="https://so.csdn.net/so/search?q=Component&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">Component<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的作用差不多，都是把对象交给spring管理。@Repository用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理。</p> <p>为什么有时候我们不用@Repository来注解接口,我们照样可以注入到这个接口的实现类呢?
1、spring配置文件中配置了MapperScannerConfigurer这个bean，它会扫描持久层接口创建实现类并交给spring管理。</p> <p>2、接口上使用了@Mapper注解或者springboot中主类上使用了@MapperScan注解，和MapperScannerConfigurer作用一样。</p> <p>注：不使用@Repository注解，idea会报警告，提示找不到这个bean，直接忽略即可。</p> <p>@Repository的作用：
这是因为该注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型。 Spring本身提供了一个丰富的并且是与具体的数据访问技术无关的数据访问异常结构，用于封装不同的持久层框架抛出的异常，使得异常独立于底层的框架。</p> <h3 id="_22-spring注解分类"><a href="#_22-spring注解分类" class="header-anchor">#</a> 22.Spring注解分类</h3> <p>1、Spring注解分类
从广义上Spring注解可以分为两类：</p> <p>一类注解是用于注册Bean</p> <p>假如IOC容器就是一间空屋子，首先这间空屋子啥都没有，我们要吃大餐，我们就要从外部搬运食材和餐具进来。这里把某一样食材或者某一样餐具搬进空屋子的操作就相当于每个注册Bean的注解作用类似。注册Bean的注解作用就是往IOC容器中放（注册）东西！
用于注册Bean的注解： 比如@Component , @Repository , @ Controller , @Service , @Configration这些注解就是用于注册Bean，放进IOC容器中，一来交给spring管理方便解耦，二来还可以进行二次使用，啥是二次使用呢？这里的二次使用可以理解为：在你开始从外部搬运食材和餐具进空屋子的时候，一次性搬运了猪肉、羊肉、铁勺、筷子四样东西，这个时候你要开始吃大餐，首先你吃东西的时候肯定要用筷子或者铁勺，别说你手抓，只要你需要，你就会去找，这个时候发现你已经把筷子或者铁勺放进了屋子，你就不用再去外部拿筷子进屋子了，意思就是IOC容器中已经存在，就可以只要拿去用，而不必再去注册！而拿屋子里已有的东西的操作就是下面要讲的用于使用Bean的注解！</p> <p>一类注解是用于使用Bean</p> <p>用于使用Bean的注解：比如@Autowired , @Resource注解，这些注解就是把屋子里的东西自己拿来用，如果你要拿，前提一定是屋子（IOC）里有的，不然就会报错，比如你要做一道牛肉拼盘需要五头牛做原材料才行，你现在锅里只有四头牛，这个时候你知道，自己往屋子里搬过五头牛，这个时候就直接把屋子里的那头牛直接放进锅里，完成牛肉拼盘的组装。是的这些注解就是需要啥想要啥，只要容器中有就往容器中拿！而这些注解又有各自的区别，比如@Autowired用在筷子上，这筷子你可能只想用木质的，或许只想用铁质的，@Autowired作用在什么属性的筷子就那什么筷子，而@Resource如果用在安格斯牛肉上面，就指定要名字就是安格斯牛肉的牛肉。
Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。 产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。@Bean明确地指示了一种方法，什么方法呢？产生一个bean的方法，并且交给Spring容器管理；从这我们就明白了为啥@Bean是放在方法的注释上了，因为它很明确地告诉被注释的方法，你给我产生一个Bean，然后交给Spring容器，剩下的你就别管了。记住，@Bean就放在方法上，就是让方法去产生一个Bean，然后交给Spring容器。</p> <p>如下就能让accountDao方法产生一个AccountDao 对象，然后这个AccountDao 对象交给Spring管理</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Bean</span>
        <span class="token keyword">public</span> <span class="token class-name">AccountDao</span> <span class="token function">accountDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AccountDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>实际上，@Bean注解和xml配置中的bean标签的作用是一样的。</p> <p>为什么要有@Bean注解？
不知道大家有没有想过，用于注册Bean的注解的有那么多个，为何还要出现@Bean注解？</p> <p><strong>原因很简单：类似@Component , @Repository , @ Controller , @Service 这些注册Bean的注解存在局限性，只能局限作用于自己编写的类，如果是一个jar包第三方库要加入IOC容器的话，这些注解就手无缚鸡之力了，是的，@Bean注解就可以做到这一点！当然除了@Bean注解能做到还有@Import也能把第三方库中的类实例交给spring管理，而且@Import更加方便快捷，只是@Import注解并不在本篇范围内，这里就不再概述。</strong></p> <p>使用@Bean注解的另一个好处就是能够动态获取一个Bean对象，能够根据环境不同得到不同的Bean对象。</p> <h3 id="_23-repository和-controller、-service、-component"><a href="#_23-repository和-controller、-service、-component" class="header-anchor">#</a> 23.@Repository和@Controller、@Service、@Component</h3> <p>@Component</p> <p>@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。</p> <p>@Component有几个衍生注解，按照三处架构分层</p> <ul><li>dao[ @Repository ]</li> <li>service[ @service ]</li> <li>controller[ @Controller]</li></ul> <p>因此，当你的一个类被<code>@Component</code>所注解，那么就意味着同样可以用<code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>来替代它，同时这些注解会具备有更多的功能，而且功能各异。</p> <p>@Controller控制层</p> <p>用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象，分发处理器会扫描使用该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。@Controller只是定义了一个控制器类，而使用@RequestMapping注解的方法才是处理请求的处理器。</p> <p>@RequestMapping</p> <p>它可以注解类也可以注解方法，注解类时标注请求的路径，标注方法时表示将特定的URL映射到指定的方法。</p> <p>@Service业务逻辑层</p> <p>应用于业务层，用于标注业务层组件,表示定义一个bean，自动根据bean的类名实例化一个首写字母为小写的bean。</p> <p>@Repository持久层</p> <p>用于标注数据访问组件，即DAO组件，表示将Dao类声明为bean</p> <p>@Repository 只能标注在 DAO 类，因为该注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型。</p> <p><strong>总结</strong></p> <p><code>@Component</code>, <code>@Service</code>, <code>@Controller</code>, <code>@Repository</code>是spring注解，注解后可以被spring框架所扫描并注入到spring容器来进行管理。虽然你可以全部使用<code>@Component</code>注解，但使用其他注解，则你的类更适合于通过工具进行处理或与其他方面相关联。</p> <ul><li><code>@Component</code>是通用注解，其他三个注解是这个注解的衍生注解，并且具有了特定的功能。</li> <li><code>@Controller</code>层是spring-mvc的注解，用于标注控制层组件，并查看是否处理请求转发，重定向。</li> <li><code>@Service</code>层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。</li> <li><code>@Repository</code>注解在持久层中，标注 DAO 类，具有将数据库操作抛出的数据访问异常自动转换(封装)为spring的持久层异常的功能。</li></ul> <p>用这些注解对应用进行分层之后，就能将请求处理，义务逻辑处理，数据库操作处理分离出来，为代码解耦，也方便了以后项目的维护和开发。</p> <h3 id="_24-spring中-component和-bean的区别"><a href="#_24-spring中-component和-bean的区别" class="header-anchor">#</a> 24.Spring中@Component和@Bean的区别</h3> <p>1、@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。</p> <p>2、@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。</p> <p>两者的目的是一样的，都是注册bean到Spring容器中。</p> <p>区别：</p> <p>@Component（@Controller、@Service、@Repository）通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。</p> <p>而@Bean注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。</p> <p><strong>@Component 作用于类，@Bean作用于方法。</strong></p> <p>总结：</p> <p><strong>@Component和@Bean都是用来注册Bean并装配到Spring容器中，但是Bean比Component的自定义性更强。可以实现一些Component实现不了的自定义加载类。</strong></p> <p>@Bean示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_25-spring-factories-springboot如何自动注入-装配-maven引入的第三方库jar"><a href="#_25-spring-factories-springboot如何自动注入-装配-maven引入的第三方库jar" class="header-anchor">#</a> 25.Spring.factories(SpringBoot如何自动注入(装配)Maven引入的第三方库jar)</h3> <ol><li><p>理解自动装配的核心原理</p></li> <li><p>能手写一个EnableAutoConfiguration注解</p></li> <li><p>理解SPI机制的原理</p> <p><strong>第1章 集成Redis</strong>
1.引入依赖包</p></li></ol> <div class="language-markup extra-class"><pre class="language-markup"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>2.配置参数</p> <div class="language-markup extra-class"><pre class="language-markup"><code>spring.redis.host=192.168.8.74
spring.redis.password=123456
spring.redis.database=0
</code></pre></div><p>3.controller</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>springbootvipjtdemo<span class="token punctuation">.</span>redisdemo</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisTemplate</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">GetMapping</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMapping</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestParam</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RestController</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/redis&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisController</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/save&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> <span class="token class-name">String</span> key<span class="token punctuation">,</span><span class="token annotation punctuation">@RequestParam</span> <span class="token class-name">String</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">&quot;添加成功&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/get&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> <span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过上面的案例，我们就能看出来，RedisTemplate这个类的bean对象，我们并没有通过XML的方式也没有通过注解的方式注入到IoC容器中去，但是我们就是可以通过@Autowired注解自动从容器里面拿到相应的Bean对象，再去进行属性注入。</p> <p>最关键的要属@Import(AutoConfigurationImportSelector.class)，借助AutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件(<strong>spring.factories</strong>)的bean定义（如Java Config@Configuration配置）都加载到当前SpringBoot创建并使用的IoC容器。</p> <p><img src="http://8.130.25.175:8080/img/image-20230717152629496.png" alt="image-20230717152629496"></p> <p><strong>SpringFactoriesLoader</strong>
其实SpringFactoriesLoader的底层原理就是借鉴于JDK的SPI机制，所以，在将SpringFactoriesLoader之前，我们现在发散一下SPI机制。</p> <p><strong>SPI</strong>
SPI ，全称为 Service Provider Interface，是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。这一机制为很多框架扩展提供了可能，比如在Dubbo、JDBC中都使用到了SPI机制。我们先通过一个很简单的例子来看下它是怎么用的。</p> <h3 id="_26-springboot的自动装配原理"><a href="#_26-springboot的自动装配原理" class="header-anchor">#</a> <strong>26.SpringBoot的自动装配原理</strong></h3> <ol><li><p>SpringBootApplication注解是入口</p> <ul><li><p>@SpringBootConfiguration：继承了Configuration，表示当前是注解类</p></li> <li><p>@EnableAutoConfiguration： 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助</p></li> <li><p>@ComponentScan(excludeFilters = { // 扫描路径设置（具体使用待确认）
ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义；并将这些bean定义加载到IoC容器中.</p></li> <li><p>我们可以通过<strong>basePackages</strong>等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</p> <p>注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages</p></li></ul></li></ol> <p><strong>SpringFactoriesLoader</strong></p> <p>借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成！</p> <p>SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件META-INF/spring.factories加载配置,加载工厂类。</p> <p>SpringFactoriesLoader为Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader即需要传入工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件；</p> <p>传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类。</p> <div class="language-markup extra-class"><pre class="language-markup"><code>public abstract class SpringFactoriesLoader {
//...
　　public static <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span> List<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span> loadFactories(Class<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span> factoryClass, ClassLoader classLoader) {
　　　　...
　　}
　　public static List<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>String</span><span class="token punctuation">&gt;</span></span> loadFactoryNames(Class<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>?</span><span class="token punctuation">&gt;</span></span> factoryClass, ClassLoader classLoader) {
　　　　....
　　}
}
</code></pre></div><p>复制</p> <p>配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名
org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key,获取对应的一组@Configuration类!(https://dl-harmonyos.51cto.com/images/202207/036d3b788cb7864aaf5532dc0458db47c4c517.jpg)上图就是从SpringBoot的autoconfigure依赖包中的META-INF/spring.factories配置文件中摘录的一段内容，可以很好地说明问题。</p> <p>（重点）所以，@EnableAutoConfiguration自动配置的魔法其实就变成了：</p> <p>从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中
org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</p> <p><img src="http://8.130.25.175:8080/img/image-20230717153236810.png" alt="image-20230717153236810"></p> <h3 id="_27-单点登录"><a href="#_27-单点登录" class="header-anchor">#</a> 27.单点登录</h3> <p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一</p> <p>SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p> <p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过<code>passport</code>，子系统本身将不参与登录操作</p> <p>当一个系统成功登录以后，<code>passport</code>将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被<code>passport</code>授权以后，会建立一个局部会话，在一定时间内可以无需再次向<code>passport</code>发起认证</p> <p><img src="https://camo.githubusercontent.com/e8a925d41d93b9bc35b77a9ce5a09740e42da226c3ca283e48fa127bf432fd80/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32623962306537302d386334622d313165622d383566362d3666616337376330633962332e706e67" alt=""></p> <p>上图有四个系统，分别是<code>Application1</code>、<code>Application2</code>、<code>Application3</code>、和<code>SSO</code>，当<code>Application1</code>、<code>Application2</code>、<code>Application3</code>需要登录时，将跳到<code>SSO</code>系统，<code>SSO</code>系统完成登录，其他的应用系统也就随之登录了</p> <p><strong>如何实现单点登录：</strong></p> <p>方式1:</p> <p>我们可以部署一个认证中心，用于专门处理登录请求的独立的 <code>Web</code>服务</p> <p>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 <code>token</code> 写入 <code>Cookie</code>（注意这个 <code>Cookie</code>是认证中心的，应用系统是访问不到的）</p> <p>应用系统检查当前请求有没有 <code>Token</code>，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心</p> <p>由于这个操作会将认证中心的 <code>Cookie</code> 自动带过去，因此，认证中心能够根据 <code>Cookie</code> 知道用户是否已经登录过了</p> <p>如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录</p> <p>如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 <code>URL</code>，并在跳转前生成一个 <code>Token</code>，拼接在目标<code>URL</code> 的后面，回传给目标应用系统</p> <p>应用系统拿到 <code>Token</code>之后，还需要向认证中心确认下 <code>Token</code> 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 <code>Token</code>写入<code>Cookie</code>，然后给本次访问放行。（注意这个 <code>Cookie</code> 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 <code>Token</code>，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了</p> <p>此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法</p> <p>方式2:</p> <p>可以选择将 <code>Session ID</code> （或 <code>Token</code> ）保存到浏览器的 <code>LocalStorage</code> 中，让前端在每次向后端发送请求时，主动将<code>LocalStorage</code>的数据传递给服务端</p> <p>这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 <code>Session ID</code>（或 <code>Token</code>）放在响应体中传递给前端</p> <p>单点登录完全可以在前端实现。前端拿到 <code>Session ID</code>（或 <code>Token</code> ）后，除了将它写入自己的 <code>LocalStorage</code> 中之外，还可以通过特殊手段将它写入多个其他域下的 <code>LocalStorage</code> 中</p> <h3 id="_28-零拷贝"><a href="#_28-零拷贝" class="header-anchor">#</a> 28.零拷贝</h3> <p>https://juejin.cn/post/6995519558475841550</p> <p>零拷贝（Zero-Copy）是一种 <code>I/O</code> 操作优化技术，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间。其在 <code>FTP</code> 或者 <code>HTTP</code> 等协议中可以显著地提升性能。但是需要注意的是，并不是所有的操作系统都支持这一特性，目前只有在使用 <code>NIO</code> 和 <code>Epoll</code> 传输时才可使用该特性。</p> <p>需要注意，它不能用于实现了数据加密或者压缩的文件系统上，只有传输文件的原始内容。这类原始内容也包括加密了的文件内容。</p> <p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p> <p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p> <p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p> <ul><li><code>第一次拷贝</code>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li> <li><code>第二次拷贝</code>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li> <li><code>第三次拷贝</code>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li> <li><code>第四次拷贝</code>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul> <p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p> <p>无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 <code>DMA copy</code>是都少不了的。因为两次 DMA 都是依赖硬件完成的。所以，所谓的零拷贝，都是为了减少 CPU copy 及减少了上下文的切换。</p> <p>三个层次的文件拷贝优化：</p> <p>零拷贝技术原理</p> <p>零拷贝主要是用来解决操作系统在处理 I/O 操作时，频繁复制数据的问题。关于零拷贝主要技术有 <code>mmap+write</code>、<code>sendfile</code>和<code>splice</code>等几种方式。</p> <p>虚拟内存</p> <p>在了解零拷贝技术之前，先了解虚拟内存的概念。</p> <p>所有现代操作系统都使用虚拟内存，使用虚拟地址取代物理地址，主要有以下几点好处：</p> <ul><li>多个虚拟内存可以指向同一个物理地址。</li> <li>虚拟内存空间可以远远大于物理内存空间。</li></ul> <p>利用上述的第一条特性可以优化，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样在 I/O 操作时就不需要来回复制了。</p> <p>如下图展示了虚拟内存的原理。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93635b183ef49828843c0f50518449a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210812181924274"></p> <p>mmap/write 方式</p> <p>使用<code>mmap/write</code>方式替换原来的传统I/O方式，就是利用了虚拟内存的特性。下图展示了<code>mmap/write</code>原理：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3747aca11884a1a85708c0163c79a99~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210812201839908"></p> <p>整个流程的核心区别就是，把数据读取到内核缓冲区后，应用程序进行写入操作时，直接把内核的<code>Read Buffer</code>的数据复制到<code>Socket Buffer</code>以便写入，这次内核之间的复制也是需要CPU的参与的。</p> <p>上述流程就是少了一个 CPU COPY，提升了 I/O 的速度。不过发现上下文的切换还是4次并没有减少，这是因为还是要应用程序发起<code>write</code>操作。</p> <blockquote><p>那能不能减少上下文切换呢?这就需要<code>sendfile</code>方式来进一步优化了。</p></blockquote> <p>sendfile 方式</p> <p>从 Linux 2.1 版本开始，Linux 引入了 <code>sendfile</code>来简化操作。<code>sendfile</code>方式可以替换上面的<code>mmap/write</code>方式来进一步优化。</p> <p><code>sendfile</code>将以下操作：</p> <div class="language-java extra-class"><pre class="language-java"><code>java
复制代码  <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
替换为：
java
复制代码 <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样就减少了上下文切换，因为少了一个应用程序发起<code>write</code>操作，直接发起<code>sendfile</code>操作。</p> <p>下图展示了<code>sendfile</code>原理：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d221a3a90a754ca9842f6324455638ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210812201905046"></p> <p><code>sendfile</code>方式只有三次数据复制（其中只有一次 CPU COPY）以及2次上下文切换。</p> <blockquote><p>那能不能把 CPU COPY 减少到没有呢？这样需要带有 <code>scatter/gather</code>的<code>sendfile</code>方式了。</p></blockquote> <p>带有 scatter/gather 的 sendfile方式</p> <p>Linux 2.4 内核进行了优化，提供了带有 <code>scatter/gather</code> 的 sendfile 操作，这个操作可以把最后一次 <code>CPU COPY</code> 去除。其原理就是在内核空间 Read BUffer 和 Socket Buffer 不做数据复制，而是将 Read Buffer 的内存地址、偏移量记录到相应的 Socket Buffer 中，这样就不需要复制。其本质和虚拟内存的解决方法思路一致，就是内存地址的记录。</p> <p>下图展示了scatter/gather 的 sendfile 的原理：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/133430c1aedc4e22a6e340efc29e4239~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210812201922193"></p> <p>scatter/gather 的 sendfile 只有两次数据复制（都是 DMA COPY）及 2 次上下文切换。CUP COPY 已经完全没有。不过这一种收集复制功能是需要硬件及驱动程序支持的。</p> <p>splice 方式</p> <p><code>splice</code> 调用和<code>sendfile</code> 非常相似，用户应用程序必须拥有两个已经打开的文件描述符，一个表示输入设备，一个表示输出设备。与<code>sendfile</code>不同的是，<code>splice</code>允许任意两个文件互相连接，而并不只是文件与<code>socket</code>进行数据传输。对于从一个文件描述符发送数据到<code>socket</code>这种特例来说，一直都是使用<code>sendfile</code>系统调用，而<code>splice</code>一直以来就只是一种机制，它并不仅限于<code>sendfile</code>的功能。也就是说 sendfile 是 splice 的一个子集。</p> <p>在 Linux 2.6.17 版本引入了 splice，而在 Linux 2.6.23 版本中， sendfile 机制的实现已经没有了，但是其 API 及相应的功能还在，只不过 API 及相应的功能是利用了 splice 机制来实现的。</p> <p>和 sendfile 不同的是，splice 不需要硬件支持。</p> <p>总结</p> <p>无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 <code>DMA copy</code>是都少不了的。因为两次 DMA 都是依赖硬件完成的。所以，所谓的零拷贝，都是为了减少 CPU copy 及减少了上下文的切换。</p> <h3 id="_29-tcp建立连接为什么是三次握手-而不是两次或四次"><a href="#_29-tcp建立连接为什么是三次握手-而不是两次或四次" class="header-anchor">#</a> 29.TCP建立连接为什么是三次握手，而不是两次或四次？</h3> <ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li> <li>三次握手才可以同步双方的初始序列号</li> <li>三次握手才可以避免资源浪费</li></ul> <h3 id="_30-tcp四次挥手为什么有时会是三次挥手"><a href="#_30-tcp四次挥手为什么有时会是三次挥手" class="header-anchor">#</a> 30.TCP四次挥手为什么有时会是三次挥手？</h3> <p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p> <p><strong>所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。</strong>（ACK不携带数据，浪费网络资源，TCP往往会延迟一段时间放松ACK，如果再延迟这短时间内，发送ACK这侧的服务器或者客户端有数据要发送，就可以一起发送了，节约了网络资源。）</p> <h3 id="_31-如何对app做安全测试"><a href="#_31-如何对app做安全测试" class="header-anchor">#</a> 31.如何对app做安全测试</h3> <p>任意用户登录</p> <p>日志安全</p> <p>值符绕过</p> <p>信息泄漏</p> <p>权限问题</p> <h3 id="_32-这四种隔离级别具体是如何实现的呢"><a href="#_32-这四种隔离级别具体是如何实现的呢" class="header-anchor">#</a> 32.这四种隔离级别具体是如何实现的呢？</h3> <ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li> <li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li> <li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 *<em>Read View *<em>来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。*</em>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</em></li></ul> <h3 id="_33-可重复读隔离级别如何用mvcc解决幻读问题"><a href="#_33-可重复读隔离级别如何用mvcc解决幻读问题" class="header-anchor">#</a> 33.可重复读隔离级别如何用mvcc解决幻读问题</h3> <p><strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读（select for update当前读-----select 快照读）」而造成的幻读问题，就引出了间隙锁</strong>。</p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/3af285a8e70f4d4198318057eb955520.png" alt="img"></p> <p>事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。</p> <p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p> <p><strong>第二个发生幻读现象的场景</strong></p> <p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p> <ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li> <li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</li> <li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul> <p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p> <h3 id="_34-元数据锁"><a href="#_34-元数据锁" class="header-anchor">#</a> 34.元数据锁</h3> <p>元数据锁主要是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p> <p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p> <ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li> <li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul> <blockquote><p>MDL 不需要显示调用，那它是在什么时候释放的?</p></blockquote> <p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p> <h3 id="_35-意向锁"><a href="#_35-意向锁" class="header-anchor">#</a> 35.意向锁</h3> <ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li> <li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul> <p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables ... read*）和独占表锁（*lock tables ... write*）发生冲突。</strong></p> <p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p> <p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p> <p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p> <p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong></p> <h3 id="_36-行级锁"><a href="#_36-行级锁" class="header-anchor">#</a> 36.行级锁</h3> <p>行级锁的类型主要有三类：</p> <ul><li><p>Record Lock，记录锁，也就是仅仅把一条记录锁上；</p> <ul><li><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p> <ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li> <li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul> <p>举个例子，当一个事务执行了下面这条语句：</p> <div class="language-sql extra-class"><pre class="language-sql"><code>mysql <span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
mysql <span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_test <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre></div><p>就是对 t_test 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。</p></li></ul></li> <li><p>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</p> <ul><li>Gap Lock 称为间隙锁，只存在于<strong>可重复读隔离级别</strong>，目的是为了解决可重复读隔离级别下幻读的现象。</li></ul></li> <li><p>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身</p></li></ul> <p>LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：</p> <ul><li>如果 LOCK_MODE 为 <code>X</code>，说明是 X 型的 next-key 锁；</li> <li>如果 LOCK_MODE 为 <code>X, REC_NOT_GAP</code>，说明是 X 型的记录锁；</li> <li>如果 LOCK_MODE 为 <code>X, GAP</code>，说明是 X 型的间隙锁；</li></ul> <h3 id="_37-mysql-log"><a href="#_37-mysql-log" class="header-anchor">#</a> 37.MySQL Log</h3> <p>undo log（回滚日志）、redo log（重做日志） 、binlog （归档日志）这三种日志：</p> <ul><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li> <li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li> <li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul> <blockquote><p>redo log 和 undo log 区别在哪？</p></blockquote> <p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p> <ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li> <li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul> <p>undo log 和 redo log 这两个日志都是 <strong>Innodb 存储引擎</strong>生成的。</p> <p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p> <h3 id="_38-redo-log-循环写-和binlog-全量日志-的-区别"><a href="#_38-redo-log-循环写-和binlog-全量日志-的-区别" class="header-anchor">#</a> 38.redo log（循环写）和binlog（全量日志）的 区别</h3> <p><em>1、适用对象不同：</em></p> <ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li> <li>redo log 是 Innodb 存储引擎实现的日志；</li></ul> <p><em>2、文件格式不同：</em></p> <ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：
<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li> <li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li> <li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li> <li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li></ul> <p><em>3、写入方式不同：</em></p> <ul><li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li> <li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul> <p><em>4、用途不同：</em></p> <ul><li>binlog 用于备份恢复、主从复制；</li> <li>redo log 用于掉电等故障恢复。</li></ul> <blockquote><p>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</p></blockquote> <p>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。</p> <h3 id="_34-为什么redis选择使用跳表而不是红黑树来实现有序集合"><a href="#_34-为什么redis选择使用跳表而不是红黑树来实现有序集合" class="header-anchor">#</a> 34.为什么Redis选择使用跳表而不是红黑树来实现有序集合？</h3> <p>Redis 中的有序集合(zset) 支持的操作：</p> <ol><li>插入一个元素</li> <li>删除一个元素</li> <li>查找一个元素</li> <li>有序输出所有元素</li> <li>按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）</li></ol> <p>其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。红黑树范围查找需要中序遍历。</p> <h3 id="_35-红黑树-二叉搜索树之一"><a href="#_35-红黑树-二叉搜索树之一" class="header-anchor">#</a> 35.红黑树（二叉搜索树之一）</h3> <p>RBTree的插入操作</p> <p>RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（在这里简称插入修复），使得它符合RBTree的定义。</p> <p><strong>新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束</strong>。<strong>也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。</strong></p> <p>插入修复操作分为以下的三种情况，而且新插入的节点的父节点都是红色的：</p> <ol><li>叔叔节点也为红色。</li> <li>叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上。</li> <li>叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上。</li></ol> <h3 id="_36-内存屏障"><a href="#_36-内存屏障" class="header-anchor">#</a> 36.内存屏障</h3> <p><strong>内存屏障（memory barrier）是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。</strong></p> <p>编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p> <p><strong>不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码。</strong>
Java内存屏障主要有Load和Store两类。
对Load Barrier来说，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据
对Store Barrier来说，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存</p> <p><strong>Volatile基本介绍</strong>
Java语言规范第三版中对volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。
Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。
<strong>volatile作用</strong> <strong>能保证可见性和防止指令重排序</strong></p> <p><strong>volatile与synchronized对比</strong>
volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为<strong>它不会引起线程上下文的切换和调度</strong></p> <p><strong>volatile如何保证可见性、防止指令重排序</strong>
volatile保持内存可见性和防止指令重排序的原理，本质上是同一个问题，也都<strong>依靠内存屏障得到解决</strong></p> <p><strong>volatile关键字通过“内存屏障”来防止指令被重排序。</strong> <strong>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序</strong></p> <p>下面是基于保守策略的JMM内存屏障插入策略：
在每个volatile写操作的前面插入一个StoreStore屏障。
在每个volatile写操作的后面插入一个StoreLoad屏障。
在每个volatile读操作的后面插入一个LoadLoad屏障。
在每个volatile读操作的后面插入一个LoadStore屏障。</p> <p><strong>volatile为什么不能保证原子性</strong>
原子操作是一些列的操作要么全做，要么全不做，而<strong>volatile 是一种弱的同步机制，只能确保共享变量的更新操作及时被其他线程看到</strong>，以最常用的i++来说吧，包含3个步骤
1，从内存读取i当前的值 2，加1 变成 3，把修改后的值刷新到内存，volatile无法保证这三个不被打断的执行完毕，如果在刷新到内存之前有中断，此时被其他线程修改了，之前的值就无效了
<strong>volatile的适用场景</strong>
volatile是在synchronized性能低下的时候提出的。如今synchronized的效率已经大幅提升，所以volatile存在的意义不大。</p> <p><strong>内存屏障类型</strong>：</p> <p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p> <table><thead><tr><th>屏障类型</th> <th>指令示例</th> <th>说明</th></tr></thead> <tbody><tr><td>LoadLoad Barriers</td> <td>Load1; LoadLoad; Load2</td> <td>确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td></tr> <tr><td>StoreStore Barriers</td> <td>Store1; StoreStore; Store2</td> <td>确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr> <tr><td>LoadStore Barriers</td> <td>Load1; LoadStore; Store2</td> <td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr> <tr><td>StoreLoad Barriers</td> <td>Store1; StoreLoad; Load2</td> <td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td></tr></tbody></table> <p>StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p> <p>StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p> <h3 id="_37-三色标记法gc"><a href="#_37-三色标记法gc" class="header-anchor">#</a> 37.三色标记法GC</h3> <p>GC 垃圾回收器其主要的目的是为了实现内存的回收，在这个过程中主要的两个步骤就是：内存标记，内存回收。</p> <p>三色标记法，主要是为了高效的标记可被回收的内存块。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c35aa72bac744b15b008363cf42977ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p> <p>三色标记（Tri-color Marking）作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：</p> <ul><li>对象在标记过程中，根据标记情况，分成三类：
<ol><li>白色对象，表示自身未被标记；</li> <li>灰色对象，表示自身被标记，但内部引用未被处理；</li> <li>黑色对象，表示自身被标记，内部引用都被处理；</li></ol></li></ul> <p>三色标记过程</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23aea3d2c7ea43b6b9f39c45ddf68499~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p> <p><strong>标记过程：</strong></p> <ol><li>在  <code>GC</code> 标记开始的时候，所有的对象均为白色；</li> <li>在将所有的 <code>GC Roots</code> 直接引用的对象标记为灰色集合；</li> <li>如果判断灰色集合中的对象不存在子引用，则将其放入黑色集合，若存在子引用对象，则将其所有的子引用对象存放到灰色集合，当前对象放入黑色集合。</li> <li>按照此步骤 3 ，依此类推，直至灰色集合中所有的对象变黑后，本轮标记完成，并且在白色集合内的对象称为不可达对象，即垃圾对象。</li> <li>标记结束后，为白色的对象为 GC Roots 不可达，可以进行垃圾回收。</li></ol> <p><strong>误标</strong></p> <p>三色标记的过程中，标记线程和用户线程是并发执行的，那么就有可能在我们标记过程中，用户线程修改了引用关系，把原本应该回收的对象错误标记成了存活。(简单来说就是 <code>GC</code> 已经标黑的对象，在并发过程中用户线程引用链断掉，导致实际应该是垃圾的白色对象但却依旧是黑的，也就是<strong>浮动垃圾</strong>)。这时产生的垃圾怎么办呢？答案是本次不处理，留给下次垃圾回收处理。</p> <p>而<strong>误标</strong>问题，意思就是把本来应该存活的对象，标记为了死亡。这就会导致非常严重的错误。那么这类垃圾是怎么产生的呢?</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d907d5b2bc2342619931531d42651378~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="误标的发生过程.png"></p> <p>途中对象 <code>A</code> 被标记为了黑色，此时它所引用的两个对象 <code>B</code>,<code>C</code> 都在被标记的灰色阶段。此时用户线程把<code>B-&gt;D</code>之间的的引用关系删除，并且在<code>A-&gt;D</code> 之间建立引用。此时<code>B</code>对象依然未扫描结束，而A对象又已经被扫描过了，不会继续接着往下扫描了。因此 <code>D</code>对象就会被当做垃圾回收掉。</p> <p><strong>什么是误标？当下面两个条件同时满足，会产生误标：</strong>（在并发标记过程中，出现一下对象引用变动的行为）</p> <ol><li>赋值器插入了一条或者多条黑色对象到白色对象的引用</li> <li>赋值器删除了全部从灰色对象到白色对象的直接引用或者间接引用</li></ol> <p><strong>误标的解决方案</strong></p> <p>要解决误标的问题，只需要破坏这两个条件中的任意一种即可，分别有两种解决方案：增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning, STAB）</p> <p><strong>增量更新</strong></p> <p>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p> <p><strong>原始快照 (STAB)</strong></p> <p>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发标记结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p> <h3 id="_38-cms与g1收集器"><a href="#_38-cms与g1收集器" class="header-anchor">#</a> 38.CMS与G1收集器</h3> <p>CMS是老年代并发GC算法：(ConcurrentMark-SweepGC、CMS GC)。</p> <p>算法总体逻辑：标记-清除（Mark-Sweep)</p> <p>cms是最常用的垃圾垃圾回收器，下面分析下CMS垃圾回收器工作原理；</p> <p>CMS 处理过程有七个步骤：</p> <ol><li><p>初始标记(CMS-initial-mark) ,会导致swt；</p></li> <li><p>并发标记(CMS-concurrent-mark)，与用户线程同时运行；</p></li> <li><p>预清理（CMS-concurrent-preclean），与用户线程同时运行；</p></li> <li><p>可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；</p></li> <li><p>重新标记(CMS-remark) ，会导致swt；</p></li> <li><p>并发清除(CMS-concurrent-sweep)，与用户线程同时运行；</p></li> <li><p>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；</p></li></ol> <p>cms运行流程图如下所示：</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/19/16de2dc0e2f7982a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="CMS流程图"></p> <p>跨代引用-old-&gt;young 或者young-&gt;old</p> <p>​		CMS 主要负责回收年老代垃圾，使用CMS时新生代垃圾收集工作通常由Serial New 或 ParNew 完成，默认新生代垃圾回收器为ParNew。CMS回收年老代垃圾时，将整体垃圾回收的过程拆分为多个阶段，并且大部分阶段与应用线程都是并发不会发生STW。CMS整体垃圾回收过程可分为初始化标记（ Initial-mark）、并发标记（Concurrent Marking）、并发预清除（Concurrent Pre-cleaning）、重新标记（Remark）、并发清除（Concurrent Sweeping），初始化标记与重新标记都会发生STW，但通常时间都比较短。CMS早其版本中初始化标记与重新标记都是由单线程完成的，后期版本可以通过 -XX:+CMSParallelInitialMark 与 -XX:CMSParallelRemarkEnabled 分别将初始化标记与重新标记阶段指定为多线程。在CMS对年老代进行并发回收时很多可能新生代发生了Young GC，此时年老代垃圾回收将立刻中断，直到Young GC结束后又重新恢复。</p> <div class="language- extra-class"><pre class="language-text"><code>1、Young GC 时，Eden区域存活的对象过大Survivor区域无法存放导致promotion failed，此时对象只能放入年老代，但由于内存碎片问题年老代同样放不下该对象，最后将发生concurrent mode failure，这时会引发Full GC，Full GC会回收整个Heap 空间导致STW时长骤增。

2、Young GC 时，Survivor 区域存活对象年龄超过了MaxTenuringThreshold，晋升到年老代，但由于内存碎片问题年老代放不下该对象，将发生concurrent mode failure，这时会引发Full GC。
</code></pre></div><p><strong>G1垃圾收集器</strong> Garbage First   https://juejin.cn/post/7050324680875442183</p> <p>G1开启了分区垃圾收集器的先河（虽然G1在逻辑上也有新生代与年老代的概念）。G1利用分治的思想将整体Heap划分为一块块大小相等的Region，在内存管理时可以针对这些Region进行管理，而不是笼统地对某个Generation进行管理。由于Region的大小通常远小于Generation，垃圾回收时处理多个Region效率通常高于处理某个Generation。</p> <p>①. G1(Garbage-First)是一款面向服务端应用的垃圾收集器,主要针对配备多核CPU及大容量内存的机器,<strong>以极高概率满足GC停顿时间的同时</strong>,还<strong>兼具高吞吐量的性能特征</strong></p> <p>②. 在JDK1.7版本正式启用,是<strong>JDK 9以后的默认垃圾收集器,取代了CMS 回收器</strong>。</p> <p><strong>为什么名字叫Garbage First？</strong></p> <p>①. G1是一个并行回收器,它<strong>把堆内存分割为很多不相关的区域(region物理上不连续),把堆分为2048个区域</strong>,每一个region的大小是1 - 32M不等,必须是<strong>2的整数次幂</strong>。使用不同的region可以来表示Eden、幸存者0区、幸存者1区、老年代等</p> <p>②. 每次根据允许的收集时间,<strong>优先回收价值最大的Region</strong>
(每次回收完以后都有一个空闲的region,在后台维护一个优先列表)</p> <p>③. 由于这种方式的侧重点在于回收垃圾最大量的区间(Region),所以我们给G1一个名字:<strong>垃圾优先(Garbage First)</strong></p> <p>④. 下面说一个问题:<strong>既然我们已经有了前面几个强大的GC,为什么还要发布Garbage First(G1)GC？</strong></p> <ul><li><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量,所以才担当起&quot;全功能收集器&quot;的重任与期望。</strong></li></ul> <p><strong>分区Region：化整为零</strong></p> <ul><li>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB,2MB, 4MB, 8MB, 1 6MB, 32MB。可以通过-XX :G1HeapRegionSize设定。<strong>所有的Region大小相同</strong>，且<strong>在JVM生命周期内不会被改变</strong>。</li> <li>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了,它们都是一部分Region (不需要连续)的集合。<strong>通过Region的动态分配方式实现逻辑上的连续。</strong></li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00269e5e4dcf463da7ff2eb0b8368fc3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p> <ul><li><p>一个region有可能属于Eden， Survivor 或者0ld/Tenured 内存区域。但是<strong>一个region只可能属于一个角色</strong>。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，o表示属于old内存区域。图中空白的表示未使用的内存空间。</p></li> <li><p>G1垃圾收集器还增加了一种新的内存区域，叫做<strong>Humongous内存区域</strong>，如图中的H块。主要用于存储大对象，如果<strong>超过1.5个region, 就放到H</strong>。</p></li> <li><p>设置H的原因:</p></li> <li><p><strong>对于堆中的大对象，默认直接会被分配到老年代</strong>，但是如果它是<strong>一个短期存在的大对象，就会对垃圾收集器造成负面影响</strong>。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对<strong>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来
存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC。 G1的大多数行为都把H区 作为老年代的一部分来看待。</p></li></ul> <p><strong>G1回收器垃圾回收过程</strong></p> <p><strong>①. G1 GC的垃圾回收过程主要包括如下三个环节：</strong></p> <ul><li>年轻代GC (Young GC)</li> <li>老年代并发标记过程 (Concurrent Marking)</li> <li>混合回收(Mixed GC)</li></ul> <p>(如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它
针对GC的评估失败提供了-种失败保护机制，即强力回收。)</p> <p>顺时针young gc -&gt; young gc + concurrent mark-&gt; Mixed GC顺序,进行垃圾回收</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9034cb2bf76479fb3eb073d11c72dc9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p> <p><strong>②. 应用程序分配内存</strong>,<strong>当年轻代的Eden区用尽时开始年轻代回收过程；*<em>G1的年轻代收集阶段是一个*<em>并行(多个垃圾线程)的独占式收集器</em></em>。在年轻代回收期,G1 GC暂停所有应用程序线程,启动多线程执行年轻代回收。然后</strong>从年轻代区间移动存活对象到Survivor区间或者老年区间,也有可能是两个区间都会涉及**</p> <p>③. <strong>当堆内存使用达到一定值(默认45%)时,开始老年代并发标记过程</strong></p> <p>④. <strong>标记完成马上开始混合回收过程</strong>。对于一个混合回收期,G1 GC从老年区间移动存活对象到空闲区间,这些空闲区间也就成为了老年代的一部分。和年轻代不同,老年代的G1回收器和其他GC不同,<strong>G1的老年代回收器不需要整个老年代被回收,一次只需要扫描/回收一小部分老年代的Region就可以了</strong>。同时,这个<strong>老年代Region是和年轻代一起被回收的。</strong></p> <p>⑤. 举个例子：一个Web服务器,Java进程最大堆内存为4G,每分钟响应1500个请求,每45秒钟会新分配大约2G的内存。G1会每45秒钟进</p> <h3 id="_39-springboot的类加载过程"><a href="#_39-springboot的类加载过程" class="header-anchor">#</a> 39.SpringBoot的类加载过程</h3> <p>（java本身的双亲委派模型以及maven中jar包或者jdbc驱动这样的SPI服务提供接口这样的SPI机制）</p> <p>Spring的类加载器实现原理是基于Java的类加载机制，并且使用了双亲委派模式。在Spring中，类加载器的实现主要涉及到两个方面：双亲委派加载机制和SPI机制。</p> <p>首先，Spring使用双亲委派加载机制来加载类。这种机制是指系统启动后，应用类加载器会加载应用类，然后发起双亲委派机制，让上级扩展类加载器去加载，如果扩展类加载器加载不到，则让应用类加载器加载。这样可以保证类的加载顺序和一致性，避免重复加载和冲突。[1]</p> <p>其次，Spring还使用了SPI（Service Provider Interface）机制来加载第三方jar包中的类。SPI机制是指第三方jar包通过ServiceLoader.load方法进行加载，首先通过双亲委派机制，Bootstrap类加载器加载到了ServiceLoader类，然后在Spring中通过ServiceLoader去加载第三方jar中的类时，由于类加载器的传递性，只能通过Bootstrap类加载器去加载第三方jar，然后顶级类加载器加载不了这个jar，所以只能通过当前线程上下文中的类加载器去加载第三方jar包的类。这里就打破了双亲委派。[3]</p> <p>综上所述，Spring的类加载器实现原理是基于Java的类加载机制，使用了双亲委派加载机制和SPI机制。这样可以保证类的加载顺序和一致性，并且能够加载第三方jar包中的类。</p> <h3 id="_40-类加载过程"><a href="#_40-类加载过程" class="header-anchor">#</a> 40.类加载过程</h3> <p><strong>加载-验证-准备-解析-初始化</strong></p> <p>​	类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化</strong>（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</p> <p><strong>加载</strong>时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</p> <ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li> <li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li> <li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul> <p><img src="http://8.130.25.175:8080/img/java_jvm_classload_1.png" alt="img"></p> <p>相对于类加载的其他阶段而言，<em>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段</em>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p> <p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p> <p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p> <blockquote><p>加载.class文件的方式</p></blockquote> <ul><li>从本地系统中直接加载</li> <li>通过网络下载.class文件</li> <li>从zip，jar等归档文件中加载.class文件</li> <li>从专有数据库中提取.class文件</li> <li>将Java源文件动态编译为.class文件</li></ul> <p><strong>链接的三个步骤</strong></p> <p><strong>验证: 确保被加载的类的正确性</strong></p> <p><strong>准备: 为类的静态变量分配内存，并将其初始化为默认值</strong>，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。</p> <p><strong>解析: 把类中的符号引用转换为直接引用</strong>符号引用就是一组符号来描述目标，可以是任何字面量。</p> <p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p> <p><strong>初始化</strong></p> <p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p> <ul><li>声明类变量是指定初始值</li> <li>使用静态代码块为类变量指定初始值</li></ul> <p><strong>JVM初始化步骤</strong></p> <ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li> <li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li> <li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul> <p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p> <ul><li>创建类的实例，也就是new的方式</li> <li>访问某个类或接口的静态变量，或者对该静态变量赋值</li> <li>调用类的静态方法</li> <li>反射(如Class.forName(&quot;com.pdai.jvm.Test&quot;))</li> <li>初始化某个类的子类，则其父类也会被初始化</li> <li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li></ul> <p>使用</p> <p>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</p> <h3 id=""><a href="#" class="header-anchor">#</a></h3> <h3 id="_41-java类加载初始化顺序-重在顺序"><a href="#_41-java类加载初始化顺序-重在顺序" class="header-anchor">#</a> 41.java类加载初始化顺序（重在顺序）</h3> <p>程序首先加载类，然后再对类进行初始化。</p> <p>加载类的顺序为：先加载基类，基类加载完毕后再加载子类。</p> <p>初始化的顺序为：先初始化基类，基类初始化完毕后再初始化子类。</p> <p>最后得出类加载顺序为：先按照声明顺序初始化基类静态变量和静态代码块，接着按照声明顺序初始化子类静态变量和静态代码块，而后按照声明顺序初始化基类普通变量和普通代码块，然后执行基类构造函数，接着按照声明顺序初始化子类普通变量和普通代码块，最后执行子类构造函数。</p> <p>对于本测试中的执行顺序为：先初始化static的变量，在执行main()方法之前就需要进行加载。再执行main方法，如果new一个对象，则先对这个对象类的基本成员变量进行初始化（非方法），包括构造代码块，这两种是按照编写顺序按序执行的，再调用构造函数。 关于继承的初始化机制，首先执行含有main方法的类，观察到Zi类含有基类Fu，即先加载Fu类的static变量，再加载Zi类的static变量。加载完static变量之后，调用main()方法，new Zi()则先初始化基类的基本变量和构造代码块，再调用基类的构造方法。然后再初始化子类Zi的基本变量和构造代码块，再执行子类的构造函数。</p> <h3 id="_42-jvm运行时内存结构-五个分区"><a href="#_42-jvm运行时内存结构-五个分区" class="header-anchor">#</a> 42.JVM运行时内存结构（五个分区）</h3> <p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p> <p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p> <ul><li>类和接口的全限定名</li> <li>字段的名称和描述符</li> <li>方法的名称和描述符</li></ul> <p>HotSpot 虚拟机对<strong>常量池</strong>的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</p> <p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：</p> <ul><li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</p></li> <li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</p></li> <li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p></li></ul> <h3 id="_43-逃逸分析"><a href="#_43-逃逸分析" class="header-anchor">#</a> 43.逃逸分析</h3> <p><strong>逃逸分析(Escape Analysis)*<em>是目前 Java 虚拟机中比较前沿的优化技术*</em>。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p> <p>逃逸分析的基本行为就是分析对象动态作用域：</p> <ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li> <li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li></ul> <p>例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StringBuffer</span> <span class="token function">craeteStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> sb<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将sb返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，但是其逃逸到了方法外部。<strong>甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸</strong>。</p> <p>上述代码如果想要 <code>StringBuffer sb</code>不逃出方法，可以这样写：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。（<strong>不逃逸才是好事-不逃逸的对象才可能在栈上分配，栈上分配对象更快，且没有GC）</strong></p> <p>使用逃逸分析，编译器可以对代码做优化：</p> <ul><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li> <li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li> <li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li></ul> <p><strong>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</strong></p> <p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p> <p><strong>代码优化之同步省略（消除）</strong></p> <ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li> <li>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li></ul> <p><strong>代码优化之标量替换</strong></p> <p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p> <p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p> <p>在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p> <p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">Point</span> point <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span>（<span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span>）<span class="token punctuation">;</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;point.x=&quot;</span><span class="token operator">+</span>point<span class="token punctuation">.</span>x<span class="token operator">+</span><span class="token string">&quot;; point.y=&quot;</span><span class="token operator">+</span>point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上代码中，point 对象并没有逃逸出 <code>alloc()</code> 方法，并且 point 对象是可以拆解成标量的。那么，JIT 就不会直接创建 Point 对象，而是直接使用两个标量 int x ，int y 来替代 Point 对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;point.x=&quot;</span><span class="token operator">+</span>x<span class="token operator">+</span><span class="token string">&quot;; point.y=&quot;</span><span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>代码优化之栈上分配</strong></p> <p>我们通过 JVM 内存分配可以知道 JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p> <h3 id="_44-tcp延迟确认机制"><a href="#_44-tcp延迟确认机制" class="header-anchor">#</a> 44.TCP延迟确认机制</h3> <p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p> <ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li> <li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li> <li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul> <p><img src="https://cdn.xiaolincoding.com//mysql/other/33f3d2d54a924b0a80f565038327e0e4.png" alt="img"></p> <p>TCP四次挥手（client-FIN-&gt;server-ACK-&gt;server-FIN-&gt;client-ack）,中间两个可能合并成一次传输（ACK+FIN），变成三次挥手。</p> <p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p> <p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p> <p><strong>所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。</strong></p> <h3 id="_45-transactional注解"><a href="#_45-transactional注解" class="header-anchor">#</a> 45.@Transactional注解</h3> <p>@<a href="https://so.csdn.net/so/search?q=Transactional&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">Transactional<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 是声明式事务管理 编程中使用的注解</p> <p><strong>1 .添加位置</strong></p> <p>1）接口实现类或接口实现方法上，而不是接口类中。
2）访问权限：public 的方法才起作用。@Transactional 注解应该只被应用到 public 方法上，这是由 Spring <a href="https://so.csdn.net/so/search?q=AOP&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">AOP<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的本质决定的。
系统设计：将标签放置在需要进行事务管理的方法上，而不是放在所有接口实现类上：<strong>只读的接口就不需要事务管理</strong>，由于配置了@Transactional就需要AOP拦截及事务的处理，可能影响系统性能。</p> <p>3）错误使用：</p> <div class="language-less extra-class"><pre class="language-less"><code>1.接口中A、B两个方法，A无<span class="token variable">@Transactional</span>标签，B有，上层通过A间接调用B，此时事务不生效。
2.接口中异常（运行时异常）被捕获而没有被抛出。
  默认配置下，spring 只有在抛出的异常为运行时 unchecked 异常时才回滚该事务，
  也就是抛出的异常为RuntimeException 的子类<span class="token punctuation">(</span>Errors也会导致事务回滚<span class="token punctuation">)</span>，
  而抛出 checked 异常则不会导致事务回滚 。可通过 <span class="token variable">@Transactional</span> rollbackFor进行配置。
3.多线程下事务管理因为线程不属于 spring 托管，故线程不能够默认使用 spring 的事务<span class="token punctuation">,</span>
  也不能获取spring 注入的 bean 。
  在被 spring 声明式事务管理的方法内开启多线程，多线程内的方法不被事务控制。
  一个使用了<span class="token variable">@Transactional</span> 的方法，如果方法内包含多线程的使用，方法内部出现异常，
  不会回滚线程中调用方法的事务。
</code></pre></div><p><strong>@Transactional注解</strong>
@Transactional 实质是使用了 JDBC 的事务来进行事务控制的
@Transactional 基于 Spring 的动态代理的机制</p> <p>@Transactional 实现原理：</p> <ol><li><p>事务开始时，通过AOP机制，生成一个代理connection对象，
并将其放入 DataSource 实例的某个与 DataSourceTransactionManager 相关的某处容器中。
在接下来的整个事务中，客户代码都应该使用该 connection 连接数据库，
执行所有数据库命令。
[不使用该 connection 连接数据库执行的数据库命令，在本事务回滚的时候得不到回滚]
（物理连接 connection 逻辑上新建一个会话session；
DataSource 与 TransactionManager 配置相同的数据源）</p></li> <li><p>事务结束时，回滚在第1步骤中得到的代理 connection 对象上执行的数据库命令，
然后关闭该代理 connection 对象。
（事务结束后，回滚操作不会对已执行完毕的SQL操作命令起作用）</p></li></ol> <p><strong>声明式事务的管理实现本质：</strong>
事务的两种开启方式：
显示开启 start transaction | begin，通过 commit | rollback 结束事务
关闭数据库中自动提交 autocommit set autocommit = 0；MySQL 默认开启自动提交；通过手动提交或执行回滚操作来结束事务</p> <p>Spring 关闭数据库中自动提交：在方法执行前关闭自动提交，方法执行完毕后再开启自动提交</p> <h3 id="_46-事务传播机制"><a href="#_46-事务传播机制" class="header-anchor">#</a> 46.事务传播机制</h3> <p><strong>事务传播行为</strong>：如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为</p> <p>什么叫事务传播行为？既然是传播，那么至少有两个东西，才可以发生传播。单体不存在传播这个行为。</p> <p>事务传播行为（Propagation behavior）指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。</p> <p>例如：method A事务方法调用method B事务方法时，method B是继续在调用者method A的事务中运行呢，还是为自己开启一个新事务运行，这就是由method B 的事务传播行为决定的。</p> <div class="language-SQL extra-class"><pre class="language-sql"><code><span class="token number">1.</span> TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_REQUIRED：
   如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。
 
<span class="token number">2.</span> TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_REQUIRES_NEW：
   创建一个新的事务，如果当前存在事务，则把当前事务挂起。
 
<span class="token number">3.</span> TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_SUPPORTS：
   如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
 
<span class="token number">4.</span> TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_NOT_SUPPORTED：
   以非事务方式运行，如果当前存在事务，则把当前事务挂起。
 
<span class="token number">5.</span> TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_NEVER：
   以非事务方式运行，如果当前存在事务，则抛出异常。
 
<span class="token number">6.</span> TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_MANDATORY：
   如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
 
<span class="token number">7.</span> TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_NESTED：
   如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；
   如果当前没有事务，则该取值等价于TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_REQUIRED。
</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20181123164237116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEzMTQ0NDI=,size_16,color_FFFFFF,t_70" alt="img"></p> <h3 id="_47-倒排索引"><a href="#_47-倒排索引" class="header-anchor">#</a> 47.倒排索引</h3> <p><strong>倒排索引(Inverted Index)</strong>：倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</p> <p>倒排索引简单实例</p> <p>中文和英文等语言不同，单词之间没有明确分隔符号，所以首先要用分词系统将文档自动切分成单词序列。这样每个文档就转换为由单词序列构成的数据流，为了系统后续处理方便，需要对每个不同的单词赋予唯一的单词编号，同时记录下哪些文档包含这个单词，在如此处理结束后，我们可以得到最简单的倒排索引（参考图3-4）。在图4中，“单词ID”一栏记录了每个单词的单词编号，第二栏是对应的单词，第三栏即每个单词对应的倒排列表。比如单词“谷歌”，其单词编号为1，倒排列表为{1,2,3,4,5}，说明文档集合中每个文档都包含了这个单词。</p> <p><img src="https://images2015.cnblogs.com/blog/855959/201702/855959-20170224200334195-2052728227.png" alt="img"></p> <p>之所以说图4所示倒排索引是最简单的，是因为这个索引系统只记载了哪些文档包含某个单词，而事实上，索引系统还可以记录除此之外的更多信息。图5是一个相对复杂些的倒排索引，与图4的基本索引系统比，在单词对应的倒排列表中不仅记录了文档编号，还记载了单词频率信息（TF），即这个单词在某个文档中的出现次数，之所以要记录这个信息，是因为词频信息在搜索结果排序时，计算查询和文档相似度是很重要的一个计算因子，所以将其记录在倒排列表中，以方便后续排序时进行分值计算。在图5的例子里，单词“创始人”的单词编号为7，对应的倒排列表内容为：（3:1），其中的3代表文档编号为3的文档包含这个单词，数字1代表词频信息，即这个单词在3号文档中只出现过1次，其它单词对应的倒排列表所代表含义与此相同。</p> <p><img src="https://images2015.cnblogs.com/blog/855959/201702/855959-20170224200448148-924219280.png" alt="855959-20170224200448148-924219280"></p> <p>实用的倒排索引还可以记载更多的信息，图6所示索引系统除了记录文档编号和单词频率信息外，额外记载了两类信息，即每个单词对应的“文档频率信息”（对应图6的第三栏）以及在倒排列表中记录单词在某个文档出现的位置信息。</p> <p>图6所示倒排索引已经是一个非常完备的索引系统，实际搜索系统的索引结构基本如此，区别无非是采取哪些具体的数据结构来实现上述逻辑结构。</p> <p>有了这个索引系统，搜索引擎可以很方便地响应用户的查询，比如用户输入查询词“Facebook”，搜索系统查找倒排索引，从中可以读出包含这个单词的文档，这些文档就是提供给用户的搜索结果，而利用单词频率信息、文档频率信息即可以对这些候选搜索结果进行排序，计算文档和查询的相似性，按照相似性得分由高到低排序输出，此即为搜索系统的部分内部流程，具体实现方案本书第五章会做详细描述。</p> <h3 id="_48-redis的内存淘汰策略"><a href="#_48-redis的内存淘汰策略" class="header-anchor">#</a> 48.Redis的内存淘汰策略</h3> <p>（<strong>主要是分为是否淘汰，淘汰设置了过期时间的，以及淘汰全部）</strong></p> <p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p> <p><em>1、<strong>不进行数据淘汰的策略</strong></em></p> <p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，则会触发 OOM，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</p> <p><em>2、进行数据淘汰的策略</em></p> <p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p> <p>在设置了过期时间的数据中进行淘汰：</p> <ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li> <li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li> <li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li> <li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul> <p>在所有数据范围内进行淘汰：</p> <ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li> <li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li> <li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul> <blockquote><p>Redis 是如何实现 LRU 算法的？</p></blockquote> <p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p> <p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p> <blockquote><p>Redis 是如何实现 LFU 算法的？</p></blockquote> <p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。</p> <p>注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 <strong>logc 会随时间推移而衰减的</strong>。</p> <p>在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p> <h3 id="_49-jdk动态代理"><a href="#_49-jdk动态代理" class="header-anchor">#</a> 49.JDK动态代理</h3> <ul><li><p>什么是代理 (模式)？</p> <p>代理模式 (Proxy Pattern) 也称委托模式 (Deletage Pattern)，属于结构型设计模式，也是一项基本的设计技巧。通常，代理模式用于处理两种问题：</p> <ul><li><strong>1、控制对基础对象的访问</strong></li> <li><strong>2、在访问基础对象时增加额外功能</strong></li></ul></li> <li><p><strong>代理的基本分类：</strong> 静态代理 + 动态代理，分类的标准是 <strong>“代理关系是否在编译期确定；</strong></p></li> <li><p><strong>动态代理的实现方式：</strong> JDK、CGLIB、Javassist、ASM</p></li></ul> <p>静态代理是指代理关系在编译期确定的代理模式。使用静态代理时，通常的做法是为每个业务类抽象一个接口，对应地创建一个代理类。</p> <p>。举个例子，需要给网络请求增加日志打印：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code>typescript
复制代码<span class="token number">1</span>、定义基础接口
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HttpApi</span> <span class="token punctuation">{</span>
    String <span class="token function">get</span><span class="token punctuation">(</span>String url<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token number">2</span>、网络请求的真正实现
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealModule</span> <span class="token keyword">implements</span> <span class="token class-name">HttpApi</span> <span class="token punctuation">{</span>
     <span class="token decorator"><span class="token at operator">@</span><span class="token function">Override</span></span>
     <span class="token keyword">public</span> String <span class="token function">get</span><span class="token punctuation">(</span>String url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token string">&quot;result&quot;</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token number">3</span>、代理类
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">HttpApi</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> HttpApi target<span class="token punctuation">;</span>

    <span class="token function">Proxy</span><span class="token punctuation">(</span>HttpApi target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Override</span></span>
    <span class="token keyword">public</span> String <span class="token function">get</span><span class="token punctuation">(</span>String url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 扩展的功能</span>
        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">&quot;http-statistic&quot;</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 访问基础对象</span>
        <span class="token keyword">return</span> target<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2.2 静态代理的缺点</p> <ul><li><strong>1、重复性：</strong> 需要代理的业务或方法越多，重复的模板代码越多；</li> <li><strong>2、脆弱性：</strong> 一旦改动基础接口，代理类也需要同步修改（因为代理类也实现了基础接口）。</li></ul> <p><strong>动态代理</strong>：</p> <p>动态代理是指代理关系在运行时确定的代理模式。需要注意，JDK 动态代理并不等价于动态代理，前者只是动态代理的实现之一，其它实现方案还有：CGLIB 动态代理、Javassist 动态代理和 ASM 动态代理等。因为代理类在编译前不存在，代理关系到运行时才能确定，因此称为动态代理。</p> <p>JDK 动态代理示例</p> <p>我们今天主要讨论JDK 动态代理（Dymanic Proxy API），它是 JDK1.3 中引入的特性，核心 API 是 Proxy 类和 InvocationHandler 接口。它的原理是利用反射机制在运行时生成代理类的字节码。</p> <p>我们继续用打印日志的例子，使用动态代理时：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpApi <span class="token function">getProxy</span><span class="token punctuation">(</span>HttpApi target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>HttpApi<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>
                target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">LogHandler</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LogHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> HttpApi target<span class="token punctuation">;</span>

        <span class="token function">LogHandler</span><span class="token punctuation">(</span>HttpApi target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// method底层的方法无参数时，args为空或者长度为0</span>
        <span class="token decorator"><span class="token at operator">@</span><span class="token function">Override</span></span>
        <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> <span class="token decorator"><span class="token at operator">@</span><span class="token function">Nullable</span></span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>       
               throws Throwable <span class="token punctuation">{</span>
            <span class="token comment">// 扩展的功能</span>
            Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">&quot;http-statistic&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 访问基础对象</span>
            <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果需要兼容多个业务接口，可以使用泛型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">{</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">SuppressWarnings</span></span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token constant">T</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token constant">T</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token constant">T</span><span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>
        target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">LogHandler</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LogHandler<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>
        <span class="token comment">// 同上</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>客户端调用：</p> <div class="language-ini extra-class"><pre class="language-ini"><code><span class="token key attr-name">HttpAPi proxy</span> <span class="token punctuation">=</span> <span class="token value attr-value">ProxyFactory.getProxy&lt;HttpApi&gt;(target);</span>
<span class="token key attr-name">OtherHttpApi proxy</span> <span class="token punctuation">=</span> <span class="token value attr-value">ProxyFactory.getProxy&lt;OtherHttpApi&gt;(otherTarget);</span>
</code></pre></div><p>通过泛型参数传递不同的类型，客户端可以按需实例化不同类型的代理对象。基础接口的所有方法都统一到 InvocationHandler#invoke() 处理。静态代理的两个缺点都得到解决：</p> <ul><li>1、重复性：即使有多个基础业务需要代理，也不需要编写过多重复的模板代码；</li> <li>2、脆弱性：当基础接口变更时，同步改动代理并不是必须的。</li></ul> <p><strong>静态代理 &amp; 动态代理对比</strong></p> <ul><li>共同点：两种代理模式实现都在不改动基础对象的前提下，对基础对象进行访问控制和扩展，符合开闭原则。</li> <li>不同点：静态代理存在重复性和脆弱性的缺点；而动态代理（搭配泛型参数）可以实现了一个代理同时处理 N 种基础接口，一定程度上规避了静态代理的缺点。从原理上讲，静态代理的代理类 Class 文件在编译期生成，而动态代理的代理类 Class 文件在运行时生成，代理类在 coding 阶段并不存在，代理关系直到运行时才确定。</li></ul> <h3 id="_50-fast-fail机制"><a href="#_50-fast-fail机制" class="header-anchor">#</a> 50.Fast-fail机制</h3> <p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ifan/Notes/Summary/summary2.html" class="prev">
        summary2
      </a></span> <span class="next"><a href="/ifan/Notes/Summary/高频点.html">
        高频点
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ifan/assets/js/app.5e29002d.js" defer></script><script src="/ifan/assets/js/2.733019b2.js" defer></script><script src="/ifan/assets/js/58.2f387033.js" defer></script>
  </body>
</html>
