<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java集合 | Notes</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="办法总比问题多">
    
    <link rel="preload" href="/ifan/assets/css/0.styles.d46f727e.css" as="style"><link rel="preload" href="/ifan/assets/js/app.1d8f04c4.js" as="script"><link rel="preload" href="/ifan/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/ifan/assets/js/18.903829cf.js" as="script"><link rel="prefetch" href="/ifan/assets/js/10.9d2debbc.js"><link rel="prefetch" href="/ifan/assets/js/100.ce0650f4.js"><link rel="prefetch" href="/ifan/assets/js/11.b481b7e3.js"><link rel="prefetch" href="/ifan/assets/js/12.a1c93484.js"><link rel="prefetch" href="/ifan/assets/js/13.d78e499d.js"><link rel="prefetch" href="/ifan/assets/js/14.0d2150b9.js"><link rel="prefetch" href="/ifan/assets/js/15.01c694bf.js"><link rel="prefetch" href="/ifan/assets/js/16.d9b12807.js"><link rel="prefetch" href="/ifan/assets/js/17.43c1b0bd.js"><link rel="prefetch" href="/ifan/assets/js/19.b1444637.js"><link rel="prefetch" href="/ifan/assets/js/20.efcc37f6.js"><link rel="prefetch" href="/ifan/assets/js/21.81da4056.js"><link rel="prefetch" href="/ifan/assets/js/22.2fa41b40.js"><link rel="prefetch" href="/ifan/assets/js/23.f343dea3.js"><link rel="prefetch" href="/ifan/assets/js/24.25c61120.js"><link rel="prefetch" href="/ifan/assets/js/25.9cb69cdb.js"><link rel="prefetch" href="/ifan/assets/js/26.1c1a1096.js"><link rel="prefetch" href="/ifan/assets/js/27.3e698f68.js"><link rel="prefetch" href="/ifan/assets/js/28.63f7f11e.js"><link rel="prefetch" href="/ifan/assets/js/29.8a400aa1.js"><link rel="prefetch" href="/ifan/assets/js/3.06be9fda.js"><link rel="prefetch" href="/ifan/assets/js/30.dd445b3e.js"><link rel="prefetch" href="/ifan/assets/js/31.21730518.js"><link rel="prefetch" href="/ifan/assets/js/32.698329c5.js"><link rel="prefetch" href="/ifan/assets/js/33.7fcf3386.js"><link rel="prefetch" href="/ifan/assets/js/34.3e9cf496.js"><link rel="prefetch" href="/ifan/assets/js/35.a5f742a8.js"><link rel="prefetch" href="/ifan/assets/js/36.5cdf7c9c.js"><link rel="prefetch" href="/ifan/assets/js/37.92b7c857.js"><link rel="prefetch" href="/ifan/assets/js/38.de0727c0.js"><link rel="prefetch" href="/ifan/assets/js/39.cd1d4ee5.js"><link rel="prefetch" href="/ifan/assets/js/4.0dd8aefa.js"><link rel="prefetch" href="/ifan/assets/js/40.e2d55b45.js"><link rel="prefetch" href="/ifan/assets/js/41.6fc8c625.js"><link rel="prefetch" href="/ifan/assets/js/42.f5669db3.js"><link rel="prefetch" href="/ifan/assets/js/43.0d002814.js"><link rel="prefetch" href="/ifan/assets/js/44.59193229.js"><link rel="prefetch" href="/ifan/assets/js/45.3933ef6d.js"><link rel="prefetch" href="/ifan/assets/js/46.1d702023.js"><link rel="prefetch" href="/ifan/assets/js/47.61263332.js"><link rel="prefetch" href="/ifan/assets/js/48.d1910cf7.js"><link rel="prefetch" href="/ifan/assets/js/49.ba295b07.js"><link rel="prefetch" href="/ifan/assets/js/5.14db227c.js"><link rel="prefetch" href="/ifan/assets/js/50.48945079.js"><link rel="prefetch" href="/ifan/assets/js/51.922c4a4a.js"><link rel="prefetch" href="/ifan/assets/js/52.90c41fbb.js"><link rel="prefetch" href="/ifan/assets/js/53.5b1ba980.js"><link rel="prefetch" href="/ifan/assets/js/54.8e84c44d.js"><link rel="prefetch" href="/ifan/assets/js/55.c277b13f.js"><link rel="prefetch" href="/ifan/assets/js/56.6d8a04a9.js"><link rel="prefetch" href="/ifan/assets/js/57.021c1663.js"><link rel="prefetch" href="/ifan/assets/js/58.099f7ab4.js"><link rel="prefetch" href="/ifan/assets/js/59.e19ec6bd.js"><link rel="prefetch" href="/ifan/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/ifan/assets/js/60.4ece97ff.js"><link rel="prefetch" href="/ifan/assets/js/61.72dd49dc.js"><link rel="prefetch" href="/ifan/assets/js/62.2212d8af.js"><link rel="prefetch" href="/ifan/assets/js/63.cd2240fd.js"><link rel="prefetch" href="/ifan/assets/js/64.266f0c5f.js"><link rel="prefetch" href="/ifan/assets/js/65.e5dd692b.js"><link rel="prefetch" href="/ifan/assets/js/66.e97c1fb7.js"><link rel="prefetch" href="/ifan/assets/js/67.c99c58ad.js"><link rel="prefetch" href="/ifan/assets/js/68.1c7b8840.js"><link rel="prefetch" href="/ifan/assets/js/69.b1ce3ceb.js"><link rel="prefetch" href="/ifan/assets/js/7.54611d34.js"><link rel="prefetch" href="/ifan/assets/js/70.742be5c0.js"><link rel="prefetch" href="/ifan/assets/js/71.50dee511.js"><link rel="prefetch" href="/ifan/assets/js/72.0653d81c.js"><link rel="prefetch" href="/ifan/assets/js/73.7a6b4080.js"><link rel="prefetch" href="/ifan/assets/js/74.200096d7.js"><link rel="prefetch" href="/ifan/assets/js/75.7ad0d457.js"><link rel="prefetch" href="/ifan/assets/js/76.4dae384f.js"><link rel="prefetch" href="/ifan/assets/js/77.d23e58be.js"><link rel="prefetch" href="/ifan/assets/js/78.30da3aa8.js"><link rel="prefetch" href="/ifan/assets/js/79.77a53c0e.js"><link rel="prefetch" href="/ifan/assets/js/8.3c3e2ed8.js"><link rel="prefetch" href="/ifan/assets/js/80.3b3507b6.js"><link rel="prefetch" href="/ifan/assets/js/81.0633d028.js"><link rel="prefetch" href="/ifan/assets/js/82.3bb840ca.js"><link rel="prefetch" href="/ifan/assets/js/83.71d297d6.js"><link rel="prefetch" href="/ifan/assets/js/84.67ddf266.js"><link rel="prefetch" href="/ifan/assets/js/85.88236cdb.js"><link rel="prefetch" href="/ifan/assets/js/86.c46c3552.js"><link rel="prefetch" href="/ifan/assets/js/87.ed3b9cdf.js"><link rel="prefetch" href="/ifan/assets/js/88.9717ca00.js"><link rel="prefetch" href="/ifan/assets/js/89.7dd65246.js"><link rel="prefetch" href="/ifan/assets/js/9.46fdf317.js"><link rel="prefetch" href="/ifan/assets/js/90.48ce955c.js"><link rel="prefetch" href="/ifan/assets/js/91.e833ee44.js"><link rel="prefetch" href="/ifan/assets/js/92.b9973f76.js"><link rel="prefetch" href="/ifan/assets/js/93.d07c4aae.js"><link rel="prefetch" href="/ifan/assets/js/94.6980a27c.js"><link rel="prefetch" href="/ifan/assets/js/95.4cb983e3.js"><link rel="prefetch" href="/ifan/assets/js/96.54504fb8.js"><link rel="prefetch" href="/ifan/assets/js/97.ce4e7809.js"><link rel="prefetch" href="/ifan/assets/js/98.7b7b8e3c.js"><link rel="prefetch" href="/ifan/assets/js/99.023a5792.js">
    <link rel="stylesheet" href="/ifan/assets/css/0.styles.d46f727e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ifan/" class="home-link router-link-active"><!----> <span class="site-name">Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ifan/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="what?" class="dropdown-title"><span class="title">what?</span> <span class="arrow down"></span></button> <button type="button" aria-label="what?" class="mobile-dropdown-title"><span class="title">what?</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/ifan/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="what?" class="dropdown-title"><span class="title">what?</span> <span class="arrow down"></span></button> <button type="button" aria-label="what?" class="mobile-dropdown-title"><span class="title">what?</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/IFANx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JVM</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ifan/Notes/JVM/java的反射机制.html" class="sidebar-link">java的反射机制</a></li><li><a href="/ifan/Notes/JVM/Java集合.html" class="active sidebar-link">Java集合</a></li><li><a href="/ifan/Notes/JVM/Java常用机制-SPI机制.html" class="sidebar-link">Java常用机制-SPI机制</a></li><li><a href="/ifan/Notes/JVM/ThreadLocal.html" class="sidebar-link">ThreadLocal</a></li><li><a href="/ifan/Notes/JVM/JVM相关.html" class="sidebar-link">JVM相关</a></li><li><a href="/ifan/Notes/JVM/Java基础.html" class="sidebar-link">Java基础</a></li><li><a href="/ifan/Notes/JVM/JUC.html" class="sidebar-link">JUC</a></li><li><a href="/ifan/Notes/JVM/Java注解.html" class="sidebar-link">Java注解</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Maven</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>软件测试相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringBoot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MySQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Netty</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Summary</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java IO</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础和原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Notes</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java集合"><a href="#java集合" class="header-anchor">#</a> Java集合</h1> <p><strong>1、说说常见的集合有哪些？</strong></p> <p>Collection接口和Map接口是所有集合框架的父接口</p> <p>Collection接口的子接口包括：List、Set。list是一个有序的集合且可以包含重复的元素。set不可包含重复的元素。</p> <p>Map接口的子接口包括：HashMap、Hashtable、ConcurrentHashMap以及TreeMap。</p> <p>List集合的实现类主要有：ArrayList、LinkedList、Vector、Stack等</p> <p>Set集合的实现类主要由：HashSet及其子类LinkedHashSet（底层是链表）、TreeSet等</p> <p><strong>2、哪些集合类可对元素的随机访问？</strong></p> <p><strong>ArrayList、HashMap、TreeMap和HashTable</strong>类提供对元素的随机访问。</p> <p><strong>3、Comparable 和 Comparator 接口的区别？</strong></p> <p>Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。</p> <p>Comparator位于包java.util下，而Comparable位于包  java.lang下</p> <p>Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer 自己就可以完成比较大小操作，已经实现了Comparable接口）<br>
自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序，如API所说：
Sorts the specified list into ascending order, according to the natural ordering of its elements. All elements in the list must implement the Comparable interface
这里的自然顺序就是实现Comparable接口设定的排序方式。</p> <p>而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。</p> <p>可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token number">1.</span> <span class="token class-name">Comparator</span> 和 <span class="token class-name">Comparable</span> 相同的地方

他们都是java的一个接口<span class="token punctuation">,</span> 并且是用来对自定义的<span class="token keyword">class</span>比较大小的<span class="token punctuation">,</span>

什么是自定义<span class="token keyword">class</span><span class="token operator">:</span> 如 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span> <span class="token keyword">int</span> age <span class="token punctuation">}</span><span class="token punctuation">.</span>

当我们有这么一个personList<span class="token punctuation">,</span>里面包含了person1<span class="token punctuation">,</span> person2<span class="token punctuation">,</span> persion3<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> 我们用<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span> personList <span class="token punctuation">)</span><span class="token punctuation">,</span> 
是得不到预期的结果的<span class="token punctuation">.</span> 这时肯定有人要问<span class="token punctuation">,</span> 那为什么可以排序一个字符串list呢<span class="token operator">:</span>

如 <span class="token class-name">StringList</span><span class="token punctuation">{</span><span class="token string">&quot;hello1&quot;</span> <span class="token punctuation">,</span> <span class="token string">&quot;hello3&quot;</span> <span class="token punctuation">,</span> <span class="token string">&quot;hello2&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span> stringList <span class="token punctuation">)</span> 能够得到正确的排序<span class="token punctuation">,</span> 那是因为 
<span class="token class-name">String</span> 这个对象已经帮我们实现了 <span class="token class-name">Comparable</span>接口 <span class="token punctuation">,</span> 所以我们的 <span class="token class-name">Person</span> 如果想排序<span class="token punctuation">,</span> 也要实现一个比较器。
   
<span class="token number">2.</span> <span class="token class-name">Comparator</span> 和 <span class="token class-name">Comparable</span> 的区别

<span class="token class-name">Comparable</span>

<span class="token class-name">Comparable</span> 定义在 <span class="token class-name">Person</span>类的内部<span class="token operator">:</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Persion</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span>比较<span class="token class-name">Person</span>的大小<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">,</span>

 因为已经实现了比较器<span class="token punctuation">,</span>那么我们的<span class="token class-name">Person</span>现在是一个可以比较大小的对象了<span class="token punctuation">,</span>它的比较功能和<span class="token class-name">String</span>完全一样<span class="token punctuation">,</span>可以随时随地的拿来
比较大小<span class="token punctuation">,</span>因为<span class="token class-name">Person</span>现在自身就是有大小之分的。<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>personList<span class="token punctuation">)</span>可以得到正确的结果。

<span class="token class-name">Comparator</span>

<span class="token class-name">Comparator</span> 是定义在<span class="token class-name">Person</span>的外部的<span class="token punctuation">,</span> 此时我们的<span class="token class-name">Person</span>类的结构不需要有任何变化<span class="token punctuation">,</span>如

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span> <span class="token keyword">int</span> age <span class="token punctuation">}</span><span class="token punctuation">,</span>

然后我们另外定义一个比较器<span class="token operator">:</span>

<span class="token keyword">public</span> <span class="token class-name">PersonComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span>比较<span class="token class-name">Person</span>的大小<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">,</span>

在<span class="token class-name">PersonComparator</span>里面实现了怎么比较两个<span class="token class-name">Person</span>的大小<span class="token punctuation">.</span> 所以<span class="token punctuation">,</span>用这种方法<span class="token punctuation">,</span>当我们要对一个 personList进行排序的时候<span class="token punctuation">,</span> 
我们除了了要传递personList过去<span class="token punctuation">,</span> 还需要把<span class="token class-name">PersonComparator</span>传递过去<span class="token punctuation">,</span>因为怎么比较<span class="token class-name">Person</span>的大小是在<span class="token class-name">PersonComparator</span>
里面实现的<span class="token punctuation">,</span> 如<span class="token operator">:</span>

<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span> personList <span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">PersonComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">.</span>

<span class="token number">3.</span> <span class="token class-name">Comparator</span> 和 <span class="token class-name">Comparable</span> 的实例

<span class="token class-name">Comparable</span><span class="token operator">:</span>

实现<span class="token class-name">Comparable</span>接口要覆盖compareTo方法<span class="token punctuation">,</span> 在compareTo方法里面实现比较：
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span>
     <span class="token class-name">String</span> name<span class="token punctuation">;</span>
     <span class="token keyword">int</span> age
     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Person</span> another<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          i <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用字符串的比较</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果名字一样,比较年龄, 返回比较年龄结果</span>
               <span class="token keyword">return</span> age <span class="token operator">-</span> another<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
               <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment">// 名字不一样, 返回比较名字的结果.</span>
          <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
   这时我们可以直接用 <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span> personList <span class="token punctuation">)</span> 对其排序了<span class="token punctuation">.</span>

<span class="token class-name">Comparator</span><span class="token operator">:</span>

实现<span class="token class-name">Comparator</span>需要覆盖 compare 方法：
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
     <span class="token class-name">String</span> name<span class="token punctuation">;</span>
     <span class="token keyword">int</span> age
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">PersonComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span> <span class="token punctuation">{</span> 
     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Person</span> one<span class="token punctuation">,</span> <span class="token class-name">Person</span> another<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          i <span class="token operator">=</span> one<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用字符串的比较</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果名字一样,比较年龄,返回比较年龄结果</span>
               <span class="token keyword">return</span> one<span class="token punctuation">.</span>age <span class="token operator">-</span> another<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
               <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment">// 名字不一样, 返回比较名字的结果.</span>
          <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
   <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span> personList <span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">PersonComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 可以对其排序

 <span class="token number">4</span><span class="token operator">:</span>总结

两种方法各有优劣<span class="token punctuation">,</span> 用<span class="token class-name">Comparable</span> 简单<span class="token punctuation">,</span> 只要实现<span class="token class-name">Comparable</span> 接口的对象直接就成为一个可以比较的对象<span class="token punctuation">,</span>
但是需要修改源代码<span class="token punctuation">,</span> 用<span class="token class-name">Comparator</span> 的好处是不需要修改源代码<span class="token punctuation">,</span> 而是另外实现一个比较器<span class="token punctuation">,</span> 当某个自定义
的对象需要作比较的时候<span class="token punctuation">,</span>把比较器和对象一起传递过去就可以比大小了<span class="token punctuation">,</span> 并且在<span class="token class-name">Comparator</span> 里面用户可以自己实现复杂的可以通用的逻辑<span class="token punctuation">,</span>使其可以匹配一些比较简单的对象<span class="token punctuation">,</span>那样就可以节省很多重复劳动了。
</code></pre></div><p>想要实现类的比较，可以选择实现comparable接口，重写对应的compareTo方法。或者，实现新建一个实现Comparator接口的类（即单独的一个比较器），用这个比较器对原来的class进行比较。</p> <p><strong>4、Collection 和 Collections 的区别？</strong></p> <p>1、java.util.Collection 是一个<strong>集合接口（集合类的一个顶级接口）</strong>。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p> <p>2、java.util.Collections 是一个<strong>包装类（工具类/帮助类）</strong>。它包含有各种有关集合操作的<strong>静态多态方法</strong>。此类<strong>不能实例化</strong>，就像一<strong>个工具类</strong>，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。</p> <p><strong>5、Enumeration 和 Iterator 接口的区别？</strong></p> <p>从源码可以看出，Iterator除了能读取集合的数据之外，也能数据进行删除操作；而Enumeration只能读取集合的数据，而不能对数据进行修改。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">Consumer</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">//返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型</span>
    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//判断容器内是否还有可供访问的元素,返回值是E</span>
    <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　 　<span class="token comment">//删除迭代器刚越过的元素</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">&quot;remove&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Enumeration</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    
    <span class="token keyword">boolean</span> <span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">E</span> <span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Iterator支持fail-fast机制，而Enumeration不支持fail-fast机制。Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的。Iterator是JDK1.2添加的接口，Iterator是基于Enumeration实现的，同时Iterator支持fail-fast机制，所以Iterator遍历集合时会比Enumeration遍历集合慢一些。</p> <p><strong>6、集合使用泛型有什么优点？</strong></p> <ol><li><p>可以只容纳指定类型的对象</p></li> <li><p>避免了在运行时出现<a href="https://so.csdn.net/so/search?q=ClassCastException&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">ClassCastException<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，在编译时会报错</p></li> <li><p>泛型也使得代码整洁，使用时不需要显式转换和instanceOf 操作符</p></li> <li><p>也优化了运行时,因为它不会产生类型检查的字节码指令</p></li></ol> <p><strong>7、List、Set、Map 之间的区别是什么？</strong></p> <p>List(列表)            																																																								List的元素以线性方式存储，可以存放重复对象，List主要有以下两个实现类：</p> <p>ArrayList : 长度可变的数组，可以对元素进行随机的访问，向ArrayList中插入与删除元素的速度慢。 JDK8 中ArrayList扩容的实现是通过grow()方法里使用语句newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)（即1.5倍扩容）计算容量，然后调用Arrays.copyof()方法进行对原数组进行复制。                                    LinkedList: 采用链表数据结构，插入和删除速度快，但访问速度慢。</p> <p>Set(集合)
Set中的对象不按特定(HashCode)的方式排序，并且没有重复对象，Set主要有以下两个实现类：</p> <p>HashSet： HashSet按照哈希算法来存取集合中的对象，存取速度比较快。当HashSet中的元素个数超过数组大小*loadFactor（默认值为0.75）时，就会进行近似两倍扩容（newCapacity = (oldCapacity &lt;&lt; 1) + 1）。
TreeSet ：TreeSet实现了SortedSet接口，能够对集合中的对象进行排序。</p> <p>Map(映射)
Map是一种把键对象和值对象映射的集合，它的每一个元素都包含一个键对象和值对象。 Map主要有以下两个实现类：</p> <p>HashMap：HashMap基于散列表实现，其插入和查询&lt;K,V&gt;的开销是固定的，可以通过构造器设置容量和负载因子来调整容器的性能。
LinkedHashMap：类似于HashMap，但是迭代遍历它时，取得&lt;K,V&gt;的顺序是其插入次序，或者是最近最少使用(LRU)的次序。
TreeMap：TreeMap基于红黑树实现。查看&lt;K,V&gt;时，它们会被排序。TreeMap是唯一的带有subMap()方法的Map，subMap()可以返回一个子树。</p> <p>HashMap：底层实现：HashMap底层整体结构是一个数组，数组中的每个元素又是一个链表。每次添加一个对象（put）时会产生一个链表对象（Object类型），Map中的每个Entry就是数组中的一个元素（Map.Entry就是一个&lt;Key,Value&gt;），它具有由当前元素指向下一个元素的引用，这就构成了链表。</p> <p><strong>8、为什么 Map 接口不继承 Collection 接口？</strong></p> <p>首先Map提供的是键值对映射（即Key和value的映射），而collection提供的是一组数据（并不是键值对映射）。如果map继承了collection接口，那么所有实现了map接口的类到底是用map的键值对映射数据还是用collection的一组数据呢（就我们平常所用的hashMap、hashTable、treeMap等都是键值对，所以它继承collection完全没意义），而且map如果继承了collection接口的话还违反了面向对象的接口分离原则。</p> <p>接口分离原则：客户端不应该依赖它不需要的接口。另一种定义是：类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署，让客户端依赖的接口尽可能地小。</p> <p>Map和List、set不同，Map放的是键值对，list、set放的是一个个的对象。说到底是因为数据结构不同，数据结构不同，操作就不一样，所以接口是分开的。还是接口分离原则</p> <p><strong>9、常用的线程安全的 Map 有哪些？</strong></p> <ul><li><p>Hashtable、</p></li> <li><p>synchronizedMap、</p></li> <li><p>ConcurrentHashMap。</p> <p>同步的map就是Hashtable, concurrenthashmap。</p> <p>你看到的Hashtable就是直接在hashmap上加了个锁，concurrenthashmap就是分成多个分段锁。</p></li></ul> <p><strong>绝对线程安全。</strong></p> <p>在任何环境下，调用者都不需要考虑额外的同步措施，都能够保证程序的正确性。</p> <p>这个定义要求很严格，java里面满足这个要求的类比较少，对于实现jsr133规范（java内存模型）的jdk（一般指jdk5.0之上），一般的不变类都是满足绝地线程安全的。比如 String，Integer类。<strong>一般情况下，定义了如果一个类里面所有字段都是final类型的，一般都认为这个类是不变的。不变类都是绝对线程安全的。</strong></p> <p><strong>相对线程安全</strong></p> <p>在一般情况下，调用者都不需要考虑线程同步，大多数情况下，都能够正常运行。jdk里面大多数类都是相对安全的。最常见的例子是java里面Vector类。</p> <p><strong>10、HashMap 与 Hashtable 的区别？</strong></p> <p><strong>hashmap</strong>：<strong>HashMap</strong>是一个不同步的Map，这意味着<strong>HashMap</strong>不是线程安全的，如果没有适当的同步代码，则无法在多个线程之间共享。</p> <p><strong>hashtable</strong>：<strong>Hashtable</strong>是一个同步的Map，<strong>Hashtable</strong>是线程安全的，可以在多个线程之间共享。</p> <p>1、哈希计算方法不同；2、键值是否可以为空值；3、实现方式不同；4、初始化容量不同；5、扩容机制不同；6、支持的遍历种类不同；7、迭代器不同；8、添加key-value的hash值算法不同；9、部分API不同；10、同步性不同；11、性能不同。哈希计算方法不同是指hashmap在取模之前进行二次hash。</p> <p><strong>hashmap</strong>：HashMap 的初始容量为：16。</p> <p><strong>hashtable</strong>：Hashtable 初始容量为：11。</p> <p>两者的负载因子默认都是：0.75</p> <p><strong>hashmap</strong>：HashMap只支持Iterator遍历。</p> <p><strong>hashtable</strong>：HashTable支持Iterator和Enumeration两种方式遍历。</p> <p><strong>hashmap</strong>：HashMap的迭代器(Iterator)是fail-fast迭代器，所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。而Hashtable 则不会。</p> <p><strong>hashtable</strong>：Hashtable的enumerator迭代器不是fail-fast的。</p> <p><strong>11、HashMap 和 TreeMap 怎么选？</strong></p> <p><code>TreeMap&lt;K,V&gt;</code>的Key值是要求实现<code>java.lang.Comparable</code>，所以迭代的时候TreeMap默认是按照Key值升序排序的；TreeMap的实现是基于红黑树结构。适用于按自然顺序或自定义顺序遍历键（key）。</p> <p><code>HashMap&lt;K,V&gt;</code>的Key值实现散列<code>hashCode()</code>，分布是散列的、均匀的，不支持排序；数据结构主要是桶(数组)，链表或红黑树。适用于在Map中插入、删除和定位元素。</p> <p><strong>结论</strong></p> <p>如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap。</p> <p><strong>12、HashMap 的数据结构是什么？</strong></p> <p>HashMap 的结构，是数组+链表+红黑树的结构，草图可以见下图。</p> <p><img src="http://8.130.25.175:8080/img/image-20230523200236738.png" alt="image-20230523200236738"></p> <p>从上图可看出，HashMap 底层是一个哈希桶数组，名为 table，数组内存储的是基于 Node 类型的数据，所以，这个 <strong>Node</strong> 甚为关键，下文会详解。</p> <p>然后同一个数组所以的位置可以存储多个 Node，并以链表或红黑树的形式来实现，所以很容易猜到，既然是链表，那么每个 Node 必然会记录下一个 Node。但是如果链表很长，那查询效率便会降低，所以自 JDK1.8 开始便引入了红黑树，即当链表长度超过 8 的时候，链表便会转为红黑树，另外，当链表长度小于 6 的时候，会从红黑树转为链表。</p> <p><strong>13、HashMap 在 JDK 8 中有哪些改变？</strong></p> <p><strong>14、HashMap 的 put 方法逻辑？</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token comment">//首先判断当前哈希表是否已经被初始化，没有的话使用resize（）方法初始化</span>
    <span class="token comment">//jdk1.8哈希表的初始化在第一次调用put（）方法时初始化而并非在构造函数中</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">//走到这里表明已经被初始化，这时判断table【inde】位置是否为空，如果为空的话直接新</span>
    <span class="token comment">//new一个节点放入</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//否则说明此处已经存在数据，    </span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
        <span class="token comment">//首先需要判断当前已存在的元素（也就是第一个节点）是否与要插入的元素key值是否相等，如果相等</span>
        <span class="token comment">//则将当前p节点的值保存在e节点中</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span><span class="token comment">//由于不同对象的hashcode可能相等，所以及比较hash也比较key</span>
                <span class="token comment">//并且||前面的比较比||后面的比较方法高效，而且保证后面的比较有意义</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment">//如果不满足上述条件，会判断当前节点是否为树形节点，如果是树形节点，</span>
        <span class="token comment">//那么直接使用红黑树的插入逻辑插入</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">//这里的for循环是用来统计当前节点个数是否达到了要转换为红黑树的阈值</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//这个if是用来判断当前是否只有一个节点或者说是走到了最后一个节点</span>
                    <span class="token comment">//那么直接尾插法插入就行了</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">//这里如果节点数达到了要转换为红黑树的阈值</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st								//采用红黑树插入方法</span>
                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">//这个if也就是在遍历链表的过程中看是否有key相等的节点</span>
                    <span class="token comment">//如果有的话则直接break，在最后进行赋值</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                   <span class="token comment">//否则e继续走向下一个节点</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token comment">//这里对之前保存的节点e进行判断并且进行最后赋值</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>
                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
        <span class="token comment">//JDK1.8里的hashMap先插入后扩容，这里进行判断是否需要扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre></div><p><strong>15、HashMap 的 get 方法逻辑？</strong></p> <p>首先根据 hash 方法获取到 key 的 hash 值
然后通过 hash &amp; (length - 1) 的方式获取到 key 所对应的Node数组下标 ( length对应数组长度 )
首先判断此结点是否为空，是否就是要找的值，是则返回空，否则进入第二个结点。
接着判断第二个结点是否为空，是则返回空，不是则判断此时数据结构是链表还是红黑树
链表结构进行顺序遍历查找操作，每次用 == 符号 和 equals( ) 方法来判断 key 是否相同，满足条件则直接返回该结点。链表遍历完都没有找到则返回空。
红黑树结构执行相应的 getTreeNode( ) 查找操作。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
    
    <span class="token comment">//Node数组不为空，数组长度大于0，数组对应下标的Node不为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token comment">//也是通过 hash &amp; (length - 1) 来替代 hash % length 的</span>
        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
        <span class="token comment">//先和第一个结点比，hash值相等且key不为空，key的第一个结点的key的对象地址和值均相等</span>
        <span class="token comment">//则返回第一个结点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment">// always check first node</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> first<span class="token punctuation">;</span>
        <span class="token comment">//如果key和第一个结点不匹配，则看.next是否为空，不为null则继续，为空则返回null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//如果此时是红黑树的结构，则进行处理getTreeNode()方法搜索key</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//是链表结构的话就一个一个遍历，直到找到key对应的结点，</span>
            <span class="token comment">//或者e的下一个结点为null退出循环</span>
            <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>16、HashMap 是线程安全的吗？</strong></p> <p><strong>HashMap 是线程不安全的</strong>。 JDK 1.7 HashMap 采用数组+ 链表的数据结构，多线程背景下，在数组扩容的时候，存在Entry 链死循环和数据丢失问题。 JDK 1.8 HashMap 采用数组+ 链表+ 红黑二叉树的数据结构，优化了1.7 中数组扩容的方案，解决了Entry 链死循环和数据丢失问题。</p> <p>HashTable 是线程安全的。</p> <p>HashTable 容器使用 synchronized 来保证线程安全，但在线程竞争激烈的情况下 HashTable 的效率非常低下。因为当一个线程访问 HashTable 的同步方法，其他线程也访问 HashTable 的同步方法时，会进入阻塞或轮询状态。如线程1使用 put 进行元素添加，线程2不但不能使用 put 方法添加元素，也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> tab<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> table<span class="token punctuation">;</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span> <span class="token operator">%</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">V</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>17、HashMap 是怎么解决 hash 冲突的？</strong></p> <p>开放地址法（open addressing）</p> <p>简单来说就是通过计算出来冲突的hash值进行再次的运算，直到得到可用的地址，主要有以下3种：</p> <ul><li>线性探测再散列：发生冲突时，顺序查看哈希表下一单元是否可用，直到找到可用的单元</li> <li>二次探测再散列：发生冲突时，以冲突的位置为中心向左右探测是否有可用单元</li> <li>伪随机探测再散列：通过一组伪随机数列计算得到对应的单位位置</li></ul> <p>单独链表法</p> <p>就是在哈希表中，针对相同的hash值使用链表的方式来存放</p> <p>再散列</p> <p>提供多个hash函数，冲突时使用其他的hash函数再次运算</p> <p><strong>18、HashMap 是怎么扩容的？</strong></p> <p>HashMap 的底层用的也是数组。 向HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素。 当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要<strong>新建一个大的数组，然后把小数组的元素复制过去</strong>。</p> <p><strong>19、HashMap 如何实现同步?</strong></p> <p>HashMap可以通过Map m = Collections.synchronizedMap(new HashMap())来达到同步的效果。具体而言，该方法会返回一个同步的Map，该Map封装了底层的HashMap的所有方法，使得底层的HashMap即使在多线程的环境中也是安全的。</p> <p>2.1 使用Conllections.synchronizedMap()方法
2.2 使用ConcurrentHashMap
2.3 对操作Map的方法实现一个对象锁</p> <p><strong>20、HashMap 中的负载因子是什么？</strong></p> <p><strong>21、Hashtable 为什么不叫 HashTable？</strong></p> <p><strong>22、ConcurrentHashMap 的数据结构？</strong></p> <p>Jdk1.7</p> <p>1、HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁</p> <p>2、假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术</p> <p>a、首先将数据分成一段一段的存储</p> <p>b、然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</p> <p>c、有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁</p> <p>d、在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</p> <p>3、ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</p> <p>4、Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色</p> <p>5、HashEntry则用于存储键值对数据</p> <p>6、一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构</p> <p>7、一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p> <p>1.8版本的ConcurrentHashMap的实现与1.7版本有很大的差别，放弃了段锁的概念，借鉴了HashMap的数据结构：数组＋链表＋红黑树</p> <ul><li>ConcurrentHashMap不接受nullkey和nullvalue</li> <li>数据结构：数组＋链表＋红黑树</li> <li>并发原理：cas乐观锁+synchronized锁</li> <li>加锁对象：数组每个位置的头节点</li></ul> <p>ConcurrentHashMap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红黑树，红黑树是为了提高查找效率</p> <p><strong>23、ArrayList 是线程安全的么？</strong></p> <p>ArrayList是线程不安全的，Vector是线程安全的。</p> <p>Vector 的源码文档上直截了当地说了，“如果不需要线程安全，推荐使用 ArrayList 替代 Vector。”说实话，在我十多年的编程生涯中，的确很少使用 Vector，因为它的线程安全是建立在每个方法上都加了 synchronized 关键字的基础上，锁的粒度很高，意味着性能就不咋滴。SynchronizedList</p> <p>那有些同学可能会说，可以使用 Collections.synchronizedList() 让 ArrayList 变成线程安全啊。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>list <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">?</span>
            <span class="token keyword">new</span> <span class="token class-name">Collections<span class="token punctuation">.</span>SynchronizedRandomAccessList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token operator">:</span>
            <span class="token keyword">new</span> <span class="token class-name">Collections<span class="token punctuation">.</span>SynchronizedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>无论是 SynchronizedRandomAccessList 还是 SynchronizedList，它们都没有在方法级别上使用 synchronized 关键字，而是在方法体内使用了 synchronized(this) 块。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>24、常用的线程安全的 List 集合有哪些？</strong></p> <ul><li>使用Vector容器</li> <li>使用Collections的静态方法synchronizedList(<strong>List</strong>&lt; T&gt; <strong>list</strong>)</li> <li>采用CopyOnWriteArrayList容器</li></ul> <p><strong>25、循环删除 List 集合可能会发生什么异常？</strong></p> <p>循环删除List集合可能会发生什么异常？
lndexOutOfBoundsException
lndexOutOfBoundsException我们很理解，是动态删除元素导致数组下标越界了。</p> <p>ConcurrentModificationException
调用list.remove()方法导致modCount和expectedModCount的值不一致。
改变集合时，取下个元素的时候都会去判断要修改的数量和期待修改的数量是否一致，不一致则会报错。</p> <p><strong>26、ArrayList 和 LinkedList 的区别？</strong></p> <ol><li><p>ArrayList与LinkedList 主要区别</p></li> <li><p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</p></li> <li><p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p></li> <li><p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p></li></ol> <p><strong>27、ArrayList 和 Vector 的区别？</strong></p> <ol><li>Vector和ArrayList几乎是一样的，区别在于Vector是<strong>线程安全</strong>的，因为这个原因，它的性能较ArrayList差。通常情况下，大部分程序员都使用ArrayList，而不是Vector，因为他们可以自己做出明确的同步操作。</li> <li>Vector 类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。但是，Vector 的大小可以根据需要增大或缩小，以适应创建 Vector 后进行添加或移除项的操作。</li> <li>每个向量会试图通过维护 capacity 和 capacityIncrement 来优化存储管理。capacity 始终至少应与向量的大小相等；这个值通常比后者大些，因为随着将组件添加到向量中，其存储将按 capacityIncrement 的大小增加存储块。应用程序可以在插入大量组件前增加向量的容量；这样就减少了增加的重分配的量。</li></ol> <p><strong>28、什么是 CopyOnWriteArrayList？</strong></p> <p>CopyOnWriteArrayList 是 Java 并发包 java.util.concurrent 中提供的并发容器，本质上是一个线程安全且读操作无锁的 ArrayList。它在确保线程安全的前提下，通过牺牲写操作的效率来保证读操作的高效。</p> <p>所谓 CopyOnWrite 就是通过复制的方式来完成对数据的修改，在修改时复制一个新的数组，在上面进行修改，不会对旧的数组进行改变，也就没有读写数据不一致的问题了。</p> <p>优点</p> <p>读操作性能高
因为无需任何同步措施，比较适用于读多写少的并发场景。</p> <p>迭代器遍历不会抛出异常
遍历 ArrayList 时，若中途有别的线程对其修改，则会抛出 ConcurrentModificationException 异常。而 CopyOnWriteArrayList 由于其&quot;读写分离&quot;的思想，它的遍历和修改操作分别作用在不同的 list 容器上，所以在使用迭代器遍历时，不会抛出 ConcurrentModificationException 异常。</p> <p>缺点</p> <p>内存占用大
每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC；</p> <p>无法保证实时性
CopyOnWriteArrayList 的写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞，所以读取到的是老容器的数据，无法保证数据的实时性。</p> <p><strong>29、什么是 fail-safe？</strong></p> <p>fail-safe 是指安全失败机制，对集合进行遍历操作的时候，它不是遍历集合本身，而是先拷贝一份集合，然后遍历这个集合。</p> <p><strong>30、什么是 fail-fast？</strong></p> <p>fail-fast的字面意思是“快速失败”。当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构被改变的话，就会抛出异常，防止继续遍历。这就是所谓的快速失败机制。</p> <p>稍微总结下：fail-fast,即快速失败机制，它是java集合中的一种错误检测机制，当多个线程（当个线程也是可以滴）,在结构上对集合进行改变时，就有可能会产生fail-fast机制。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            temp<span class="token operator">++</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            temp<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//结果java.util.ConcurrentModificationException</span>
<span class="token comment">//结果分析：因为当temp==3的时候，执行list.remove()方法，集合的结构被改变了，所以再次遍历迭代器的时候，就会抛出异常。</span>
分析：从源码我们可以发现，迭代器在执行<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>等方法的时候，都会调用<span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span>这个方法，查看modCount<span class="token operator">==</span>expectedModCount<span class="token operator">?</span>如果相等则抛出异常。

expectedModcount<span class="token operator">:</span>这个值在对象被创建的时候就被赋予了一个固定的值modCount。也就是说这个值是不变的。也就是说，如果在迭代器遍历元素的时候，如果modCount这个值发生了改变，那么再次遍历时就会抛出异常。
</code></pre></div><p><strong>31、fail-fast 与 fail-safe 有什么区别？</strong></p> <p>当我们对集合结构上做出改变的时候，fail-fast机制就会抛出异常。但是，对于采用fail-safe机制来说，就不会抛出异常(大家估计看到safe两个字就知道了)。</p> <p>这是因为，当集合的结构被改变的时候，fail-safe机制会在复制原集合的一份数据出来，然后在复制的那份数据遍历。</p> <p>因此，虽然fail-safe不会抛出异常，但存在以下缺点</p> <ol><li><p>复制时需要额外的空间和时间上的开销。</p></li> <li><p>不能保证遍历的是最新内容。</p></li></ol> <p><strong>32、HashSet 的底层实现原理是什么？</strong></p> <p>HashSet 的内部采用了HashMap作为数据存储，HashSet其实就是在操作HashMap的key</p> <p>因为HashMap是无序的，因此HashSet也不能保证元素的顺序
因为HashSet中没有对应同步的操作，因此是线程不安全的
支持null元素(因为hashMap也支持null键和null值)</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>   
 <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>   
 <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>   
<span class="token punctuation">{</span>   
 <span class="token comment">// 使用 HashMap 的 key 保存 HashSet 中所有元素  </span>
 <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>   
 <span class="token comment">// 定义一个虚拟的 Object 对象作为 HashMap 的 value   </span>
 <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
 …   
 <span class="token comment">// 构造方法，初始化 HashSet，底层会初始化一个 HashMap   </span>
 <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 <span class="token comment">// 以指定的 initialCapacity、loadFactor 创建 HashSet   </span>
 <span class="token comment">// 其实就是以相应的参数创建 HashMap   </span>
 <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dummy<span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity   
         <span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 <span class="token comment">// 调用 map 的 keySet 来返回所有的 key   </span>
 <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 <span class="token comment">// 调用 HashMap 的 size() 方法返回 Entry 的数量，就得到该 Set 里元素的个数  </span>
 <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 <span class="token comment">// 调用 HashMap 的 isEmpty() 判断该 HashSet 是否为空，  </span>
 <span class="token comment">// 当 HashMap 为空时，对应的 HashSet 也为空  </span>
 <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 <span class="token comment">// 调用 HashMap 的 containsKey 判断是否包含指定 key   </span>
 <span class="token comment">//HashSet 的所有元素就是通过 HashMap 的 key 来保存的  </span>
 <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 <span class="token comment">// 将指定元素放入 HashSet 中，也就是将该元素作为 key 放入 HashMap   </span>
 <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 <span class="token comment">// 调用 HashMap 的 remove 方法删除指定 Entry，也就删除了 HashSet 中对应的元素  </span>
 <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token operator">==</span><span class="token constant">PRESENT</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 <span class="token comment">// 调用 Map 的 clear 方法清空所有 Entry，也就清空了 HashSet 中所有元素  </span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   
 <span class="token punctuation">{</span>   
     map<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
 <span class="token punctuation">}</span>   
 …   
<span class="token punctuation">}</span> 
</code></pre></div><p>HashSet中没有重复元素，允许有一个为null
HashSet底层使用了哈希表来支持的，特点：存储快
往Haset添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中 的存储位置。
1.如果算出的元素存储的位置目前没有任何元素存储，那么该元素可以直接存储在该位置上
2. 如果算出的元素的存储位置目前已经存在有其他的元素了，那么还会调用该元素的equals方法
与该位置的元素再比较一次，如果equals方法返回的是true，那么该位置上的元素视为重复元
素，不允许添加，如果返回的是false，则允许添加</p> <p>HashSet实现原理进行一个总结：
（1）基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</p> <p>（2）当我们试图把某个类的对象当成 HashMap的 key，或试图将这个类的对象放入 HashSet 中保存时，重写该类的equals(Object obj)方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode() 返回值的关键属性，都应该用于作为 equals() 比较的标准。</p> <p>（3）HashSet的其他操作都是基于HashMap的。</p> <p><strong>33、怎么确保一个集合不能被修改？</strong></p> <p>我们怎么确保一个[集合]不能被修改？首先我们要清楚，集合（map,set,list…）都是引用类型，所以我们如果用final修饰的话，集合里面的内容还是可以修改的。</p> <p>可以看到：我们用final关键字定义了一个map集合，这时候我们往集合里面传值，第一个键值对1,1；我们再修改后，可以把键为1的值改为100，说明我们是可以修改map集合的值的。</p> <p>那我们应该怎么做才能确保集合不被修改呢？
我们可以采用Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。
同理：Collections包也提供了对list和set集合的方法。
Collections.unmodifiableList(List)
Collections.unmodifiableSet(Set)</p> <p><img src="http://8.130.25.175:8080/img/image-20230523211912777.png" alt="image-20230523211912777"></p> <p>添加完元素之后，设置为unmodified之后再更新list就会出错了。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ifan/Notes/JVM/java的反射机制.html" class="prev">
        java的反射机制
      </a></span> <span class="next"><a href="/ifan/Notes/JVM/Java常用机制-SPI机制.html">
        Java常用机制-SPI机制
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ifan/assets/js/app.1d8f04c4.js" defer></script><script src="/ifan/assets/js/2.733019b2.js" defer></script><script src="/ifan/assets/js/18.903829cf.js" defer></script>
  </body>
</html>
